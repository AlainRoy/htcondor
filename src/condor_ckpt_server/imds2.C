/***************************Copyright-DO-NOT-REMOVE-THIS-LINE**
 * CONDOR Copyright Notice
 *
 * See LICENSE.TXT for additional notices and disclaimers.
 *
 * Copyright (c)1990-1998 CONDOR Team, Computer Sciences Department, 
 * University of Wisconsin-Madison, Madison, WI.  All Rights Reserved.  
 * No use of the CONDOR Software Program Source Code is authorized 
 * without the express consent of the CONDOR Team.  For more information 
 * contact: CONDOR Team, Attention: Professor Miron Livny, 
 * 7367 Computer Sciences, 1210 W. Dayton St., Madison, WI 53706-1685, 
 * (608) 262-0856 or miron@cs.wisc.edu.
 *
 * U.S. Government Rights Restrictions: Use, duplication, or disclosure 
 * by the U.S. Government is subject to restrictions as set forth in 
 * subparagraph (c)(1)(ii) of The Rights in Technical Data and Computer 
 * Software clause at DFARS 252.227-7013 or subparagraphs (c)(1) and 
 * (2) of Commercial Computer Software-Restricted Rights at 48 CFR 
 * 52.227-19, as applicable, CONDOR Team, Attention: Professor Miron 
 * Livny, 7367 Computer Sciences, 1210 W. Dayton St., Madison, 
 * WI 53706-1685, (608) 262-0856 or miron@cs.wisc.edu.
****************************Copyright-DO-NOT-REMOVE-THIS-LINE**/

#include "condor_common.h"
#include "condor_config.h"
#include "condor_debug.h"
#include "imds2.h"
#include "fileinfo2.h"
#include "fileindex2.h"


u_lint IMDS::GetNumFiles()
{
	return FileStats.GetNumFiles();
}


int IMDS::AddFile(struct in_addr machine_IP,
		  const char*    owner_name,
		  const char*    file_name,
		  u_lint         file_size,
		  file_state     state)
{
  file_node*      file_ptr;
  file_info_node* file_data;
  char            pathname[MAX_PATHNAME_LENGTH];

  file_ptr = Index.GetFileNode(machine_IP, owner_name, file_name);
  if (file_ptr != NULL)
    {
      file_data = file_ptr->file_data;
      sprintf(pathname, "%s%s/%s/%s", LOCAL_DRIVE_PREFIX, 
	      file_data->data.machine_IP_name, owner_name, file_name);
      if ((state == NOT_PRESENT) || (state == LOADING))
	remove(pathname);                        // Do not care if fails
      file_data->data.size = file_size;
      file_data->data.last_modified_time = time(NULL);
      file_data->data.state = state;
    }
  else
    {
      file_data = FileStats.AddFileInfo(machine_IP, owner_name, file_name, 
					file_size, state, NULL);
      (void) Index.AddNewFile(machine_IP, owner_name, file_name, file_data);
    }
  return CREATED;
}

#define ANALYZER_CKPT_DIR "/local.ostrich/johnbent/CKPTS/"
#define ANALYZER_ERRORS "/local.ostrich/johnbent/ERRS/errors"

int IMDS::RenameFile(struct in_addr machine_IP,
					 const char*    owner_name,
					 const char*    file_name,
					 const char*    new_file_name)
{
	file_node*      old_fn;
	file_node*      new_fn;
	file_info_node* old_file_ptr;
	file_info_node* new_file_ptr;
	char            new_pathname[MAX_PATHNAME_LENGTH];
	char            old_pathname[MAX_PATHNAME_LENGTH];
	char			new_link[MAX_PATHNAME_LENGTH];  // for diff. ckpt analysis
	char			old_link[MAX_PATHNAME_LENGTH];  // for diff. ckpt analysis
	
	old_fn = Index.GetFileNode(machine_IP, owner_name, file_name);
	if (old_fn == NULL)
		return DOES_NOT_EXIST;
	old_file_ptr = old_fn->file_data;
	sprintf(old_pathname, "%s%s/%s/%s", LOCAL_DRIVE_PREFIX, 
			old_file_ptr->data.machine_IP_name, owner_name, file_name);
	sprintf(new_pathname, "%s%s/%s/%s", LOCAL_DRIVE_PREFIX, 
			old_file_ptr->data.machine_IP_name, owner_name, new_file_name);
	new_fn = Index.GetFileNode(machine_IP, owner_name, new_file_name);
	if (new_fn == NULL) {
		if (rename(old_pathname, new_pathname) != 0)
			return CANNOT_RENAME_FILE;
		strncpy(old_file_ptr->data.machine_IP_name, new_file_name, 
				MAX_CONDOR_FILENAME_LENGTH);
		old_file_ptr->data.last_modified_time = time(NULL);
		(void) Index.AddNewFile(machine_IP, owner_name, new_file_name, 
								old_file_ptr);
    } else {
		new_file_ptr = new_fn->file_data;
		if (new_file_ptr->data.last_modified_time >
			old_file_ptr->data.last_modified_time)
			return CANNOT_RENAME_OVER_NEWER_FILE;
		/* create hard links for John Bent's diff. ckpting analysis */
		char * diff_ckpt_dir;
		if ( (diff_ckpt_dir = param("DIFF_CKPT_DIR")) != NULL) {
			dprintf( D_ALWAYS, "diff dir is %s\n", diff_ckpt_dir );
			sprintf(new_link, "%s%s%s%s", diff_ckpt_dir, 
				old_file_ptr->data.machine_IP_name, owner_name, 
				file_name);
			sprintf(old_link, "%s%s%s%s.tmp", diff_ckpt_dir, 
				old_file_ptr->data.machine_IP_name, owner_name, 
				file_name); 
			dprintf(D_ALWAYS,"making links to %s and %s\n", new_link, old_link);
			if (0 == LinkFile(old_pathname, old_link))	/* ignore failure */ 
				LinkFile(new_pathname, new_link);
			free( file_name );	
		} else {
			dprintf( D_ALWAYS, "imds2.C: diff dir param not found\n");
		} 
		/* create hard links for John Bent's diff. ckpting analysis */
		sprintf(new_link, "%s%s", ANALYZER_CKPT_DIR, file_name);
		sprintf(old_link, "%s%s.tmp", ANALYZER_CKPT_DIR, file_name); 
		if (0 == LinkFile(old_pathname, old_link)) 
			LinkFile(new_pathname, new_link);
		if (rename(old_pathname, new_pathname) != 0)
			return CANNOT_RENAME_FILE;
		new_file_ptr->data.size = old_file_ptr->data.size;
		new_file_ptr->data.state = old_file_ptr->data.state;
		new_file_ptr->data.last_modified_time = time(NULL);
		(void) FileStats.RemoveFileInfo(NULL);
    }
	(void) Index.DeleteFile(machine_IP, owner_name, file_name);
/*	return RENAMED; */
	return CKPT_OK;
}


// this is used to create hard links for the diff. ckpting analysis (John B)
// it also sets world writeable permissions to allow the manager to remove
// the links when done
int IMDS::LinkFile (char * old_path, char * new_path) { 
    int status = link (old_path, new_path);
    if (status == 0) { // link ok, now set permissions
		status = access(new_path, R_OK | W_OK );
		if (status == 0) return status;
		dprintf( D_ALWAYS, "IMDS:LinkFile: access error" );
	}

	else { // unable to create link, check errno
    	char * error_file;
		FILE * error_fp;
		
		if ( (error_file = param("DIFF_CKPT_ERR")) != NULL) {
    		sprintf(error_file, "%s", error_file);
    		error_fp = fopen(error_file, "a");
    		if (error_fp == NULL) {
        		printf("Could not open %s.\n", error_file);
				free( error_file );
        		return status;
    		}
    		if (errno == EEXIST) { // analyzer is running slow, print an err msg
        		fprintf(error_fp, "Already exists: %s\n", new_path);
    		} else {
        		fprintf(error_fp, "Link error: %s\n", strerror(errno));
    		}
    		if (0 != fclose(error_fp)) {
				dprintf( D_ALWAYS, "Could not close error file: \n" );
			}
			free( error_file );
		} else {
			dprintf( D_ALWAYS, "No DIFF_CKPT_ERR param\n" );
		}
	}
    return status;
}


// this is used to create hard links for the diff. ckpting analysis (John B)
int IMDS::LinkFile (char * old_path, char * new_path) { 
    int status = link (old_path, new_path);
    if (status == 0) return status;

	else { // unable to create link, check errno
    	char error_file[MAX_PATHNAME_LENGTH];
		FILE * error_fp;
    	sprintf(error_file, "%s", ANALYZER_ERRORS);
    	error_fp = fopen(error_file, "a");
    	if (error_fp == NULL) {
        	printf("Could not open %s.\n", error_file);
        	return status;
    	}
    	if (errno == EEXIST) { // analyzer is running slow, print an error msg
        	fprintf(error_fp, "Already exists: %s\n", new_path);
    	} else {
        	fprintf(error_fp, "Link error: %s\n", strerror(errno));
    	}
    		if (0 != fclose(error_fp)) perror("Could not close error file: ");
	}
    return status;
}


>>>>>>> 1.9.28.1
u_short IMDS::RemoveFile(struct in_addr machine_IP,
						 const char*    owner_name,
						 const char*    file_name)
{
	file_node* file_ptr;
	int        d_ret_code;
	int        i_ret_code;
	
	file_ptr = Index.GetFileNode(machine_IP, owner_name, file_name);
	if (file_ptr == NULL)
		return DOES_NOT_EXIST;
	d_ret_code = FileStats.RemoveFileInfo(NULL);
	if (d_ret_code != REMOVED_FILE)
		return (u_short) d_ret_code;
	i_ret_code = Index.DeleteFile(machine_IP, owner_name, file_name);
	return (u_short) i_ret_code;
}


void IMDS::TransferFileInfo(int socket_desc)
{
  FileStats.TransferFileInfo(socket_desc);
}


