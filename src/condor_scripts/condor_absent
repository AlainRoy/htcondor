#! /usr/bin/env perl
#! /s/std/bin/perl -w
use strict;

# ******************************************************
# Command line options
# ******************************************************
my %Options =
    (
     "[-ping]"		=> "Enable ping test",
     "[-]"		=> "Read roster from STDIN",
     "[-reserved]"	=> "Check the reserved list",
     "[-cluster]"	=> "Report \"Cluster\" nodes that are down",
     "[-pool=host]"	=> "Set the condor pool to \"host\"",
     "[-down-cluster]"	=> "Report known down cluster nodes",
     "[-down-all]"	=> "Report all known down nodes",
     "[-script]"	=> "Produce script-parsable output",
     "[-v]"		=> "Verbose",
     "[-h]"		=> "Dump help",
    );

# Process command line
my %Config = (
	      Verbose		=> 0,
	      DoPing		=> 0,
	      DoReserved	=> 0,
	      DoClusterCheck	=> 0,
	      DoDownCluster	=> 0,
	      DoDownNodes	=> 0,
	      DoSetupReq	=> 0,
	      DoScriptOut	=> 0,
	      RosterDir		=> "/p/condor/home/admin",
	      RosterFile	=> "",
	      CondorPool	=> "",
	     );
my $Program = $0;
my @DownList;
my $CommandLine = join( " ", $0, @ARGV );
foreach my $Arg ( @ARGV )
{
    if ( $Arg =~ /^-ping$/ )
    {
	$Config{DoPing} = 1;
    }
    elsif ( $Arg =~ /^-pingok$/ )
    {
	$Config{DoPingOk} = 1;
    }
    elsif ( $Arg =~ /^-$/ )
    {
	$Config{RosterFile} = "<\&STDIN";
    }
    elsif ( $Arg =~ /^-reserved$/ )
    {
	$Config{DoReserved} = 1;
    }
    elsif ( $Arg =~ /^-cluster$/ )
    {
	$Config{DoClusterCheck} = 1;
    }
    elsif ( $Arg =~ /^-down-cluster$/ )
    {
	$Config{DoDownCluster} = 1;
    }
    elsif ( $Arg =~ /^-down-all$/ )
    {
	$Config{DoDownCluster} = 1;
	$Config{DoDownNodes} = 1;
    }
    elsif ( $Arg =~ /^-setup$/ )
    {
	$Config{DoSetupReq} = 1;
    }
    elsif ( $Arg =~ /^-script$/ )
    {
	$Config{DoScriptOut} = 1;
    }
    elsif ( $Arg =~ /^-pool=(.*)/ )
    {
	$Config{CondorPool} = $1;
    }
    elsif ( $Arg =~ /^-v$/ )
    {
	$Config{Verbose}++;
    }
    elsif ( $Arg =~ /^-h$/ )
    {
	Help( );
	exit 0;
    }
    else
    {
	Usage( $Arg );
	die "$0: Unknown option '$Arg'";
    }
}

# -cluster w/o -ping doesn't make sense
if (  ( $Config{DoClusterCheck} ) && ( ! $Config{DoPing} )  )
{
    print STDERR "Warning: -cluster has no effect without -ping\n";
}

# Set this to the file that contains the list of machines in your
# pool, sorted and unique.  It should contain just hostnames, not full
# hostnames with domains.
if ( exists( $ENV{CONDOR_ROSTER_DIR} ) )
{
    $Config{RosterDir} = $ENV{CONDOR_ROSTER_DIR};
}
$Config{RosterFile} = "$Config{RosterDir}/roster"
    if ( $Config{RosterFile} eq "" );
if ( exists( $ENV{CONDOR_ROSTER_FILE} ) )
{
    $Config{RosterFile} = $ENV{CONDOR_ROSTER_FILE};
}
my $RosterStateFile = "$Config{RosterDir}/roster.state";
if ( exists( $ENV{CONDOR_ROSTER_STATE} ) )
{
    $RosterStateFile = $ENV{CONDOR_ROSTER_STATE};
}
my $CondorStatus = "condor_status";
my $CondorReserved = "condor_reserved";
my $CondorStatusArgs = "-master";
$CondorStatusArgs = $CondorStatusArgs . " -pool $Config{CondorPool}"
    if ( $Config{CondorPool} ne "" );

# List of users,hosts,user@hosts to allow as personal condor users
my %PersonalCondorLists = (
			   Users	=> [ "NEVER-MATCH-ME" ],
			   Hosts	=> [ "NEVER-MATCH-ME" ],
			   Full 	=> [ "NEVER-MATCH-ME" ],
		      );

# List of machiens that require some setup work b4 Condor can run on them...
my %SetupRequired;

# Read the state; all we really need is the "ClusterNodes" list
my %ClusterNodes;
my $ClusterCount = 0;
die "can't read '$RosterStateFile'" if (! open ( IN, $RosterStateFile ) );
while ( <IN> )
{
    chomp;
    s/\#.*$//g;
    next if ( $_ eq "" );
    if ( /arch\s+=\s+\"(.+)\"/i )
    {
	# Do nothing
    }
    elsif ( /ExcludeUser\s+=\s+\"(.+?)\"/i )
    {
	# Do nothing
    }
    elsif ( /ExcludeSponsor\s+=\s+\"(.+?)\"/i )
    {
	# Do nothing
    }
    elsif ( /ExcludeRoom\s+=\s+\"(.+?)\"/i )
    {
	# Do nothing
    }
    elsif ( /ExcludeAll\s+=\s+\"(.+?)\"/i )
    {
	# Do nothing
    }
    elsif ( /ExcludeHost\s+=\s+\"(.+?)\"/i )
    {
	# Do nothing
    }
    elsif ( /IncludeHost\s+=\s+\"(.+?)\"/i )
    {
	# Do nothing
    }
    elsif ( /ClusterNode\s+=\s+\"(.+?)\"/i )
    {
	$ClusterNodes{$1} = $1;
	$ClusterCount++;
    }
    elsif ( /Down\s+=\s+\"(.+?)\"/i )
    {
	push @DownList, $1;
    }
    elsif ( /NotSetup\s+=\s+\"(.+?)\"/i )
    {
	$SetupRequired{$1} = $1;
    }
    elsif ( /PersonalCondor(Users|Hosts|Full)\s+=\s+\"(.+?)\"/i )
    {
	push( @{$PersonalCondorLists{$1}}, $2 );
    }
    elsif ( ! /^$/ )
    {
	print STDERR "Can't parse state line $. '$_'\n";
    }
}
close( IN );

# Read in the current roster, build the "%Absent" hash of names
die "Can't open '$Config{RosterFile}'"
    if ( ! open( IN, "$Config{RosterFile}" )  );
my $RosterCount;
my %FullRoster;
my %RosterDown;
while ( <IN> )
{
    chomp;
    next if ( /^\s+$/ );

    # Is it a 'down' line from the roster?
    if ( /-\s+(\S+)/ )
    {
	$RosterDown{$1} = $1;
	$FullRoster{$1} = $1;
    }
    else
    {
	$FullRoster{$_} = $_;
    }

    # Default line...
    $RosterCount++;
}
close( IN );

# Initialize the absent list to be the full roster
# Exclude machines that are down or need setup
my %Absent;
foreach my $Host ( keys %FullRoster )
{
    next if ( exists $RosterDown{$Host} );
    next if ( exists $SetupRequired{$Host} );
    $Absent{$Host} = $Host;
}


# This is the actual work: Take the output from condor_status, remove
# any entries that have an '@' (which are from personal condors) unless
# the user listed is in the PersonalCondorUsers list.
# Delete from the %Absent hash each entry found..
{
    # Build a regex of personal condor users
    my $PersonalUsers =
	"(" . join( ")|(", @{$PersonalCondorLists{Users}} ) . ")";
    my $PersonalHosts =
	"(" . join( ")|(", @{$PersonalCondorLists{Hosts}} ) . ")";
    my $PersonalFull =
	"(" . join( ")|(", @{$PersonalCondorLists{Full}} ) . ")";

    # Build & run the condor_status command...
    my $Cmd = "$CondorStatus $CondorStatusArgs";
    die "Can't run '$Cmd'" if ( ! open( IN, "$Cmd|" )  );
    while ( <IN> )
    {
	chomp;
	my $Host = $_;

	# Check for personal condor, filter 'em
	if ( /(.*)@(.*)/ )
	{
	    my $User = $1;
	    $Host = $2;
	    my $Full = $_;
	    if ( ( $User =~ /$PersonalUsers/ ) ||
		 ( $Host =~ /$PersonalHosts/ ) ||
		 ( $Full =~ /$PersonalFull/ )  )
	    {
		# Do nothing
	    }
	    else
	    {
		next;
	    }
	}

	# Ok.  Now clean up the host name & strike it from the absent hash
	$Host =~ s/\..*//g;
	delete $Absent{$Host};
    }
    close( IN );
}

# Now, %Absent contains the list of all "Roster" machines that are
#  1 - Not known to be down (in the roster state file)
#  2 - Not reporting in to the collector

# Run the cluster tool...
my $ReservedCount = 0;
if ( $Config{DoReserved} )
{
    my $Cmd = "$CondorReserved";
    die "Can't run '$Cmd'" if ( ! open( IN, "$Cmd|" )  );
    while ( <IN> )
    {
	chomp;
	my $Host = $_;
	if ( exists $Absent{$Host} )
	{
	    delete $Absent{$Host};
	}
	$ReservedCount++;
	print "Reserved: $Host\n" if ( $Config{Verbose} >= 1 );
    }
    close( IN );
}

# Dump it out - Print out entries in the roster that aren't in the
# condor_status output.
my @ClusterDown;		# Cluster nodes that are 'down'
my $ClusterAbsent = 0;		# Count of the above
my @NotDown;			# Hosts listed as down, but not
if ( $Config{DoPing} )
{
    my %PingOk;

    # Build up a temp absent list
    my @TempAbsent = ( keys %Absent, keys %RosterDown, keys %SetupRequired );
    while( $#TempAbsent >= 0 )
    {
	my $PingCmd = "pingfilt";
	my $HostCount = 0;
	my $Host;
	while ( $Host = shift( @TempAbsent ) )
	{
	    if ( ( length($PingCmd) + length ($Host) + 2 ) > 2000 )
	    {
		unshift @TempAbsent, $Host;
		last;
	    }
	    $PingCmd = $PingCmd . " $Host";
	    $HostCount++;
	}

	# If there are hosts in our list to ping...
	if ( $HostCount )
	{
	    die "Can't run pingfilt" if ( ! open( IN, "$PingCmd 2>&1 |") );
	    while( <IN> )
	    {
		chomp;
		next if ( /^ping:/ );
		$PingOk{$_} = 1;
	    }
	    close( IN );
	}
    }
    $#TempAbsent = -1;

    # Now, remove the unreachable hosts from the absent list
    foreach my $Host ( keys %Absent )
    {
	# If it's down, remove it from the absent list
	if ( ! exists $PingOk{$Host} )
	{
	    delete $Absent{$Host};

	    # However, if it's in the cluster, note it..
	    if ( exists( $ClusterNodes{$Host} ) )
	    {
		push( @ClusterDown, $Host );
	    }
	}
	# Otherwise, note it as an "absent" cluster node
	elsif ( exists $ClusterNodes{$Host} )
	{
	    $ClusterAbsent++;
	}
    }

    # "Down" hosts that pinged ok?
    foreach my $Host ( @DownList )
    {
	if ( exists $PingOk{$Host} )
	{
	    push @NotDown, $Host;
	}
    }
}

# Ok, now dump out the results
my $AbsentCount = 0;
my @ClusterAbsent;
if ( scalar keys %Absent > 0 )
{
    my $Num = ( scalar keys %Absent );
    print "\n# Absent nodes ($Num):\n" if ( ! $Config{DoScriptOut} );
    foreach my $Host ( sort keys %Absent )
    {
	print "$Host\n";
	$AbsentCount++;
	push @ClusterAbsent, $Host if ( exists $ClusterNodes{$Host} );
    }
}

# Report hosts that are listed as down, but ping ok
if ( ( $Config{DoPingOk} ) && ( $#NotDown >= 0 ) )
{
    my $Num = $#NotDown + 1;
    print "\n# Hosts listed as down, but ping ok ($Num):\n" 
	if ( ! $Config{DoScriptOut} );
    foreach my $Host ( sort @NotDown )
    {
	print "Host marked down, but ping ok: '$Host'\n";
    }
}

# Report absent cluster nodes separately...
if ( $#ClusterAbsent >= 0 )
{
    my $Num = $#ClusterAbsent + 1;
    print "\n# Cluster nodes absent ($Num):\n" if ( ! $Config{DoScriptOut} );
    foreach my $Host ( @ClusterAbsent )
    {
	print "Cluster node absent: '$Host'\n";
    }
}

# Report cluster hosts that are down
if ( ( $Config{DoClusterCheck} ) && ( $#ClusterDown >= 0 ) )
{
    my $Num = ($#ClusterDown + 1);
    print "\n# Cluster nodes down ($Num):\n" if ( ! $Config{DoScriptOut} );
    foreach my $Host ( @ClusterDown )
    {
	print "Cluster node down: '$Host'\n";
    }
}

# Build the list of cluser & node hosts 'known' to be down..
my @KnownClusterDown;
my @KnownNodeDown;
foreach my $Host ( sort @DownList )
{
    if ( exists $ClusterNodes{$Host} )
    {
	push @KnownClusterDown, $Host;
    }
    else
    {
	push @KnownNodeDown, $Host;
    }
}
# Report hosts that are _known_ to be down...
if ( ( $Config{DoDownCluster} ) && ( $#KnownClusterDown >= 0 ) )
{
    my $Num = $#KnownClusterDown + 1;
    print "\n# Cluster nodes known to be down ($Num):\n"
	if ( ! $Config{DoScriptOut} );
    foreach my $Host ( @KnownClusterDown )
    {
	print "Cluster node known to be down: '$Host'\n";
    }
}
if ( ( $Config{DoDownNodes} ) && ( $#KnownNodeDown >= 0 ) )
{
    my $Num = $#KnownNodeDown + 1;
    print "\n# Nodes known to be down ($Num):\n"
	if ( ! $Config{DoScriptOut} );
    foreach my $Host ( @KnownNodeDown )
    {
	print "Node known to be down: '$Host'\n";
    }
}

# Report nodes that are in the "setup required" state
if ( ( $Config{DoSetupReq} ) && ( scalar keys %SetupRequired > 0 ) )
{
    my $Num = scalar keys %SetupRequired;
    print "\n# Nodes requiring setup ($Num):\n" if ( ! $Config{DoScriptOut} );
    foreach my $Host ( sort keys %SetupRequired )
    {
	print "Node requring setup: '$Host'\n";
    }
}

# Report cluster nodes that are known to be down..
print "\n" if ( ! $Config{DoScriptOut} );
print "# Summary\n";
print "#   $RosterCount machines in the roster\n";
print "#   Cluster: $ClusterCount nodes";
print ", $ReservedCount reserved" if ( $Config{DoReserved} );
print ", " . ($#ClusterDown + 1) . " down" if ( $Config{DoClusterCheck} );
print ", $ClusterAbsent absent";
print "\n#   $AbsentCount hosts absent\n";
print "\n# $CommandLine\n";

# ******************************************************
# Dump out usage
# ******************************************************
sub Usage ( $ )
{
    my $Unknown = shift;

    print "$Program: unknown option '$Unknown'\n" if ( $Unknown ne "" );
    printf "usage: $Program %s\n", join (" ", sort keys %Options);
    print "use '-h' for more help\n";
    exit 1;

} # usage ()
# ******************************************************

# ******************************************************
# Dump out help
# ******************************************************
sub Help ( )
{
    my ($opt, $text);

    printf "usage: $Program %s\n", join (" ", sort keys %Options);
    foreach $opt (sort {lc($a) cmp lc($b) } keys %Options)
    {
	printf ("  %15s : %-40s\n", $opt, $Options{$opt} );
    }
    exit 0;

} # help ()
# ******************************************************
