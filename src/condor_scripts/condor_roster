#! /usr/bin/env perl
#! /usr/bin/perl -w
use strict;
# use warnings;

# Enabled debugging
my $Debug = 0;

# Dirs & files
my $RosterDir = "/p/condor/home/admin";
if ( defined( $ENV{CONDOR_ROSTER_DIR} ) )
{
    $RosterDir = $ENV{CONDOR_ROSTER_DIR};
}
my $RosterFile = "$RosterDir/roster";
if ( defined( $ENV{CONDOR_ROSTER_FILE} ) )
{
    $RosterFile = $ENV{CONDOR_ROSTER_FILE};
}
my $RosterStateFile = "$RosterDir/roster.state";
if ( defined( $ENV{CONDOR_ROSTER_STATE} ) )
{
    $RosterStateFile = $ENV{CONDOR_ROSTER_STATE};
}

# Machine info list
my $MachineList = "condor_hostlist";

# Lists
my @Archs;		# Supported achitectures
my @ExcludeUsers;	# List of users to exclude
my @ExcludeHosts;	# No condor on these hosts
my @ExcludeSponsors;	# No condor for these sponsors
my @ExcludeRooms;	# No condor in these rooms
my @ClusterNodes;	# Dedicated cluster nodes
my @IncludeHosts;	# Other hosts that we're allowwed to run on
my @DownHosts;		# Machines with problems

# Add a "never match" pattern to all of the exclude lists
push @ExcludeUsers, "NEVER-MATCH-ME";
push @ExcludeHosts, "NEVER-MATCH-ME";
push @ExcludeSponsors, "NEVER-MATCH-ME";
push @ExcludeRooms, "NEVER-MATCH-ME";


# ******************************************************
# Command line parsing...
# ******************************************************
my $Program = "condor_roster";
my %Options =
    (
     "[-]"		=> "Write to STDOUT",
     "[-o=file]"	=> "Use 'file' as the roster file",
     "[-s=file]"	=> "Use 'file' as the roster state file",
     "[-l=prog]"	=> "Run 'prog' to get the host inventory",
     "[-d]"		=> "Enable debugging",
     "[-h]"		=> "Dump help",
    );
foreach my $Arg ( @ARGV )
{
    if ( $Arg =~ /^-$/ )
    {
	$RosterFile = ">\&STDOUT";
    }
    elsif ( $Arg =~ /^-o=(.*)$/ )
    {
	$RosterFile = $1;
    }
    elsif ( $Arg =~ /^-s=(.*)$/ )
    {
	$RosterStateFile = $1;
    }
    elsif ( $Arg =~ /^-l=(.*)$/ )
    {
	$MachineList = $1;
    }
    elsif ( $Arg =~ /^-d$/ )
    {
	$Debug++;
    }
    elsif ( $Arg =~ /^-h/ )
    {
	Help( );
    }
    else
    {
	Usage( $Arg );
    }
}

# Read the state
die "can't read '$RosterStateFile'" if (! open ( IN, $RosterStateFile ) );
while ( <IN> )
{
    chomp;
    s/\#.*$//g;
    next if ( $_ eq "" );
    if ( /arch\s+=\s+\"(.+)\"/i )
    {
	my ($t) = $1;
	$t =~ s/\//\\\//g;
	push( @Archs, $t );
    }
    elsif ( /ExcludeUser\s+=\s+\"(.+?)\"/i )
    {
	print "$.: No User = '$1'\n" if ( $Debug );
	push( @ExcludeUsers, $1 );
    }
    elsif ( /ExcludeSponsor\s+=\s+\"(.+?)\"/i )
    {
	print "$.: No Sponsor = '$1'\n" if ( $Debug );
	push( @ExcludeSponsors, $1 );
    }
    elsif ( /ExcludeRoom\s+=\s+\"(.+?)\"/i )
    {
	print "$.: No room = '$1'\n" if ( $Debug );
	push( @ExcludeRooms, $1 );
    }
    elsif ( /ExcludeAll\s+=\s+\"(.+?)\"/i )
    {
	print "$.: No All = '$1'\n" if ( $Debug );
	push( @ExcludeUsers, $1 );
	push( @ExcludeSponsors, $1 );
	push( @ExcludeRooms, $1 );
    }
    elsif ( /ExcludeHost\s+=\s+\"(.+?)\"/i )
    {
	push( @ExcludeHosts, $1 );
    }
    elsif ( /IncludeHost\s+=\s+\"(.+?)\"/i )
    {
	push( @IncludeHosts, $1 );
    }
    elsif ( /ClusterNode\s+=\s+\"(.+?)\"/i )
    {
	push( @ClusterNodes, $1 );
    }
    elsif ( /Down\s+=\s+\"(.+?)\"/i )
    {
	push( @DownHosts, $1 );
    }
    elsif ( ! /^$/ )
    {
	print "Can't parse state line $. '$_'\n";
    }
}
close( IN );

# Form the patterns
my $Archs		= "(" . join( ")|(", @Archs   ) . ")";
my $ExcludeUsers	= "(" . join( ")|(", @ExcludeUsers ) . ")";
my $ExcludeRooms	= "(" . join( ")|(", @ExcludeRooms ) . ")";
my $ExcludeSponsors	= "(" . join( ")|(", @ExcludeSponsors ) . ")";
my $ExcludeHosts	= "(" . join( ")|(", @ExcludeHosts ) . ")";

# For Debug purposes
if ( $Debug )
{
    print "Archs='$Archs'\n";
    print "ExcludeUsers='$ExcludeUsers'\n";
    print "ExcludeSponsors='$ExcludeSponsors'\n";
    print "ExcludeRooms='$ExcludeRooms'\n";
    print "ExcludeHosts='$ExcludeHosts'\n";
}

# Read in the machine info list...
my %Roster;
my $MachineCount = 0;	# Raw machine count
my $HostCount = 0;	# Hosts added to the list count
if ( $MachineList eq "" )
{
    die "Can't read stdin" if (! open ( MACHINES, "<\&STDIN" ) );
}
else
{
    die "Can't run '$MachineList'" if (! open ( MACHINES, "$MachineList|" ) );
}
MACHINE:
while ( <MACHINES> )
{
    chomp;
    next if ( /^\#/ );

    # Parse the line
    $MachineCount++;
    my ( $Host, $Room, $UserList, $Sponsor, $OS, $Arch ) = split( /;/ );
    print "\n$Host... " if ( $Debug );

    # Supported arch?
    next if ( ! ($OS =~ /$Archs/) );
    print "<OS:$OS>" if ( $Debug );

    # No user/room/sponsor?
    foreach my $User ( split( /,/, $UserList ) )
    {
	next MACHINE if ( $User =~ /$ExcludeUsers/ );
    }
    print "<U:$UserList> " if ( $Debug );

    # No user/room/sponsor?
    next if ( $Room =~ /$ExcludeRooms/ );
    print "<R:$Room> " if ( $Debug );

    # No user/room/sponsor?
    next if ( $Sponsor =~ /$ExcludeSponsors/ );
    print "<S:$Sponsor> " if ( $Debug );

    # No host?
    $Host =~ s/\..*//;
    next if ( $Host =~ /$ExcludeHosts/ );
    print "<H:$Host> " if ( $Debug );

    # Add to roster
    if ( defined( $Roster{$Host} ) )
    {
	print STDERR "Warning: $Host defined twice (input line $.)!\n";
	next;
    }
    $Roster{$Host} = $Host;
    $HostCount++;
    print "ADDING\n" if ( $Debug );
}
close( IN );
my $ExcludeCount = $MachineCount - $HostCount;

# Add in the "Cluster node" machines:
foreach my $Node ( @ClusterNodes )
{
    $Roster{$Node} = $Node;
}

# Add in the "Include Host" machines:
foreach my $Host ( @IncludeHosts )
{
    $Roster{$Host} = $Host;
}

# Remove the 'Down' hosts
my $DownCount = 0;
foreach my $Down ( @DownHosts )
{
    $DownCount++;
    delete( $Roster{$Down} );
}

# Dump 'em
print "# Writing to $RosterFile...";
die "Can't write to roster file" if (! open ( OUT, ">$RosterFile" ) );
my $NodeCount = 0;
foreach my $Host ( sort keys %Roster )
{
    print OUT "$Host\n";
    $NodeCount++;
}
close ( OUT );
print "  $NodeCount nodes; $ExcludeCount excluded, $DownCount down\n";
# ******************************************************
# Dump out usage
# ******************************************************
sub Usage ( $ )
{
    my $Unknown = shift;

    print "$Program: unknown option '$Unknown'\n" if ( $Unknown ne "" );
    printf "usage: $Program %s\n", join (" ", sort keys %Options);
    print "use '-h' for more help\n";
    exit 1;

} # usage ()
# ******************************************************

# ******************************************************
# Dump out help
# ******************************************************
sub Help ( )
{
    my ($opt, $text);

    printf "usage: $Program %s\n", join (" ", sort keys %Options);
    foreach $opt (sort {lc($a) cmp lc($b) } keys %Options)
    {
	printf ("  %15s : %-40s\n", $opt, $Options{$opt} );
    }
    exit 0;

} # help ()
# ******************************************************
