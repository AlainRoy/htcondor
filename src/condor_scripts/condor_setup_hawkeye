#! /usr/bin/env perl
use strict;
use warnings;
$| = 1;

# Prototypes
sub Main( );
sub CommandLine( @ );
sub FindConfigFile( );
sub ReadConfigFile( );
sub InstallFiles( );
sub ProcessConfigLine( $ );
sub WriteConfig( );
sub Expand( $ );
sub ExpandString( $ );
sub Usage ( $ );
sub Help ( );

# ******************************************************
# Command line options
# ******************************************************
my $Distribution = "condor";
my %Options =
    (
     "[--modules=dir]"	=> "Specify modules directory",
     "[--source=dir]"	=> "Specify installation source",
     "[--config=file]"	=> "Specify $Distribution config file",
     "[--no-update|-n]"	=> "Don't update the config file",
     "[--update=file]"	=> "Specify config file to update",
     "[--update|-u]"	=> "Enable config update <default>",
     "[--manual|-m]"	=> "Manual mode; asks lots of questions",
     "[--defaults]"	=> "Use defaults if possible",
     "[--help|-h]"	=> "Dump help",
    );

# Hash of directories & files
my %Config = (
	      RootDir => "",
	      SourceDir => ".",
	      BaseConfigFile => "",
	      ConfigFile => "",
	      ModulesDir => "",
	      UpdateConfig => 0,
	      UseDefaults => 1,
	      Startd => -1,
	      CronName => "",
	      SbinDir => "",
	      );

# Modules to install
my %InstallFiles = (
		    "HawkeyeLib.pm" => "ModulesDir",
		    "HawkeyePublish.pm" => "ModulesDir",
		    "condor_install_module" => "SbinDir",
		   );

my %ConfigMacros;
my %ConfigLines;	# Hash of arrays; 1 per file
my @NewConfig;		# New configuration lines

# "Main" Logic
if ( ! exists $ENV{PWD} )
{
    $ENV{PWD} = `/bin/pwd`; chomp $ENV{PWD};
}

# Basic setups
my $Program = "condor_setup_hawkeye";
my $ConfigEnv = "CONDOR_CONFIG";

# Process command line, etc..
CommandLine( @ARGV );
$#ARGV = -1;
$| = 1;

# Find the release tarball
if ( ! -f "$Config{SourceDir}/release.tar" )
{
    print STDERR "\nUnable to access 'release.tar' in $Config{SourceDir}\n";
    print STDERR "You may need to specify --source=<dir>\n";
    die "No release tarball found\n";
}

# Find the config file to use
$ENV{$ConfigEnv} = $Config{BaseConfigFile} if ( ! exists $ENV{$ConfigEnv} );
FindConfigFile( );

# Read the config file
ReadConfigFile( );

# Copy in the perl modules
InstallFiles( );

# And, write the new config
WriteConfig( );

# end of "main"
# ******************************************************

# ******************************************************
# Parse the command line, etc.
# ******************************************************
sub CommandLine( @ )
{
    foreach my $Arg ( @_ )
    {
	# Speicfy modules directory
	if ( $Arg =~ /^--modules=(.+)/ )
	{
	    $Config{ModulesDir} = $1;
	}

	# Speicify config file
	elsif ( $Arg =~ /--config=(.+)/ )
	{
	    my $File = $1;
	    if ( ! $File =~ /^\// )
	    {
		$File = $ENV{PWD} . "/$File";
	    }
	    $Config{BaseConfigFile} = $File;
	}

	# Config file to update
	elsif ( $Arg =~ /^--update=(.+)/ )
	{
	    $Config{ConfigFile} = $1;
	    $Config{UpdateConfig} = 1;
	}

	# Config update
	elsif ( ( $Arg eq "-u") || ( $Arg eq "--update" ) )
	{
	    $Config{UpdateConfig} = 1;
	}

	# Don't update config
	elsif ( ( $Arg eq "-n") || ( $Arg eq "--no-update" ) )
	{
	    $Config{UpdateConfig} = 0;
	}

	# Installation directory
	elsif ( $Arg =~ /^--source=(.+)/ )
	{
	    $Config{SourceDir} = $1;
	}

	# Specify the modules directory...
	elsif ( $Arg =~ "--modules=(.+)" )
	{
	    $Config{ModulesDir} = $1;
	}

	# Help
	elsif ( ( $Arg =~ /^-h/ ) || ( $Arg eq "--help" ) )
	{
	    Help( );
	    exit 0;
	}

	# Unknown option
	else
	{
	    Usage( $Arg );
	    exit( 1 );
	}
    }


} # CommandLine( )
# ******************************************************

# ******************************************************
# Find the configuration file to use
# ******************************************************
sub FindConfigFile( )
{

    # Check the config env variable...
    if ( ( $Config{BaseConfigFile} eq "" ) && ( exists $ENV{$ConfigEnv} ) )
    {
	if ( ! ( -f $ENV{$ConfigEnv} ) )
	{
	    warn "$ENV{$ConfigEnv} (from ENV) does not exist!";
	}
	$Config{BaseConfigFile} = $ENV{$ConfigEnv};
    }

    # Fallbacks...
    my @FallbackConfigs = [ "/home/$Distribution", ];
    my $RootEnv = uc $Distribution . "_ROOT_DIR";
    unshift @FallbackConfigs, $ENV{$RootEnv}
	if ( exists $ENV{$RootEnv} );
    foreach my $TempConfig ( @FallbackConfigs )
    {
	if (  ( $Config{BaseConfigFile} eq "" ) && ( -f $TempConfig )  )
	{
	    $Config{BaseConfigFile} = $TempConfig;
	}
    }

    # Finally, let's go check the config
    if ( $Config{BaseConfigFile} eq "" )
    {
	print STDERR "No config found\n";
	Usage( "" );
	print STDERR "\tOr, set the $ConfigEnv env variable\n";
	exit 1;
    }

} # FindConfigFile()
# ******************************************************

# ******************************************************
# Read the config file
# ******************************************************
sub ReadConfigFile( )
{
    my @ConfigFiles = ( { Raw => $Config{BaseConfigFile},
			  File => $Config{BaseConfigFile}, } );

    # Pre-define some things:
    if ( ! exists $ENV{HOSTNAME} )
    {
	$ENV{HOSTNAME} = `/bin/hostname`;
	chomp $ENV{HOSTNAME};
    }
    $ConfigMacros{FULL_HOSTNAME} = $ENV{HOSTNAME};
    $ConfigMacros{HOSTNAME} = $ConfigMacros{FULL_HOSTNAME};
    $ConfigMacros{HOSTNAME} =~ s/\..*$//;
    $ConfigMacros{TILDE} = $ENV{HOME};

    # Read all of the config files
    foreach my $Conf ( @ConfigFiles )
    {
	my $Raw = $Conf->{Raw};
	my $File = $Conf->{File};
	open( CONFIG, $File ) || die "Can't read config @ $File";

	print "Reading config file $Raw ...";
	my $Line = "";
	while( <CONFIG> )
	{
	    chomp;
	    push( @{$ConfigLines{$File}}, $_ );
	    s/^\s+//;
	    s/\s+$//;

	    # Comment? ( /\#/ )
	    if ( /\#/ )
	    {
		ProcessConfigLine( $Line ) if ( $Line ne "" );
		$Line = "";
	    }

	    # Continuation?
	    elsif ( /(.*)\\$/ )
	    {
		$Line = ( $Line eq "" ) ? $1 : $Line . " " . $1;
	    }

	    # "Normal" line
	    else
	    {
		$Line = ( $Line eq "" ) ? $_ : $Line . " " . $_;
		ProcessConfigLine( $Line ) if ( $Line ne "" );
		$Line = "";
	    }
	}
	close( CONFIG );
	print "Done\n";

	# Evaluate the local configs
	if ( ( $File eq $Config{BaseConfigFile} ) &&
	     ( exists $ConfigMacros{LOCAL_CONFIG_FILE} )  )
	{
	    foreach my $Local ( split( /[\,\s]+/,
				       $ConfigMacros{LOCAL_CONFIG_FILE} ) )
	    {
		my $r = ();
		$r->{Raw} = $Local;
		$r->{File} = ExpandString( $Local );
		push( @ConfigFiles, $r );
		$r = ();
	    }
	}
    }
    print "\n";


    # Add basic things to the config if they're not defined...
    $Config{CronName} = Expand( "STARTD_CRON_NAME" );
    if ( ! defined $Config{CronName} )
    {
	$Config{CronName} =
	    ( $Distribution eq "hawkeye" ) ? "Hawkeye" : "Cron";
	push @NewConfig, "STARTD_CRON_NAME = $Config{CronName}";
	$ConfigMacros{STARTD_CRON_NAME} = $Config{CronName};
    }

    # Figure out where the modules go
    {
	my $Modules = $ConfigMacros{MODULES};
	if ( ! defined $Modules )
	{
	    my $Hawkeye = Expand( "HAWKEYE" );
	    my $HawkeyeDir = Expand( "HAWKEYE_DIR" );
	    my $ReleaseDir = Expand( "RELEASE_DIR" );

	    # 1. Look for direct config via cmd line
	    if ( $Config{ModulesDir} ne "" )
	    {
		$Modules = $Config{ModulesDir};
	    }
	    # 2. Look for HAWKEYE_DIR in config
	    elsif ( ( defined $HawkeyeDir ) && ( -d $HawkeyeDir ) )
	    {
		$Modules = "\$(HAWKEYE_DIR)/modules";
	    }
	    # 3. Look for HAWKEYE in config
	    elsif ( ( defined $Hawkeye ) && ( -d $Hawkeye ) )
	    {
		$Modules = "\$(HAWKEYE)/modules";
	    }
	    # 4. Look for RELEASE_DIR in config
	    elsif ( defined $ReleaseDir )
	    {
		$Modules = "\$(RELEASE_DIR)/modules";
	    }
	}

	# Confirm from user
	my $Expanded = "";
	while( 1 )
	{
	    print "What directory would you like modules installed in?\n";
	    print "  You may specify something like \$(RELEASE_DIR)/modules\n";
	    print "  Default = '$Modules'\n" if ( $Modules ne "" );
	    print "  Modules: ";
	    my $Input = <>; chomp $Input;
	    $Input = $Modules if ( $Input eq "" );

	    $Expanded = ExpandString( $Input );
	    print "  $Input expands to '$Expanded': Is this correct [Y/n]? ";
	    $_ = <>;
	    if ( /^n/i )
	    {
		next;
	    }

	    # Ok, let's run with it...
	    $Modules = $Input;
	    last;
	}

	# Create the modules directory if it doesn't exit
	if ( ! -d $Expanded )
	{
	    print "  Creating modules directory '$Expanded'...\n";
	    mkdir( $Expanded, 0755 ) || die "Can't mkdir '$Expanded'";
	}

	# Store it away...
	$Config{ModulesDir} = $Expanded;

	# And, let's set the config
	if ( ( !exists $ConfigMacros{MODULES} ) ||
	     ( $ConfigMacros{MODULES} ne $Modules ) )
	{
	    print "Defining MODULES\n";
	    push @NewConfig, "MODULES = $Modules";
	    $ConfigMacros{MODULES} = $Modules;
	}

	print "\n";
    }

    # Jobs defined?
    my $CronJobsVar = uc( $ConfigMacros{STARTD_CRON_NAME} ) . "_JOBS";
    my $Jobs = Expand( $CronJobsVar );
    if ( ! defined $Jobs )
    {
	push @NewConfig, "$CronJobsVar = ";
	$ConfigMacros{$CronJobsVar} = "";
    }

    # Try to find the file that last definied the job list
    if ( $Config{ConfigFile} eq "" )
    {
	my $File = Expand( "INSTALL_MODULE_CONFIG_FILE" );
	$Config{ConfigFile} = $File if ( defined $File );
    }

    # Find the "sbin" & "bin" directories
    my $Sbin = Expand( "SBIN" );
    if ( ( !defined $Sbin ) || ( $Sbin eq "" ) )
    {
	print STDERR "SBIN not defined in config.  Giving up.\n";
	exit 1;
    }
    $Config{SbinDir} = $Sbin;

    my $Bin = Expand( "BIN" );
    if ( ( !defined $Bin ) || ( $Bin eq "" ) )
    {
	print STDERR "BIN not defined in config.  Giving up.\n";
	exit 1;
    }
    $Config{BinDir} = $Bin;

    # Try to find the file that last definied the job list
    FindConfigToUpdate( \@ConfigFiles );


} # ReadConfigFile
#  ******************************************************

# ******************************************************
# Read the config file
# ******************************************************
sub FindConfigToUpdate( $ )
{
    my $ConfigFiles = shift;

    # Local vars
    my $UpdateConf = undef;
    my $CronJobsVar = uc( $ConfigMacros{STARTD_CRON_NAME} ) . "_JOBS";

    if ( !defined $UpdateConf )
    {
	foreach my $Conf ( reverse @{$ConfigFiles} )
	{
	    my @List = grep( /^\s*$CronJobsVar\s+=/,
			     @{$ConfigLines{$Conf->{File}}} );
	    if ( scalar @List )
	    {
		$UpdateConf = $Conf;
		last;
	    }
	}
    }

    # Try to find the file that last defined STARTD_CRON_NAME
    if ( !defined $UpdateConf )
    {
	foreach my $Conf ( reverse @{$ConfigFiles} )
	{
	    my @List = grep( /^\s*START_CRON_NAME\s+=/,
			     @{$ConfigLines{$Conf->{File}}} );
	    if ( scalar @List )
	    {
		$UpdateConf = $Conf;
		last;
	    }
	}
    }

    # If there's a local config that's named ".jobs" or similar, use it as
    # the config to modify
    if ( !defined $UpdateConf )
    {
	foreach my $Conf ( @{$ConfigFiles} )
	{
	    if ( $Conf->{Raw} =~ /(jobs|joblist|hawkeye)$/ )
	    {
		$UpdateConf = $Conf;
		last;
	    }
	}
    }

    # Finally, we'll grab a reasonable fallback
    if ( !defined $UpdateConf )
    {
	$UpdateConf = ();
	$UpdateConf->{Raw} = "\$(RELEASE_DIR)/condor_config.hawkeye";
	$UpdateConf->{File} = ExpandString( "\$(RELEASE_DIR)/condor_config.hawkeye" );
    }

    # Confirm from user
    while( 1 )
    {
	my $File = $UpdateConf->{File};
	my $Raw = $UpdateConf->{Raw};
	print "What directory would you like to store the module definitions in?\n";
	print "  You may specify something like \$(RELEASE_DIR)/etc/config.jobs\n";
	print "  Default = '$Raw'\n";
	print "  Local config: ";
	my $Input = <>; chomp $Input;
	$Input = $Raw if ( $Input eq "" );

	$File = ExpandString( $Input );
	print "$Input expands to '$File': Is this correct [Y/n]? ";
	$_ = <>;
	redo if ( /^n/i );

	# Ok, let's run with it...
	$Config{ConfigFile} = $File;
	$Raw = $Input;

	my $Found = 0;
	foreach my $Conf ( @{$ConfigFiles} )
	{
	    $Found++ if ( $File eq $Conf->{File} );
	}
	if ( ! $Found )
	{
	    print "\n";
	    print "WARNING; $Raw does not appear to be in the\n";
	    print "  LOCAL_CONFIG_FILE list.  You'll need to verify and correct\n";
	    print "  this for your Hawkeye to work\n";
	    print "  Press <enter> to continue\n";
	    $_ = <>;
	}
	last;
    }

} # FindConfigToUpdate( $ )
# ******************************************************

# ******************************************************
# Install the perl modules & executables
# ******************************************************
sub InstallFiles( )
{
    # Extract the tarball
    print "Extracting release tarball... ";
    my $TarBall = "$Config{SourceDir}/release.tar";
    system( "tar xf $TarBall" );
    print "Done\n";

    # Walk through the expected files...
    print "\nInstalling files:\n";
    while( my ( $File, $Dest) = each ( %InstallFiles ) )
    {
	my $Full = "./" . $File;
	if ( ! -f $Full )
	{
	    print STDERR "\nUnable to access $File in $Config{SourceDir}\n";
	    print STDERR "You may need to specify --source=<dir>\n";
	    exit 1;
	}
	print "$File -> $Config{$Dest} ...";
	my $Cmd = "/bin/cp -f $Full $Config{$Dest}";
	system( $Cmd ) == 0 or die "Failed to run '$Cmd': $?";
	print "ok\n";
	unlink( $Full );
    }

    # Create "hawkeye_config_val"
    my $File = $Config{BinDir} . "/hawkeye_config_val";
    if ( ! ( -f $File ) )
    {
	print "hawkeye_config_val -> $Config{BinDir} ... ";
	my $CronPrefix = uc $Config{CronName} . "_";
	open( HCV, ">$File" ) or die "Can't create $File";
	print HCV <<HCV_1 ;
#! /usr/bin/env perl
use strict;
use warnings;

# Parse the command line
foreach my \$ArgNo ( 0 .. \$#ARGV )
{
    # Get the "real" variable name
    \$ARGV\[\$ArgNo\] =~ s/^hawkeye_/$CronPrefix/i;
}

# Now, run the real condor_config_val
# print join( " ", "condor_config_val", \@ARGV ) . "\\n";
exec( "condor_config_val", \@ARGV );
HCV_1
	close( HCV );
	chmod( 0755, $File );
	print "Ok\n";
    }

    # Done
    return 1;

} # InstallFiles
# ******************************************************

# ******************************************************
# Write the new config file
# ******************************************************
sub WriteConfig( )
{
    # Any work to do?
    if ( $#NewConfig < 0 )
    {
	print "\nNo config updates required\n";
	return 1;
    }

    my $File = $Config{ConfigFile};
    my $TmpFile = "$File.tmp.$$";
    open( TMP, ">$TmpFile" ) || die "Can't create temp config '$TmpFile'";

    my $EmacsLocal = 0;
    foreach ( @{$ConfigLines{$File}} )
    {
	if ( /\#\#\# Local Variables:/ )
	{
	    $EmacsLocal = 1;
	    push( @NewConfig, "" );
	    push( @NewConfig, $_ );
	    next;
	}
	if ( $EmacsLocal )
	{
	    if ( /\#\#\#/ )
	    {
		push( @NewConfig, $_ );
		$EmacsLocal = 0 if ( /End:/ );
		next;
	    }
	    else
	    {
		$EmacsLocal = 0;
	    }
	}
	print TMP "$_\n";
    }
    foreach ( @NewConfig )
    {
	print TMP "$_\n";
    }
    close( TMP );

    # Ask the user unless they explicietly asked us to overwrite it
    my $OverWrite = $Config{UpdateConfig};
    if ( ! $OverWrite )
    {
	if ( -f $Config{ConfigFile} )
	{
	    print "\nAbout to overwrite $Config{ConfigFile}; ok? ";
	    $OverWrite = 1 if ( <> =~ /^y/ );
	}
	else
	{
	    $OverWrite = 1;
	}
    }

    # OverWrite it?
    if ( $OverWrite )
    {
	unlink( $Config{ConfigFile} );
	rename( $TmpFile, $Config{ConfigFile} );
	print "\n$Config{ConfigFile} updated\n";
    }
    else
    {
	print "New config in $TmpFile\n";
    }

    return 1;

} # WriteConfig()
# ******************************************************

# ******************************************************
# Process a line from a config file
# ******************************************************
sub ProcessConfigLine( $ )
{
    my $Line = shift;

    $Line =~ s/^\s+//;
    $Line =~ s/\s+$//;
    return 0 if ( $Line eq "" ) ;

    # MACRO = value
    if ( $Line =~ /^(\S+)\s*=\s*(.+)/ )
    {
	my $Macro = uc( $1 );
	my $Value = $2;

	if ( exists $ConfigMacros{$Macro} )
	{
	    my $CurValue = $ConfigMacros{$Macro};
	    $Value =~ s/\$\($Macro\)/$CurValue/g;
	}
	$ConfigMacros{$Macro} = $Value;
    }
    elsif ( $Line =~ /^(\S+)\s*=$/ )
    {
	my $Macro = uc( $1 );
	$ConfigMacros{$Macro} = "";
    }
}


# ******************************************************
# Expand a macro from the config file
# ******************************************************
sub Expand( $ )
{
    my $Var = shift;

    # One more check
    return undef if ( ! exists ( $ConfigMacros{$Var} ) );

    # Now, expand it out...
    my $Value = $ConfigMacros{$Var};
    while( $Value =~ /(.*)\$\((\w+)\)(.*)/ )
    {
	if ( $2 eq $Var )
	{
	    $Value = $1 . $3;
	}
	elsif ( exists ( $ConfigMacros{$2} ) )
	{
	    $Value = $1 . $ConfigMacros{$2} . $3;
	    last if ( $2 eq $Var );
	}
	elsif ( exists ( $ENV{$2} ) )
	{
	    $Value = $1 . $ENV{$2} . $3;
	    last if ( $2 eq $Var );
	}
	else
	{
	    print STDERR "Warning: Unable to expand $Value\n";
	    last;
	}
    }
    $Value;

} # Expand()
# ******************************************************

# ******************************************************
# Expand a string
# ******************************************************
sub ExpandString( $ )
{
    my $Value = shift;

    # Now, expand it out...
    while( $Value =~ /(.*)\$\((\w+)\)(.*)/ )
    {
	if ( exists ( $ConfigMacros{$2} ) )
	{
	    $Value = $1 . $ConfigMacros{$2} . $3;
	}
	elsif ( exists ( $ENV{$2} ) )
	{
	    $Value = $1 . $ENV{$2} . $3;
	}
	else
	{
	    print STDERR "Warning: Unable to expand $Value\n";
	    last;
	}
    }
    $Value;

} # ExpandString()
# ******************************************************

# ******************************************************
# Dump out usage
# ******************************************************
sub Usage ( $ )
{
    my $Unknown = shift;

    print "$Program: unknown option '$Unknown'\n" if ( $Unknown ne "" );
    printf "usage: $Program [options] [files]\n";
    print "use '-h' for more help\n";
    exit 1;

} # usage ()
# ******************************************************

# ******************************************************
# Dump out help
# ******************************************************
sub Help ( )
{
    my ($opt, $text);

    printf "usage: $Program [options] [files]\n";
    foreach $opt (sort {lc($a) cmp lc($b) } keys %Options)
    {
	printf ("  %15s : %-40s\n", $opt, $Options{$opt} );
    }
    exit 0;

} # help ()
# ******************************************************
