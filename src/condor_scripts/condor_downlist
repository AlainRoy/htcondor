#! /usr/bin/env perl
#! /usr/bin/perl -w
use strict;
# use warnings;

# Enabled debugging
my $Debug = 0;

# Dirs & files
my $RosterDir = "/p/condor/home/admin";
if ( defined( $ENV{CONDOR_ROSTER_DIR} ) )
{
    $RosterDir = $ENV{CONDOR_ROSTER_DIR};
}
my $RosterStateFile = "$RosterDir/roster.state";
if ( defined( $ENV{CONDOR_ROSTER_STATE} ) )
{
    $RosterStateFile = $ENV{CONDOR_ROSTER_STATE};
}

# Add a "never match" pattern to all of the exclude lists
my @NotePatterns;
my $Verbose = 0;


# ******************************************************
# Command line parsing...
# ******************************************************
my $Program = "condor_roster";
my %Options =
    (
     "[pattern]"	=> "Only down machines with pattern in note",
     "[-v]"		=> "Verbose output",
     "[-h]"		=> "Dump help",
    );
foreach my $Arg ( @ARGV )
{
    if ( $Arg =~ /^-h/ )
    {
	Help( );
    }
    elsif ( $Arg =~ /^-v/ )
    {
	$Verbose++;
    }
    elsif ( ~ ( $Arg =~ /^-/ ) )
    {
	push @NotePatterns, $Arg;
    }
    else
    {
	Usage( $Arg );
    }
}

# String version of the note patterns for easy matching..
my $NotePattern = (  ( $#NotePatterns >= 0 ) ?
		     "(" . join( ")|(", @NotePatterns ) . ")" : ".*" );

# Read the state
die "can't read '$RosterStateFile'" if (! open ( IN, $RosterStateFile ) );
while ( <IN> )
{
    chomp;
    s/\#.*$//g;
    next if ( $_ eq "" );
    if ( /arch\s+=\s+\"(.+)\"/i )
    {
    }
    elsif ( /ExcludeUser\s+=\s+\"(.+?)\"/i )
    {
    }
    elsif ( /ExcludeSponsor\s+=\s+\"(.+?)\"/i )
    {
    }
    elsif ( /ExcludeRoom\s+=\s+\"(.+?)\"/i )
    {
    }
    elsif ( /ExcludeAll\s+=\s+\"(.+?)\"/i )
    {
    }
    elsif ( /ExcludeHost\s+=\s+\"(.+?)\"/i )
    {
    }
    elsif ( /IncludeHost\s+=\s+\"(.+?)\"/i )
    {
    }
    elsif ( /ClusterNode\s+=\s+\"(.+?)\"/i )
    {
    }
    elsif ( /NotSetup\s+=\s+\"(.+?)\"/i )
    {
    }
    elsif ( /Down\s+=\s+\"(.+?)\"(.*)/i )
    {
	my $Host = $1;
	my $Remain = $2;

	# Ok, let's look at the remainder of the line..
	chomp $Remain;
	$Remain =~ s/\#.*$//;
	$Remain =~ s/^\s+//;
	my $NoteString = "";
	my $Dump = 0;

	# Otherwise, dump if it matches...
	if ( $Remain =~ /(.+)[\s+,](.+)/ )
	{
	    my $Date = $1;
	    my $Notes = $2;
	    if ( $Notes =~ /$NotePattern/i )
	    {
		$Dump = 1;
		$NoteString = "$Date $Notes";
	    }
	}
	# If there is no matching note only dump if there is no pattern...
	else
	{
	    $Dump = 1 if ( $NotePattern eq ".*" );
	}

	# Dump it
	if ( $Dump )
	{
	    printf "%-30s", $Host;
	    if ( $Verbose )
	    {
		print "$NoteString";
	    }
	    print "\n";
	}
    }
    elsif ( ! /^$/ )
    {
	print "Can't parse state line $. '$_'\n";
    }
}
close( IN );


# ******************************************************
# Dump out usage
# ******************************************************
sub Usage ( $ )
{
    my $Unknown = shift;

    print "$Program: unknown option '$Unknown'\n" if ( $Unknown ne "" );
    printf "usage: $Program %s\n", join (" ", sort keys %Options);
    print "use '-h' for more help\n";
    exit 1;

} # usage ()
# ******************************************************

# ******************************************************
# Dump out help
# ******************************************************
sub Help ( )
{
    my ($opt, $text);

    printf "usage: $Program %s\n", join (" ", sort keys %Options);
    foreach $opt (sort {lc($a) cmp lc($b) } keys %Options)
    {
	printf ("  %15s : %-40s\n", $opt, $Options{$opt} );
    }
    exit 0;

} # help ()
# ******************************************************
