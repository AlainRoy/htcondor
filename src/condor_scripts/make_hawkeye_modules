#! /s/std/bin/perl -w
use strict;

# Prototypes
sub main( @ );
sub BuildTarball( $@ );

# Command line stuff
my $Program = "make_hawkeye_modules";
my %Options =
    (
     "[-d=dir]"		=> "Specify target directory 'dir'",
     "[-r]"		=> "Enable release mode",
     "[-f]"		=> "force",
     "[-h]"		=> "Dump help",
     "tarball"		=> "Target tarball",
     "[files]"		=> "List of '.hawk' files",
    );

# Invoke main..
main( @ARGV );
$#ARGV = -1;

# ******************************************************
# Main program..
# ******************************************************
sub main( @ )
{
    my @Targets;
    my $ModulesFile = "Hawkeye.modules";
    my %KnownTargets;
    my $DefaultDir = ".";
    my $TestDir = ".";
    my $ModulePrefix = "";
    my $TargetDir = "";
    my $Force = 0;
    my $ReleaseMode = 0;

    # Process the command line...
    foreach my $Arg ( @_ )
    {
	# Option?
	if ( $Arg =~ /^-(.*)/ )
	{
	    my $Opt = $1;
	    if ( $Opt =~ /^h/ )
	    {
		Help( );
	    }
	    elsif ( $Opt =~ /^d=(.*)/ )
	    {
		$TargetDir = $1;
	    }
	    elsif ( $Opt =~ /^f$/ )
	    {
		$Force = 1;
	    }
	    elsif ( $Opt =~ /^r$/ )
	    {
		$ReleaseMode = 1;
	    }
	    else
	    {
		Usage( $Arg );
	    }
	    next;
	}

	# Must be a target name
	push( @Targets, $Arg );
    }

    # Read the modules file
    open( MODULES, $ModulesFile ) || die "Can't read $ModulesFile";
    my $Target = "";
    while( <MODULES> )
    {
	chomp;
	next if ( ( /^\#/ ) || ( $_ eq "" ) );
	if ( /^directory:\s+(\S+)/i )
	{
	    $DefaultDir = $1;
	}
	elsif ( /^test-directory:\s+(\S+)/i )
	{
	    $TestDir = $1;
	}
	elsif ( /^prefix:\s+(\S+)/i )
	{
	    $ModulePrefix = $1;
	}
	elsif ( /^target:\s+(\S+)/i )
	{
	    $Target = $1;
	}
	elsif ( /^version:\s+(\S+)/i )
	{
	    $KnownTargets{$Target}{Version} = $1;
	}
	elsif ( /^os:\s+(\S+)/i )
	{
	    $KnownTargets{$Target}{OS} = $1;
	}
	elsif ( /^\+(.*)/ )
	{
	    push( @{$KnownTargets{$Target}{HawkFiles}},
		  map( { "$_.hawk" } split( /[\s\,]+/, $1 ) ) );
	}
	else
	{
	    die "$ModulesFile line $.: parse error";
	}
    }
    close( MODULES );

    # Env variable overrides the dirctory from the file...
    if ( exists $ENV{HAWKEYE_RELEASE_DIR} )
    {
	$DefaultDir = "$ENV{HAWKEYE_RELEASE_DIR}/modules";
    }
    if ( exists $ENV{HAWKEYE_MODULES_DIR} )
    {
	$DefaultDir = $ENV{HAWKEYE_MODULES_DIR};
    }

    # Dir logic
    if ( $TargetDir eq "" )
    {
	$TargetDir = $ReleaseMode ? $DefaultDir : $TestDir;
    }

    # Create the directory?
    if ( ! -d $TargetDir )
    {
	mkdir $TargetDir || die "Can't create modoles dir $TargetDir";
    }

    # Any valid targets?
    {
	my @Tmp = keys %KnownTargets;
	die "No targets in $ModulesFile" if ( $#Tmp < 0 );
    }

    # Verify that the TarBall specified
    if ( $#Targets < 0 )
    {
	@Targets = sort keys %KnownTargets;
	print "Using default list: " . join(" ", @Targets ) . "\n";
    }

    # Quick checks of the defined targets
    foreach my $Target( keys %KnownTargets )
    {
	die "$Target has no version defined"
	    if ( ! exists $KnownTargets{$Target}{Version} );
	if ( ! exists $KnownTargets{$Target}{OS} )
	{
	    $KnownTargets{$Target}{OS} = "Unix-Any";
	    warn "No O/S Specified; assuming 'Unix-Any'";
	}
	die "$Target has no files"
	    if ( ! exists $KnownTargets{$Target}{HawkFiles} );
	foreach my $File ( @{$KnownTargets{$Target}{HawkFiles}} )
	{
	    die "'$File' of target '$Target' not found\n" if ( ! -f $File );
	}
    }
    # And, verify that the requested targets exist...
    foreach my $Target ( @Targets )
    {
	die "$Target is not a valid target"
	    if ( ! exists $KnownTargets{$Target} );
    }

    # Ok, now do the work
    print "Target directory = $TargetDir\n";
    foreach my $Target ( @Targets )
    {
	my $Version = $KnownTargets{$Target}{Version};
	my $OS = $KnownTargets{$Target}{OS};
	my $TarBall =
	    $ModulePrefix . $Target . "-" . $Version . "-".  $OS . ".tar.gz";
	my $TarBallFull = "$TargetDir/$TarBall";

	# Does it already exist?
	if ( ( 0 == $Force ) && ( -f $TarBallFull ) )
	{
	    print "\n$TarBall exists; skipping\n";
	    print "  Use -f to force overwrite\n";
	    next;
	}

	# Do it
	print "\nBuilding $Target $Version -> '$TarBall'\n";
	BuildTarball( "$TargetDir/$TarBall",
		      @{$KnownTargets{$Target}{HawkFiles}} );
    }

    # All done: ok
    exit 0;

} # main()
# ******************************************************

# ******************************************************
# Build a single TarBall
# ******************************************************
sub BuildTarball( $@ )
{
    my $TarBall = shift @_;
    my @HawkFiles = @_;

    # Walk through the files..
    my @AllFiles;
    foreach my $HawkFile ( @HawkFiles )
    {
	die "$HawkFile does not exist" if ( ! -f $HawkFile );
	push @AllFiles, $HawkFile;

	open( HAWKFILE, $HawkFile ) || die "Can't read $HawkFile";
	while( <HAWKFILE> )
	{
	    # All we care about is the ModuleFiles line(s)...
	    if ( /MODULEFILES:\s*(.+)/i )
	    {
		my @Files = split( /\s+/, $1 );
		foreach my $File ( @Files )
		{
		    die "$HawkFile line $.: $File does not exist"
			if ( ! -f $File );
		}
		push @AllFiles, @Files;
	    }
	}
	close( HAWKFILE );
    }

    # Ok, now just build the tarball...
    my $Cmd = "tar cvfhz $TarBall " . join( " ", @AllFiles );
    system( $Cmd ) == 0 || die "system '$Cmd' failed: $?";

    return 0;

} # BuildTarball ()
# ******************************************************

# ******************************************************
# Dump out usage
# ******************************************************
sub Usage ( $ )
{
    my $Unknown = shift;

    print "$Program: unknown option '$Unknown'\n" if ( $Unknown ne "" );
    printf "usage: $Program %s\n", join (" ", sort keys %Options);
    print "use '-h' for more help\n";
    exit 1;

} # usage ()
# ******************************************************

# ******************************************************
# Dump out help
# ******************************************************
sub Help ( )
{
    my ($opt, $text);

    printf "usage: $Program %s\n", join (" ", sort keys %Options);
    foreach $opt (sort {lc($a) cmp lc($b) } keys %Options)
    {
	printf ("  %15s : %-40s\n", $opt, $Options{$opt} );
    }
    exit 0;

} # help ()
# ******************************************************
