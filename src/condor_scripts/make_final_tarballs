#!/usr/bin/env perl

# This script performs all steps necessary to take the release.tar
# files for whatever platforms you want and put them onto the web as
# the completed binary release with all the right support files, name,
# etc, etc.  Read the README file in this directory for details on how
# to release a new patch level or revision of Condor.
#
# This should be run in the top-level src directory.
#

# Autoflush the output
$| = 1;

# Deal with any command-line args we are passed:
while( $_ = shift( @ARGV ) ) {
  SWITCH: {	
    if( /-s.*/ ) {
	$sys = shift(@ARGV);
	last SWITCH;
    }
    if( /-v.*/ ) {
	$versarg = shift(@ARGV);
	last SWITCH;
    }
    if( /-l.*/ ) {
	$libc = shift(@ARGV);
	last SWITCH;
    }
    if( /-tarcmd.*/ ) {
	$tar_cmd = shift(@ARGV);
	last SWITCH;
    }
    if( /-cpcmd.*/ ) {
	$cp_cmd = shift(@ARGV);
	last SWITCH;
    }
    if( /-t.*/ ) {
	# this is short for "-target".  if we get "-tarcmd", we'll
	# already catch it above, so we can leave this test alone...
        $target = shift(@ARGV);
	if( ! -d $target ) {
	    die "Target directory $target does not exist!\n";
	}
        last SWITCH;
    }
  }
}

# Now, grab the version of this release.
if( $versarg ) {
    $vers_string = $versarg;
} else {
    # If we weren't told on the command line, use the condor_master
    # binary with -version to find the version string.
    if( -f "strip_dir/sbin/condor_master" ) {
        $vers_string=`strip_dir/sbin/condor_master -version`;
    } elsif ( -f "static_dir/sbin/condor_master" ) {
        $vers_string=`./static_dir/sbin/condor_master -version`;
    } else {
	die "ERROR: can't find a condor_version, and no -v specified";
    }
    if( ! $vers_string ) {
	die "ERROR: Can't find version string, and no -v specified";
    }
}

$vers_string =~ /(.*\$CondorVersion: )?(\d+)\.(\d+)\.(\d+).*/;
$majorv = $2;
$minorv = $3;
$releasev = $4;
$version = "$majorv.$minorv.$releasev";

if( $version =~ /(\d+)\.(\d+)\.(\d+)/ ) {
    print "Making final tarballs for Condor Version $version\n";
} else {
    die "ERROR: Can't parse the version string!";
}

# Things you should probably leave alone:
require 5.002;

######################################################################
# Settings you may want to customize
######################################################################

# These are the modules you actually want to build.
@modules = ( "condor", "ckpt_server", "pvm", "sdk","eventd", "dagman" );
#@modules = ( "smp_startd", "ckpt_server", "pvm", "sdk" );
#@modules = ( "condor", "ckpt_server", "pvm", "mpi" );
#@modules = ( "ckpt_server", "pvm" );
#@modules = ( "condor" );

# List any special files, other than README, DOC, INSTALL, and
# LICENSE.TXT (which are included in all releases) that you want in
# the skeleton for a given module.
%skelfiles = (
  "condor"   => [ "condor_install", "condor_configure", "examples", ],
);

# If any of the files you specify aren't found in the $realskel
# directory you specify, put the relative path to where your file can
# be found here.
%filesource = (
  "condor_install" => "condor_scripts/condor_install",
  "condor_configure" => "condor_scripts/condor_configure",
);	   

# If the tar file for this module has a different name than
# "$module.tar", specify that here.
%tarfile = (
  "condor" => "release.tar",
);	   

# English descriptions of the modules, used in the README, etc. 
%module_descriptions = (
  "condor"        => "Main release",
  "view_client"   => "CondorView client contrib module",
  "dagman"        => "DagMan contrib module",
  "pvm"           => "PVM contrib module",
  "ckpt_server"   => "Checkpoint Server contrib module",
  "mpi"           => "MPI contrib module",
  "sdk"           => "software developer's kit",
  "eventd"        => "Condor Eventd contrib module"
);	   

######################################################################
# The rest of these settings can probably stay just like they are.
######################################################################

# Some paths of interest:
$skel="release_skeleton";
$realskel="condor_release";

%releaselocation = (
  "static"        => "static_dir",
  "dynamic"       => "strip_dir"
);

# Convert from AFS @sys names to our names for the tarballs.
%opsysname = (
  "sun4x_56"      => "solaris26",
  "sun4x_57"      => "solaris27",
  "sun4x_58"      => "solaris28",
  "sun4x_59"      => "solaris29",
  "i386_rh72"     => "linux",
  "i386_rh80"     => "linux",
  "i386_rh9"      => "linux",
  "ia64_rh72"     => "linux",
  "ia64_sles81"   => "linux",
  "alpha_rh72"    => "linux",
  "alpha_dux40"   => "dux40",
  "alpha_dux51"   => "dux51",
  "sgi_65"        => "irix65",
  "ppc_macosx"    => "MacOSX",
  "hp_ux102"      => "hpux10.20",
  "hp_ux110"      => "hpux11.00",
  "ppc_aix51"	  => "aix5.1",
  "ppc_aix52"	  => "aix5.2"
);

%archname = (
  "sun4x_56"      => "Sparc",
  "sun4x_57"      => "Sparc",
  "sun4x_58"      => "Sparc",
  "sun4x_59"      => "Sparc",
  "i386_rh72"     => "x86",
  "i386_rh80"     => "x86",
  "i386_rh9"      => "x86",
  "ia64_rh72"     => "ia64",
  "ia64_sles81"   => "ia64",
  "alpha_rh72"    => "Alpha",
  "alpha_dux40"   => "Alpha",
  "alpha_dux51"   => "Alpha",
  "sgi_65"        => "SGI",
  "ppc_macosx"    => "PPC",
  "hp_ux102"      => "HPPAR",
  "hp_ux110"      => "HPPAR",
  "ppc_aix51"	  => "aix",
  "ppc_aix52"	  => "aix"
);


# NOTE: any two entries in here with the same arch *MUST* have
# seperate values, or else we get identically named files and that's
# no good at all!
%libcname = (
  "i386_rh72"   => "glibc22",
  "i386_rh80"   => "redhat80",
  "i386_rh9"    => "glibc23",
  "ia64_rh72"   => "glibc22",
  "ia64_sles81" => "sles81",
  "alpha_rh72"  => "glibc22",
);


umask(022);

######################################################################
# Actual work begins...
######################################################################

if( ! $target) {
   $target="/p/condor/public/binaries";
}

# Make sure we know what platform we are... If we weren't told on the
# command-line, run "sys" and use that.
if( ! $sys ) {
    $sys=`sys`;
    chomp($sys);
} 
$arch = $archname{$sys};
$opsys = $opsysname{$sys};
$libc = $libcname{$sys};

if( ! $tar_cmd ) {
    $tar_cmd = "tar --owner=root --group=root";
}
if( ! $cp_cmd ) {
  # the condor build system always tells us the right thing, so
  # hopefully we never hit this code.  however, if we need a default,
  # it really depends on if we're using GNU cp or not.  on linux, we
  # can safely use the GNU flags, and on the others, we'll just have
  # to live without and hope for the best.  luckily, the configure
  # script figures it out for us and tells us, so it's not really an
  # issue inside here anymore...
  if( $opsys =~ /.*linux.*/ ) {
    $cp_cmd = "cp -rL";
  } else {  
    $cp_cmd = "cp -r";
  }
}

`rm -rf $skel`;
mkdir( "$skel", 0777 ) || die "Can't mkdir($skel): $!\n";

($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime;
$mon++;
$date="$mon/$mday/$year";

foreach $module ( @modules ) {

    $release="$module-$version";
    if( $tarfile{$module} ) {
	$tarfile=$tarfile{$module};
    } else {
	$tarfile="$module.tar";
    }

    # Setup skeleton directory
    print "Setting up skeleton directory for \"$module\"... ";
    mkdir( "$skel/$release", 0777 ) || 
	die "Can't mkdir($skel/$release): $!\n";

    # You always want the same version of LICENSE.TXT in everything. 
    $out = `cp -f $realskel/LICENSE.TXT $skel/$release`;
    if( ($? >> 8) != 0 ) {
	die "Can't cp $realskel/LICENSE.TXT: $out";
    }

    # Now, you always want a README, DOC, and INSTALL
    foreach $file ( "README", "INSTALL", "DOC" ) {
	$out = `cp -f $realskel/$file $skel/$release/`;
	if( ($? >> 8) != 0 ) {
	    die "Can't cp $realskel/$file: $out";
	}
    }

    # Now, handle any special case files for a given module
    foreach $file ( @{$skelfiles{$module}} ) {
		if( $filesource{$file} ) {
	   	 $src = $filesource{$file};
		} else {
	   	 $src = "$realskel/$file";
		}
		if( $filedest{$file} ) {
	   	 $dest = $filedest{$file};
		} else {
	   	 $dest = $file;
		}
		$out = `$cp_cmd $src $skel/$release/$dest`;
		if( ($? >> 8) != 0 ) {
		    die "Can't $cp_cmd $src: $out";
		}
    }
    `rm -rf $skel/$release/CVS`;
    `rm -rf $skel/$release/*/CVS`;
    `rm -rf $skel/$release/*/*/CVS`;

    print "done.\n";

    # Now, handle static and/or dynamic versions, whatever exists... 

    foreach $linktype ( "static", "dynamic" ) {
	# Make sure the proper tar file exists
	if( ! (-d $releaselocation{$linktype} && 
	       -f "$releaselocation{$linktype}/$tarfile") ) {
	    print STDERR "There's no $tarfile file for $linktype on this platform, skipping.\n";
	    next;
	}

	# Figure out what our filenames should look like.
	$platform="$opsys-$arch";
	if( $libc ) {
	    $platform = "$platform-$libc";
	}
	if( $linktype =~ /dynamic/ ) {
	    $platform = "$platform-dynamic";
	}

	# Copy the tarfile with the right permissions into the skeleton. 
	$out = `cp $releaselocation{$linktype}/$tarfile $skel/$release/$tarfile`;
	if( ($? >> 8) != 0 ) {
	    die "Can't cp $releaselocation{$linktype}/$tarfile: $out";
	}

	# Create full archive 
	chdir( $skel ) || die "Can't chdir to $skel: $!\n";
	print "Creating full archive: $release.tar\n";
	print `$tar_cmd -cvf $release.tar $release`;
	if( ($? >> 8) != 0 ) {
	    die "Can't tar $release.tar $release\n";
	}

	chdir( ".." ) || die "Can't chdir to ..: $!\n";

	# Delete the release.tar we're now done with.
	unlink( "$skel/$release/$tarfile" );

	# Fix ownerships in the full archive.
	$out = `cp $skel/$release.tar $skel/$release-$platform.tar`;
	if( ($? >> 8) != 0 ) {
	    die "Can't cp $skel/$release.tar $skel/$release-$platform.tar: $out";
	}

	# Delete the tar file we're now done with.
	unlink( "$skel/$release.tar" );

	# Figure out where we want put this tarball
	if( $module =~ /condor/ ) {
	    $targetdir = "$target/v$majorv.$minorv";
	} else {
	    $targetdir = "$target/contrib";
	}
	if( ! -d $targetdir ) {
	    mkdir( $targetdir, 0777 ) || die "Can't mkdir $targetdir: $!\n";
	}
	$targetfile = "$targetdir/$release-$platform.tar";

	# Make sure there's nothing in the way where we want to put it.
	unlink( "$targetfile", "$targetfile.Z", "$targetfile.gz" );

	# Compress as appropriate, and move to the final location.
	if( $platform =~ /.*linux.*/ ) {
	    print "gzipping $skel/$release-$platform.tar\n";
	    $out = `gzip $skel/$release-$platform.tar`;
	    if( ($? >> 8) != 0 ) {
		die "Can't gzip $skel/$release-$platform.tar: $out";
	    }
	    print "Moving $release-$platform.tar.gz into $targetdir ... ";
	    $out = `mv $skel/$release-$platform.tar.gz $targetdir`;
	    if( ($? >> 8) != 0 ) {
		die "Can't mv $skel/$release-$platform.tar.gz $targetdir: $out";
	    }
	    print "done.\n";
	} else {
	    print "compressing $skel/$release-$platform.tar\n";
	    $out = `compress $skel/$release-$platform.tar`;
	    if( ($? >> 8) != 0 ) {
		die "Can't compress $skel/$release-$platform.tar: $out";
	    }
	    print "Moving $release-$platform.tar.Z into $targetdir ... ";
	    $out = `mv $skel/$release-$platform.tar.Z $targetdir`;
	    if( ($? >> 8) != 0 ) {
		die "Can't mv $skel/$release-$platform.tar.Z $targetdir: $out";
	    }
	    print "done.\n";
	}
    }
}

sub customize {
    local( $source, $target, $module, $tarfile ) = @_;
    local( $description ) = $module_descriptions{$module};

    open( SRC, "<$source" ) || die "\nCan't open $source for reading.\n";
    open( TARGET, ">$target" ) || die "\nCan't open $target for writing.\n";

    while( <SRC> ) {
	s/#module#/$module/;
	if( length($tarfile) < 8 ) {
	    s/#tarfile#/$tarfile\t/;
	} else {
	    s/#tarfile#/$tarfile/;
	}
	s/#description#/$description/;
	s/#date#/$date/;
	print TARGET $_;
    }
    close( SRC );
    close( TARGET );
}
    


