#!/usr/bin/env perl

##/***************************Copyright-DO-NOT-REMOVE-THIS-LINE**
##
## Condor Software Copyright Notice
## Copyright (C) 1990-2006, Condor Team, Computer Sciences Department,
## University of Wisconsin-Madison, WI.
##
## This source code is covered by the Condor Public License, which can
## be found in the accompanying LICENSE.TXT file, or online at
## www.condorproject.org.
##
## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
## AND THE UNIVERSITY OF WISCONSIN-MADISON "AS IS" AND ANY EXPRESS OR
## IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
## WARRANTIES OF MERCHANTABILITY, OF SATISFACTORY QUALITY, AND FITNESS
## FOR A PARTICULAR PURPOSE OR USE ARE DISCLAIMED. THE COPYRIGHT
## HOLDERS AND CONTRIBUTORS AND THE UNIVERSITY OF WISCONSIN-MADISON
## MAKE NO MAKE NO REPRESENTATION THAT THE SOFTWARE, MODIFICATIONS,
## ENHANCEMENTS OR DERIVATIVE WORKS THEREOF, WILL NOT INFRINGE ANY
## PATENT, COPYRIGHT, TRADEMARK, TRADE SECRET OR OTHER PROPRIETARY
## RIGHT.
##
##***************************Copyright-DO-NOT-REMOVE-THIS-LINE**/


# This script performs all steps necessary to take the release.tar
# files for whatever platforms you want and put them onto the web as
# the completed binary release with all the right support files, name,
# etc, etc.  Read the README file in this directory for details on how
# to release a new patch level or revision of Condor.
#
# This should be run in the top-level src directory.
#

use Getopt::Long;

# Autoflush the output
$| = 1;

use vars qw/ $opt_help $opt_sys $opt_version $opt_libc $opt_tarcmd $opt_cpcmd $opt_target/;

GetOptions ( 'help'              => \$opt_help,
             'sys=s'             => \$opt_sys,
             'version=s'         => \$opt_version,
             'libc=s'            => \$opt_libc,
             'tarcmd=s'          => \$opt_tarcmd,
             'cpcmd=s'           => \$opt_cpcmd,
             'linktype=s'        => \$opt_linktype,
             'target=s'          => \$opt_target);

# Deal with any command-line args we are passed:

my ($sys, $versarg, $libc, $tar_cmd, $cp_cmd, $target);

if (defined($opt_help)) {
    print_usage(); exit 0;
}
if (defined($opt_sys)) {
    $sys = $opt_sys;
}
if (defined($opt_version)) {
    $versarg = $opt_version;
}
if (defined($opt_libc)) {
    $libc = $opt_libc;
}
if (defined($opt_tarcmd)) {
    $tar_cmd = $opt_tarcmd;
}
if (defined($opt_cpcmd)) {
    $cp_cmd = $opt_cpcmd;
}
if (defined($opt_target)) {
    $target = $opt_target;
}

if (defined($opt_linktype)) {
   @linktypes = split /,/, $opt_linktype;
} else {
   # set up a default of everything
   @linktypes = 
      ("static", "dynamic", "unstripped-dynamic", "unstripped-static");
}

# Now, grab the version of this release.
if( $versarg ) {
    $vers_string = $versarg;
} else {
    # If we weren't told on the command line, use the condor_master
    # binary with -version to find the version string.
    if( -f "strip_dir/sbin/condor_master" ) {
        $vers_string=`strip_dir/sbin/condor_master -version`;
    } elsif ( -f "static_dir/sbin/condor_master" ) {
        $vers_string=`./static_dir/sbin/condor_master -version`;
    } else {
	die "ERROR: can't find a condor_version, and no -v specified";
    }
    if( ! $vers_string ) {
	die "ERROR: Can't find version string, and no -v specified";
    }
}

$vers_string =~ /(.*\$CondorVersion: )?(\d+)\.(\d+)\.(\d+).*/;
$majorv = $2;
$minorv = $3;
$releasev = $4;
$version = "$majorv.$minorv.$releasev";

if( $version =~ /(\d+)\.(\d+)\.(\d+)/ ) {
    print "Making final tarballs for Condor Version $version\n";
} else {
    die "ERROR: Can't parse the version string!";
}

# Things you should probably leave alone:
require 5.002;

######################################################################
# Settings you may want to customize
######################################################################

# These are the modules you actually want to build.

# The modules hash format is thus:
# The toplevel keys in the %modules hash are the names of the modules you'd
# like to build. These names end up as the first thing in the file name
# if the finished tarball, so "condor" as a module name will end up like:
# condor-6.8.5-....
# Then the hash table defined by the module key must contain these keys:
#	generate skelfiles tarfile releaselocation
# Their description is as such:
#	generate
#		This is used for debugging this script. Set it to 0 to not build
#		the module. Set it to 1 to build it.
#	skelfiles
#		This is an array of objects to copy from the source skeleton directory
#		to the destination directory (which will eventually become the final
#		tarball). An object will either be a bare string, in which case that
#		means to copy the string from the $realskel directory into the
#		destination directory and have it be named the same thing, or the
#		object will be an array which contains the source file and the 
#		destination filename. In the case of the array, the source file is
#		found relative to the cwd of the script. In any case, the source file
#		may be a directory, in which cse it is recursively copied.
#		NOTE: There is no way to specify an absolute path or files deeper in 
#		the $realskel directory.
#	tarfile
#		This is an array where the first index is the name of the Makefile
#		generated tarball that this script is packaging. This is the tarfile
#		name searched for in each release location. The second value of the
#		array is whether or not you want the tarfile untarred or not into
#		the destination directory.
#	releaselocation
#		The key of this hash is one of these linktype specifiers:
#			static dynamic unstripped-dynamic unstripped-static
#		The value is the src/ directory name of where that linktype had been
#		produced. For example, the "dynamic" linktype means the stripped
#		dynamically linked executables, which are found in src/strip_dir
#		after "make stripped" completes.

%modules = (
	"condor" => {
		"generate" => 1,

		"skelfiles" => [ 
			"README", "DOC", "INSTALL", "LICENSE.TXT",
			[ "condor_scripts/condor_configure", "condor_configure" ],
			"examples" 
		],

		"tarfile" => [ "release.tar", 0 ],

		"releaselocation" => {
  			"dynamic"       => "strip_dir",
  			"static"        => "static_dir",
  			"unstripped-static"  => "static_unstrip_dir",
  			"unstripped-dynamic" => "release_dir",
		},
	},
	
	"condordebugsyms" => {
		"generate" => 1,

		"skelfiles" => [ 
			"DOC", "INSTALL", "LICENSE.TXT",
			[ "condor_release/README.debugsyms", "README" ], 
		],

		"tarfile" => [ "debugsyms.tar", 1],

		# Currently, this module exists only for the 'dynamic' linktype.
		"releaselocation" => {
  			"dynamic"       => "strip_dir",
		},
	},
);

######################################################################
# The rest of these settings can probably stay just like they are.
######################################################################

# Some paths of interest:
$skel="release_skeleton";
$realskel="condor_release";

# Convert from AFS @sys names to our names for the tarballs.
%opsysname = (
  "sun4x_56"      => "solaris26",
  "sun4x_57"      => "solaris27",
  "sun4x_58"      => "solaris28",
  "sun4x_59"      => "solaris29",
  "i386_debian40"   => "linux",
  "i386_rh72"     => "linux",
  "i386_rh80"     => "linux",
  "i386_rh9"      => "linux",
  "i386_tao1"     => "linux",
  "i386_centos42"   => "linux",
  "i386_centos43"   => "linux",
  "i386_centos44"   => "linux",
  "ia64_rh72"     => "linux",
  "ia64_rhel3"    => "linux",
  "i386_rhel3"    => "linux",
  "ia64_sles81"   => "linux",
  "alpha_rh72"    => "linux",
  "condor_ppc_yd30" => "linux",
  "condor_ppc_sles9" => "linux",
  "condor_ppc_rhel3" => "linux",
  "x86_64_rhel3"  => "linux",
  "x86_64_debian40" => "linux",
  "alpha_dux40"   => "dux40",
  "alpha_dux51"   => "dux51",
  "sgi_65"        => "irix65",
  "i386_macosx103"   => "MacOSX10.3",
  "i386_macosx104"   => "MacOSX10.4",
  "ppc_macosx103"    => "MacOSX10.3",
  "ppc_macosx104"    => "MacOSX10.4",
  "hp_ux102"      => "hpux10.20",
  "hp_ux110"      => "hpux11.00",
  "ppc_aix51"	  => "aix5.1",
  "ppc_aix52"	  => "aix5.2",
  "i386_freebsd4" => "freebsd4",
  "i386_freebsd5" => "freebsd5",
  "i386_freebsd6" => "freebsd6"
);

%archname = (
  "sun4x_56"      => "Sparc",
  "sun4x_57"      => "Sparc",
  "sun4x_58"      => "Sparc",
  "sun4x_59"      => "Sparc",
  "i386_debian40"   => "x86",
  "i386_rh72"     => "x86",
  "i386_rh80"     => "x86",
  "i386_rh9"      => "x86",
  "i386_tao1"     => "x86",
  "i386_centos42"   => "x86",
  "i386_centos43"   => "x86",
  "i386_centos44"   => "x86",
  "ia64_rh72"     => "ia64",
  "ia64_rhel3"    => "ia64",
  "i386_rhel3"    => "x86",
  "ia64_sles81"   => "ia64",
  "alpha_rh72"    => "Alpha",
  "condor_ppc_yd30" => "PPC",
  "condor_ppc_sles9" => "PPC",
  "condor_ppc_rhel3" => "PPC",
  "x86_64_rhel3"  => "x86_64",
  "x86_64_debian40" => "x86_64",
  "alpha_dux40"   => "Alpha",
  "alpha_dux51"   => "Alpha",
  "sgi_65"        => "SGI",
  "i386_macosx103"   => "x86",
  "i386_macosx104"   => "x86",
  "ppc_macosx103"    => "PPC",
  "ppc_macosx104"    => "PPC",
  "hp_ux102"      => "HPPAR",
  "hp_ux110"      => "HPPAR",
  "ppc_aix51"	  => "aix",
  "ppc_aix52"	  => "aix",
  "i386_freebsd4" => "x86",
  "i386_freebsd5" => "x86",
  "i386_freebsd6" => "x86"
);


# NOTE: any two entries in here with the same arch *MUST* have
# seperate values, or else we get identically named files and that's
# no good at all!
%libcname = (
  "i386_debian40"   => "debian40",
  "i386_rh72"   => "glibc22",
  "i386_rh80"   => "redhat80",
  "i386_rh9"    => "glibc23",
  "i386_tao1"   => "tao1",
  "i386_centos42" => "centos42",
  "i386_centos43" => "centos43",
  "i386_centos44" => "centos44",
  "x86_64_rhel3"  => "rhel3",
  "x86_64_debian40"  => "debian40",
  "i386_rhel3"  => "rhel3",
  "ia64_rh72"   => "glibc22",
  "ia64_rhel3"  => "rhel3",
  "ia64_sles81" => "sles81",
  "condor_ppc_yd30" => "yd30",
  "condor_ppc_sles9" => "sles9",
  "condor_ppc_rhel3" => "glibc23",
  "alpha_rh72"  => "glibc22",
);


umask(022);

######################################################################
# Actual work begins...
######################################################################

if( ! $target) {
   $target="/p/condor/public/binaries";
}

# Make sure we know what platform we are... If we weren't told on the
# command-line, run "sys" and use that.
if( ! $sys ) {
    $sys=`sys`;
    chomp($sys);
} 
$arch = $archname{$sys};
$opsys = $opsysname{$sys};
$libc = $libcname{$sys};

if( ! $tar_cmd ) {
    $tar_cmd = "tar --owner=root --group=root";
}
if( ! $cp_cmd ) {
  # the condor build system always tells us the right thing, so
  # hopefully we never hit this code.  however, if we need a default,
  # it really depends on if we're using GNU cp or not.  on linux, we
  # can safely use the GNU flags, and on the others, we'll just have
  # to live without and hope for the best.  luckily, the configure
  # script figures it out for us and tells us, so it's not really an
  # issue inside here anymore...
  if( $opsys =~ /.*linux.*/ ) {
    $cp_cmd = "cp -rL"; 
  } else {  
    $cp_cmd = "cp -r"; 
  } 

}

`rm -rf $skel`;

mkdir( "$skel", 0777 ) || die "Can't mkdir($skel): $!\n";

($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime;
$mon++;
$date="$mon/$mday/$year";

print "Building linktype(s): @linktypes\n";

foreach $module ( sort keys %modules ) {

    die "Define generate for $module" 
		if( !exists($modules{$module}{'generate'}) );

	if ($modules{$module}{'generate'} != 1) {
		print "Skipping the processing of module: $module\n";
		next;
	}

	print "Processing module: $module\n";

    $release="$module-$version";

    die "Define a tarfile for $module" 
		if( !exists($modules{$module}{'tarfile'}) );

	# the first argument is the tarfile, the second is whether or not we
	# should untar it.
	($tarfile,$untar) = @{$modules{$module}{'tarfile'}};

	# Setup the skeleton directory
    print "Setting up skeleton directory for \"$module\"...\n";
	mkdir("$skel/$release", 0777) || 
		die "Can't mkdir($skel/$release): $!";

    # Now, copy over any files specified for a given module
    foreach $file ( @{$modules{$module}{'skelfiles'}} ) {
		
		if (ref($file) eq "ARRAY") {
			($src, $dest) = @{$file};
		} else {
	   	 	$src = "$realskel/$file";
	   	 	$dest = $file;
		}
		# Must be able to do recursive copy in case of directories...
		runcmd("$cp_cmd $src $skel/$release/$dest");
    }
    runcmd("rm -rf $skel/$release/CVS", 1);
    runcmd("rm -rf $skel/$release/*/CVS", 1);
    runcmd("rm -rf $skel/$release/*/*/CVS", 1);
    print "done.\n";

    # Now, handle static and/or dynamic versions, whatever exists... 

	print "Building specified linktypes versions of release tarballs\n";
    foreach $linktype ( @linktypes ) {
		# If the modules doesn't provide a release for this linktype, just
		# ignore it.
		if (!exists($modules{$module}{'releaselocation'}{$linktype})) {
			print "Module $module doesn't support linktype '$linktype'. " .
				"Ignoring.\n";
			next;
		}

		print "Building $linktype from $modules{$module}{'releaselocation'}{$linktype}/$tarfile\n";

		# Make sure the proper tar file exists
		if( ! (-d $modules{$module}{'releaselocation'}{$linktype} && 
	       	-f "$modules{$module}{'releaselocation'}{$linktype}/$tarfile") ) {
	    	print STDERR "There's no $tarfile file for $linktype on this platform, skipping.\n";
	    	next;
		}

		# Figure out what our filenames should look like.
		$platform="$opsys-$arch";
		if( $libc ) {
	    	$platform .= "-$libc";
		}
		if( $linktype =~ /dynamic/ ) {
	    	$platform .= "-dynamic";
		}
		if( $linktype =~ /unstripped/ ) {
	    	$platform .= "-unstripped";
		}
		
		if ($untar == 1) {
			# If I've asked for this tarball to have been untarred, then 
			# untar it into the skeleton directory
			print "Untaring tarfile into skeleton.\n";
			# This runs in a subshell as to not distub the cwd of the script
			print runcmd("(cd $skel/$release && " . 
				"$tar_cmd -xf " .
				"../../$modules{$module}{'releaselocation'}{$linktype}/$tarfile)");
		} else {
			# Otherwise just copy the tarfile with the right permissions into
			# the skeleton. 

			print "Copying tarfile into skeleton.\n";

			# So one may run this script over and over, we will do a copy
			# here instead of a move, otherwise the toplevel makefile will
			# have to be called again to rebuild the source file.

			runcmd("dd " .
				"if=$modules{$module}{'releaselocation'}{$linktype}/$tarfile " .
				"of=$skel/$release/$tarfile bs=10485760");
		}

		# Create full archive 
		print "Creating the full archive $skel/$release.tar\n";
		# This runs in a subshell as to not distub the cwd of the script
		print runcmd("(cd $skel && $tar_cmd -cvf $release.tar $release)");

		# Delete the release.tar we're now done with.
		print "Cleaning up some files...\n";
		runcmd("unlink $skel/$release/$tarfile", 1);

		print "Renaming tarball to archecture specific name.\n";
		runcmd("mv $skel/$release.tar $skel/$release-$platform.tar");
	
		# Figure out where we want put this tarball
		if( $module =~ /condor/ ) {
	    	$targetdir = "$target/v$majorv.$minorv";
		} else {
	    	$targetdir = "$target/contrib";
		}
		if( ! -d $targetdir ) {
	    	print "mkdir($targetdir, 0777)\n";
	    	mkdir( $targetdir, 0777 ) || die "Can't mkdir $targetdir: $!\n";
		}
		$targetfile = "$targetdir/$release-$platform.tar";

		# Make sure there's nothing in the way where we want to put it.
		runcmd("unlink $targetfile", 1);
		runcmd("unlink $targetfile.Z", 1);
		runcmd("unlink $targetfile.gz", 1);

		# gzip, and move to the final location.  we no longer bother
		# with trying to use compress on non-linux platforms, since
		# it's not unreasonable to require gzip in this day and age.
		# we already check for gzip (but not compress) on our build
		# machines @ configure time, and some of our platforms don't
		# put compress in a reasonable location... :(
		runcmd("gzip $skel/$release-$platform.tar");

		print "Moving $release-$platform.tar.gz into $targetdir\n";
		runcmd("mv $skel/$release-$platform.tar.gz $targetdir");
		print "done.\n";
	}
}

exit 0;

# The first argument is the command for the shell to execute.
# The presence of the second argument, means don't die if the command fails.
# Returns the output of the program, if any.
sub runcmd() {
	my ($cmd, $shouldnt_die) = @_;
	my (@out);

	die "Can't execute undefined command!"
		if (!defined($cmd));

	print "$cmd\n";
	@out = `$cmd 2>&1`;

	# check if the person who runs the command doesn't care if it succeeds 
	# or not.
	if( ($? >> 8) != 0 ) {
		if (!defined($shouldnt_die)) {
			$out = join("\n", @out);
	   		die "Can't $cmd: $out";
		}
	}

	return @out;
}

sub print_usage() {

    print <<END_USAGE;
--help
This screen

--sys=<System Name>

--version=<Condor Version String>

--libc=<libc name>

--tarcmd=<tar command with args>

--cpcmd=<cp command with args>

--target=<target location>

--linktype=<a set of one or more of:
   static, dynamic, unstripped-dynamic, unstripped-static>

END_USAGE
}
