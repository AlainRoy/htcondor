/***************************Copyright-DO-NOT-REMOVE-THIS-LINE**
 * CONDOR Copyright Notice
 *
 * See LICENSE.TXT for additional notices and disclaimers.
 *
 * Copyright (c)1990-1998 CONDOR Team, Computer Sciences Department, 
 * University of Wisconsin-Madison, Madison, WI.  All Rights Reserved.  
 * No use of the CONDOR Software Program Source Code is authorized 
 * without the express consent of the CONDOR Team.  For more information 
 * contact: CONDOR Team, Attention: Professor Miron Livny, 
 * 7367 Computer Sciences, 1210 W. Dayton St., Madison, WI 53706-1685, 
 * (608) 262-0856 or miron@cs.wisc.edu.
 *
 * U.S. Government Rights Restrictions: Use, duplication, or disclosure 
 * by the U.S. Government is subject to restrictions as set forth in 
 * subparagraph (c)(1)(ii) of The Rights in Technical Data and Computer 
 * Software clause at DFARS 252.227-7013 or subparagraphs (c)(1) and 
 * (2) of Commercial Computer Software-Restricted Rights at 48 CFR 
 * 52.227-19, as applicable, CONDOR Team, Attention: Professor Miron 
 * Livny, 7367 Computer Sciences, 1210 W. Dayton St., Madison, 
 * WI 53706-1685, (608) 262-0856 or miron@cs.wisc.edu.
****************************Copyright-DO-NOT-REMOVE-THIS-LINE**/

#include "condor_common.h"
#include "condor_debug.h"
#include "condor_string.h"
#include "condor_config.h"
#include "condor_jobqueue.h"
#include "condor_uid.h"
#include "condor_file_info.h"
#include "name_tab.h"
#include "proto.h"
#include "condor_sys.h"
#include "condor_io.h"
#include "startup.h"
#include "fileno.h"
#include "condor_rsc.h"
#include "renice_self.h"

#if defined(AIX32)
#	include <sys/id.h>
#endif

const mode_t REGULAR_FILE_MODE =
	S_IRUSR | S_IWUSR |					// rw- for user
	S_IRGRP |					        // r-- for group
	S_IROTH;						    // r-- for other

const mode_t EXECUTABLE_FILE_MODE =
	S_IRUSR | S_IWUSR | S_IXUSR |		// rwx for user
	S_IRGRP |           S_IXGRP |		// r-x for group
	S_IROTH |           S_IXOTH;		// r-x for other

const mode_t LOCAL_DIR_MODE =
	S_IRUSR | S_IWUSR | S_IXUSR |		// rwx for user
	S_IRGRP | S_IWGRP | S_IXGRP |		// rwx for group
	S_IROTH | S_IWOTH | S_IXOTH;		// rwx for other


#include "user_proc.h"
#include "condor_sys.h"

static char *_FileName_ = __FILE__;     /* Used by EXCEPT (see except.h)     */

extern char	*Execute;			// Name of directory where user procs execute

extern "C" {
	void _updateckpt( char *, char *, char * );
	void killkids(pid_t, int);
}
void open_std_file( int which );
void set_iwd();

/*
  With bytestream checkpointing, there is no updating of checkpoints - the
  user process does everything on its own.
*/
#if !defined(NO_CKPT)
extern "C" {
void
_updateckpt( char *a, char *b, char *c )
{
	EXCEPT( "Should never get here" );
}
}
#endif

extern sigset_t	ChildSigMask;
extern NameTable SigNames;
extern char *ThisHost;
extern char *InitiatingHost;
extern ReliSock	*SyscallStream;	// stream to shadow for remote system calls
extern int EventSigs[];
int UserProc::proc_index = 1;

#ifndef MATCH
#define MATCH 0	// for strcmp
#endif

extern NameTable JobClasses;
extern NameTable ProcStates;

int connect_to_port( int );

UserProc::~UserProc()
{
	delete [] cmd;
	delete [] args;
	delete [] env;
	delete [] local_dir;
	delete [] cur_ckpt;
	delete [] core_name;
	if ( family ) {
		delete family;
	}
}

void
UserProc::display()
{
	dprintf( D_ALWAYS, "User Process %d.%d {\n", cluster, proc );

	dprintf( D_ALWAYS, "  cmd = %s\n", cmd );
	dprintf( D_ALWAYS, "  args = %s\n", args );
	dprintf( D_ALWAYS, "  env = %s\n", env );

	dprintf( D_ALWAYS, "  local_dir = %s\n", local_dir );
	dprintf( D_ALWAYS, "  cur_ckpt = %s\n", cur_ckpt );
	dprintf( D_ALWAYS, "  core_name = %s\n", core_name );

	dprintf( D_ALWAYS, "  uid = %d, gid = %d\n", uid, gid );

	dprintf( D_ALWAYS, "  v_pid = %d\n", v_pid );
	if( pid ) {
		dprintf( D_ALWAYS, "  pid = %d\n", pid );
	} else {
		dprintf( D_ALWAYS, "  pid = (NOT CURRENTLY EXECUTING)\n" );
	}

	display_bool( D_ALWAYS, "  exit_status_valid", exit_status_valid );
	if( exit_status_valid ) {
		dprintf( D_ALWAYS, "  exit_status = 0x%x\n", exit_status );
	} else {
		dprintf( D_ALWAYS, "  exit_status = (NEVER BEEN EXECUTED)\n" );
	}

	display_bool( D_ALWAYS, "  ckpt_wanted", ckpt_wanted );
	display_bool( D_ALWAYS, "  coredump_limit_exists", coredump_limit_exists );
	if( coredump_limit_exists ) {
		dprintf( D_ALWAYS, "  coredump_limit = %d\n", coredump_limit );
	}

	dprintf( D_ALWAYS, "  soft_kill_sig = %d\n", soft_kill_sig );
	dprintf( D_ALWAYS, "  job_class = %s\n", JobClasses.get_name(job_class) );

	dprintf( D_ALWAYS, "  state = %s\n", ProcStates.get_name(state) );
	display_bool( D_ALWAYS, "  new_ckpt_created", new_ckpt_created );
	display_bool( D_ALWAYS, "  ckpt_transferred", ckpt_transferred );
	display_bool( D_ALWAYS, "  core_created", core_created );
	display_bool( D_ALWAYS, "  core_transferred", core_transferred );
	display_bool( D_ALWAYS, "  exit_requested", exit_requested );
	dprintf( D_ALWAYS, "  image_size = %d blocks\n", image_size );

	dprintf( D_ALWAYS, "  user_time = %d\n", user_time );
	dprintf( D_ALWAYS, "  sys_time = %d\n", sys_time );

	dprintf( D_ALWAYS, "  guaranteed_user_time = %d\n", guaranteed_user_time );
	dprintf( D_ALWAYS, "  guaranteed_sys_time = %d\n", guaranteed_sys_time );

	dprintf( D_ALWAYS, "}\n" );

}


/*
  We have been given a filename describing where we should get our
  executable from.  That name could be of the form "<hostname>:<pathname>",
  or it could just be <pathname>.  Also the <pathname> part could contain
  macros to be looked up in our config file.  We do that macro expansion
  here, and also check the <hostname> part.  If the hostname refers
  to our own host, we set "on_this_host" to TRUE and if it refers to
  the submitting host, we set it to FALSE.  For now, it is an error
  if it refers to some third host.  We then ruturn a pointer to the
  macro expanded pathname in a static data area.

  The pathname could also be an AFS file, in which case we can also access
  the file with a symlink.  The form is "/afs/...".
*/
char *
UserProc::expand_exec_name( int &on_this_host )
{
	static char answer[ _POSIX_PATH_MAX ];
	char	*host_part;
	char	*path_part;
	char	*tmp;
	char	a_out[ _POSIX_PATH_MAX ];
	int		status;

	status = REMOTE_syscall( CONDOR_get_a_out_name, a_out );
	if( status < 0 ) {
		EXCEPT( "Can't get name of a.out file" );
	}
	if( strchr(a_out,':') ) {		// form is <hostname>:<path>
		host_part = strtok( a_out, " \t:" );
		if( host_part == NULL ) {
			EXCEPT( "Can't find host part" );
		}
		path_part = strtok( NULL, " \t:");
		if( path_part == NULL ) {
			EXCEPT( "Can't find path part" );
		}
		if( strcmp(host_part,ThisHost) == MATCH )  {
			on_this_host = TRUE;
		} else {
			if( strcmp(host_part,InitiatingHost) == MATCH ) {
				on_this_host = FALSE;
			} else {
				EXCEPT( "Unexpected host_part \"%s\", ThisHost %s", 
					   host_part, ThisHost );
			}
		}
	} else if( strncmp("/afs",a_out,4) == MATCH ) {
		on_this_host = TRUE;
		path_part = a_out;
	} else {	// form is <path>
		on_this_host = FALSE;
		path_part = a_out;
	}

		// expand macros in the pathname part
	tmp = macro_expand( path_part );
	strcpy( answer, tmp );
	FREE( tmp );
			

	if( on_this_host ) {
		if( access(answer,X_OK) == 0 ) {
			dprintf( D_ALWAYS, "Executable is located on this host\n" );
		} else {
			dprintf( D_ALWAYS,
				"Executable located on this host - but not executable\n"
			);
			on_this_host = FALSE;
		}
	} else {
		dprintf( D_ALWAYS, "Executable is located on submitting host\n" );
	}
	dprintf( D_ALWAYS, "Expanded executable name is \"%s\"\n", answer );
	return answer;
}

/*
  The executable file is on this host already, so just make a symbolic
  link to it.
*/
int
UserProc::link_to_executable( char *src, int & error_code )
{
	int status;

	errno = 0;
	status =  symlink( src, cur_ckpt );
	if( status < 0 ) {
		dprintf( D_ALWAYS,
			"Can't create sym link from \"%s\" to \"%s\", errno = %d\n",
			src, cur_ckpt, errno
		);
	} else {
		dprintf( D_ALWAYS,
			"Created sym link from \"%s\" to \"%s\"\n", src, cur_ckpt
		);
	}
	error_code = errno;
	return status;
}

/*
  The executable file is on the submitting host.  Transfer a copy
  to this machine.
*/
int
UserProc::transfer_executable( char *src, int &error_code )
{
	int		status;

	errno = 0;
	status = get_file( src, cur_ckpt, EXECUTABLE_FILE_MODE );

	if( status < 0 ) {
		dprintf( D_ALWAYS,
			"Failed to fetch orig ckpt file \"%s\" into \"%s\", errno = %d\n",
			src, cur_ckpt, errno
		);
	} else {
		dprintf( D_ALWAYS,
			"Fetched orig ckpt file \"%s\" into \"%s\"\n", src, cur_ckpt
		);
	}

	error_code = errno;
	return status;
}

/*
  Check to see if an executable file is properly linked for execution
  with the Condor remote system call library.
*/
int
UserProc::linked_for_condor()
{
	if( magic_check(cur_ckpt) < 0 ) {
		state = BAD_MAGIC;
		dprintf( D_ALWAYS, "magic_check() failed\n" );
		return FALSE;
	}

	// Don't look for symbol "MAIN" in vanilla jobs or PVM processes
	if( job_class != PVM && job_class != VANILLA ) {	
		if( symbol_main_check(cur_ckpt) < 0 ) {
			state = BAD_LINK;
			dprintf( D_ALWAYS, "symbol_main_check() failed\n" );
			return FALSE;
		}
	}

	dprintf( D_FULLDEBUG, "Done verifying executable file\n" );
	return TRUE;
}

int
UserProc::fetch_ckpt()
{
	int		on_this_host;
	char	*new_path;
	int		status;
	int		error_code;

	new_path = expand_exec_name( on_this_host );

	if( on_this_host ) {
		status = link_to_executable( new_path, error_code );
	} else {
		status = transfer_executable( new_path, error_code );
	}

	if( status < 0 ) {
		state = CANT_FETCH;
		exit_status = error_code;
		return FALSE;
	}

	switch( job_class ) {

	  case STANDARD:
	  case PIPE:
		if( linked_for_condor() ) {
			state = RUNNABLE;
			return TRUE;
		} else {
			return FALSE;
		}

	  case VANILLA:
	  case PVM:
	  case PVMD:
		state = RUNNABLE;
		return TRUE;

	  default:
		EXCEPT( "Unknown job class (%d)", job_class );
	}

	// We can never get here
	return FALSE;
}

#define MATCH 0			/* result of strcmp */
#define EQUAL '='		/* chars looked for during parsing */
#define SPACE ' '
#define TAB '\t'
#define SEMI ';'


void
UserProc::execute()
{
	int		argc;
	char	*argv[ 2048 ];
	char	**argp;
	char	**envp;
	sigset_t	sigmask;
	long	arg_max;
	char	*tmp;
	char	a_out_name[ _POSIX_PATH_MAX ];
	char	shortname[ _POSIX_PATH_MAX ];
	int		user_syscall_fd;
	const	int READ_END = 0;
	const	int WRITE_END = 1;
	const 	int USER_CMD_FD = 3;
	int		pipe_fds[2];
	FILE	*cmd_fp;
	char	buf[128];
	int		wait_for = TRUE;
	int		fd;

	pipe_fds[0] = -1;
	pipe_fds[1] = -1;

		// We will use mkargv() which modifies its arguments in place
		// so we not use the original copy of the arguments
	if( (arg_max=sysconf(_SC_ARG_MAX)) == -1 ) {
		arg_max = _POSIX_ARG_MAX;
	}
	tmp = new char [arg_max];
	strncpy( tmp, args, arg_max );

	sprintf( shortname, "condor_exec.%d.%d", cluster, proc );
	sprintf( a_out_name, "%s/%s/%s", Execute, local_dir, shortname );

		// Set up arg vector according to class of job
	switch( job_class ) {

	  case STANDARD:
	  case PIPE:
		if( pipe(pipe_fds) < 0 ) {
			EXCEPT( "pipe()" );}

			dprintf( D_ALWAYS, "Pipe built\n" );
		
			// The user process should not try to read commands from
			// 0, 1, or 2 since we'll be using the commands to redirect
			// those.
		if( pipe_fds[READ_END] < 14 ) {
			dup2( pipe_fds[READ_END], 14 );
			close( pipe_fds[READ_END] );
			pipe_fds[READ_END] = 14;
		}
		dprintf( D_ALWAYS, "New pipe_fds[%d,%d]\n", pipe_fds[0], pipe_fds[1] );
		sprintf( buf, "%d", pipe_fds[READ_END] );
		dprintf( D_ALWAYS, "cmd_fd = %s\n", buf );

		argv[0] = shortname;
		argv[1] = "-_condor_cmd_fd";
		argv[2] = buf;
		mkargv( &argc, &argv[3], tmp );
		break;

	  case PVM:
#if 1
		EXCEPT( "Don't know how to deal with PVM jobs" );
#else
		argv[0] = shortname;
		argv[1] = "-1";
		argv[2] = in;
		argv[3] = out;
		argv[4] = err;
		mkargv( &argc, &argv[5], tmp );
#endif
		break;

	  case VANILLA:
		argv[0] = shortname;
		mkargv( &argc, &argv[1], tmp );
		break;
	}

		// set up environment vector
	envp = env_obj.get_vector();

		// We may run more than one of these, so each needs its own
		// remote system call connection to the shadow
	if( job_class == PVM || job_class == PIPE ) {
		user_syscall_fd = NewConnection( v_pid );
	}

		// print out arguments to execve
	dprintf( D_ALWAYS, "Calling execve( \"%s\"", a_out_name );
	for( argp = argv; *argp; argp++ ) {							// argv
		dprintf( D_ALWAYS | D_NOHEADER, ", \"%s\"", *argp );
	}
	dprintf( D_ALWAYS | D_NOHEADER, ", 0" );
	for( argp = envp; *argp; argp++ ) {							// envp
		dprintf( D_ALWAYS | D_NOHEADER, ", \"%s\"", *argp );
	}
	dprintf( D_ALWAYS | D_NOHEADER, ", 0 )\n" );


	if( (pid = fork()) < 0 ) {
		EXCEPT( "fork" );
	}

	if( pid == 0 ) {	// the child

			// Block only these 3 signals which have special meaning for
			// checkpoint/restart purposes.  Leave other signals ublocked
			// so that if we get an exception during the restart process,
			// we will get a core file to debug.
		sigemptyset( &sigmask );
		// for some reason if we block these, the user process is unable
		// to unblock some or all of them.
#if 0
		sigaddset( &sigmask, SIGUSR1 );
		sigaddset( &sigmask, SIGUSR2 );
		sigaddset( &sigmask, SIGTSTP );
#endif
		sigprocmask( SIG_SETMASK, &sigmask, 0 );

			// renice
		renice_self( "JOB_RENICE_INCREMENT" );

			// child process should have only it's submitting uid, and cannot
			// switch back to root or some other uid.  
			// It'd be nice to check for errors here, but
			// unfortunately, we can't, since this only returns the
			// previous priv state, not whether it worked or not. 
			//  -Derek Wright 4/30/98
		set_user_priv_final();

		switch( job_class ) {
		  
		  case STANDARD:
			if( chdir(local_dir) < 0 ) {
				EXCEPT( "chdir(%s)", local_dir );
			}
			close( pipe_fds[WRITE_END] );
			break;

		  case PVM:
		  case PIPE:
			if( chdir(local_dir) < 0 ) {
				EXCEPT( "chdir(%s)", local_dir );
			}
			close( pipe_fds[WRITE_END] );
			dup2( user_syscall_fd, RSC_SOCK );
			break;

		  case VANILLA:
			set_iwd();
			open_std_file( 0 );
			open_std_file( 1 );
			open_std_file( 2 );

			(void)close( RSC_SOCK );
			(void)close( CLIENT_LOG );

			break;
		}

			// Make sure we're not root
		if( getuid() == 0 ) {
				// EXCEPT( "We're about to start as root, aborting." );
				// You can't see this error message at all.  So, just
				// exit(4), which is what EXCEPT normally gives. 
			exit( 4 );
		}

			// Everything's ready, start it up...
		errno = 0;
		execve( a_out_name, argv, envp );

			// A successful call to execve() never returns, so it is an
			// error if we get here.  A number of errors are possible
			// but the most likely is that there is insufficient swap
			// space to start the new process.  We don't try to log
			// anything, since we have the UID/GID of the job's owner
			// and cannot write into the log files...
		dprintf( D_ALWAYS, "Exec failed - errno = %d\n", errno );
		exit( EXECFAILED );
	}

		// The parent
	dprintf( D_ALWAYS, "Started user job - PID = %d\n", pid );
	if( job_class != VANILLA ) {
			// Send the user process its startup environment conditions
		close( pipe_fds[READ_END] );
		cmd_fp = fdopen( pipe_fds[WRITE_END], "w" );
		dprintf( D_ALWAYS, "cmd_fp = 0x%x\n", cmd_fp );

		if( is_restart() ) {
#if 1
			fprintf( cmd_fp, "restart\n" );
			dprintf( D_ALWAYS, "restart\n" );
#else
			fprintf( cmd_fp, "restart %s\n", target_ckpt );
			dprintf( D_ALWAYS, "restart %s\n", target_ckpt );
#endif
			fprintf( cmd_fp, "end\n" );
			dprintf( D_ALWAYS, "end\n" );
		} else {
			fprintf( cmd_fp, "end\n" );
			dprintf( D_ALWAYS, "end\n" );
		}
		fclose( cmd_fp );
	}

	delete [] tmp;
	state = EXECUTING;

	if ( job_class == VANILLA ) {
		family = new ProcFamily(pid,PRIV_USER);
		family->takesnapshot();
	}
}

// inline void
void
do_unlink( const char *name )
{
	while( unlink(name) < 0 ) {
		if( errno != ETXTBSY ) {
			dprintf( D_ALWAYS,
				"Can't unlink \"%s\" - errno = %d\n", name, errno
			);
			return;
		}
	}
	dprintf( D_ALWAYS, "Unlinked \"%s\"\n", name );
}


void
UserProc::delete_files()
{
	do_unlink( cur_ckpt );
	do_unlink( core_name );

	if( rmdir(local_dir) < 0 ) {
		dprintf( D_ALWAYS,
			"Can't remove directory \"%s\" - errno = %d\n", local_dir, errno
		);
	} else {
		dprintf( D_ALWAYS, "Removed directory \"%s\"\n", local_dir );
	}
}

void
UserProc::handle_termination( int exit_st )
{
	struct stat	buf;

	exit_status = exit_st;
	exit_status_valid = TRUE;
	accumulate_cpu_time();

	if( exit_requested && job_class == VANILLA ) { // job exited by request
		dprintf( D_ALWAYS, "Process exited by request\n" );
		state = NON_RUNNABLE;
	} else if( WIFEXITED(exit_status) ) { 
                                     // exited on own accord with some status
		dprintf( D_ALWAYS,
			"Process %d exited with status %d\n", pid, WEXITSTATUS(exit_status)
		);
		if( WEXITSTATUS(exit_status) == EXECFAILED ) {
			dprintf( D_ALWAYS,
				"EXEC of user process failed, probably insufficient swap\n"
			);
			state = NON_RUNNABLE;
		} else {
			state = NORMAL_EXIT;
			commit_cpu_time();
		}
	} else {
		dprintf( D_ALWAYS,
			"Process %d killed by signal %d\n", pid, WTERMSIG(exit_status)
		);
		switch( WTERMSIG(exit_status) ) {
		  case SIGUSR2:			// ckpt and vacate exit 
			dprintf( D_ALWAYS, "Process exited for checkpoint\n" );
			state = CHECKPOINTING;
			commit_cpu_time();
			break;
		  case SIGQUIT:			// exited for a checkpoint
			dprintf( D_ALWAYS, "Process exited for checkpoint\n" );
			state = CHECKPOINTING;
			/*
			  For bytestream checkpointing:  the only way the process exits
			  with signal SIGQUIT is if has transferred a checkpoint
			  successfully.
			*/
			ckpt_transferred = TRUE;
			break;
		  case SIGUSR1:
		  case SIGKILL:				// exited by request - no ckpt
			dprintf( D_ALWAYS, "Process exited by request\n" );
			state = NON_RUNNABLE;
			break;
		  default:					// exited abnormally due to signal
			dprintf( D_ALWAYS, "Process exited abnormally\n" );
			state = ABNORMAL_EXIT;
			commit_cpu_time();		// should this be here on ABNORMAL_EXIT ???? -Todd
		}
			
	}
	pid = 0;

	// the parent process exited; make certain kids are all gone as well
	if ( job_class == VANILLA ) {
		family->hardkill();
	}

	priv_state priv;

	switch( state ) {

	    case CHECKPOINTING:
			core_created = FALSE;
			ckpt_transferred = TRUE;
			break;

        case ABNORMAL_EXIT:
			priv = set_root_priv();	// need to be root to access core file
		    if( core_is_valid(core_name) ) {
				dprintf( D_ALWAYS, "A core file was created\n" );
				core_created = TRUE;
			} else {
				dprintf( D_FULLDEBUG, "No core file was created\n" );
				core_created = FALSE;
				(void)unlink( core_name );	// remove any incomplete core
			}
			set_priv(priv);
			break;

		default:
			dprintf( D_FULLDEBUG, "No core file was created\n" );
			core_created = FALSE;
			break;
	}

}

void
UserProc::send_sig( int sig )
{
    sigset_t    sigmask, oldmask;
    int         i;
	priv_state	priv;
 
	if( !pid ) {
		dprintf( D_FULLDEBUG,
		"UserProc::send_signal() called, but user job pid NULL\n" );
		return;
	}

//	priv = set_root_priv();

		// We don't want to be root going around killing things or we
		// might do something we'll regret in the morning. -Derek 8/29/97
	priv = set_user_priv();  

	if ( job_class == VANILLA ) {
		// Here we call killkids() to forward the signal to all of our
		// decendents, since a VANILLA job in condor can fork.  But first,
		// we block all of our async events, since killkids is relatively
		// slow, does popen and runs /bin/ps, etc.  Thus it is not re-enterant.
		// -Todd Tannenbaum, 5/9/95
		switch (sig) {
		case SIGTERM:
			family->softkill(sig);
			break;
		case SIGSTOP:
			family->suspend();
			break;
		case SIGCONT:
			family->resume();
			break;
		case SIGKILL:
			family->hardkill();
			break;
		default:
			if (kill(pid,SIGCONT) < 0) {
				EXCEPT( "kill(%d,SIGCONT)", pid );
			}
			if (kill(pid,sig) < 0) {
				EXCEPT( "kill(%d,%d)", pid, sig );
			}
		}
	}

	if ( job_class != VANILLA )
	if( sig != SIGCONT ) {
		if( kill(pid,SIGCONT) < 0 ) {
			set_priv(priv);
			if( errno == ESRCH ) {	// User proc already exited
				dprintf( D_ALWAYS, "Tried to send signal SIGCONT to user job "
						 "%d, but that process doesn't exist.\n", pid);
				return;
			}
			perror("kill");
			EXCEPT( "kill(%d,SIGCONT)", pid  );
		}
		dprintf( D_ALWAYS, "Sent signal SIGCONT to user job %d\n", pid);
	}

	if ( job_class != VANILLA )
	if( kill(pid,sig) < 0 ) {
		set_priv(priv);
		if( errno == ESRCH ) {	// User proc already exited
			dprintf( D_ALWAYS, "Tried to send signal %d to user job "
					 "%d, but that process doesn't exist.\n", sig, pid);
			return;
		}
		perror("kill");
		EXCEPT( "kill(%d,%d)", pid, sig );
	}

	set_priv(priv);

	if (SigNames.get_name(sig) != NULL)
		dprintf( D_ALWAYS, "Sent signal %s to user job %d\n",
				SigNames.get_name(sig), pid);
	else
		dprintf( D_ALWAYS, "Unknown signum %d sent to user job %d\n",
				sig, pid);
}



inline void
display_bool( int debug_flags, char *name, int value )
{
	dprintf( debug_flags, "%s = %s\n", name, value ? "TRUE" : "FALSE" );
}


/*
Look at the core file the previous checkpoint and try to guess how big
a new checkpoint file would be created from them.  Return the answer in
1024 byte units.
*/
#define SLOP 50
int
UserProc::estimate_image_size()
{
	int		answer;
	int		text_blocks;
	int		hdr_blocks;
	int		core_blocks;

	core_blocks = physical_file_size( core_name );
	text_blocks = calc_text_blocks( cur_ckpt );
	hdr_blocks = calc_hdr_blocks();

	answer = hdr_blocks + text_blocks + core_blocks + SLOP;

	dprintf( D_FULLDEBUG, "text: %d blocks\n", text_blocks );
	dprintf( D_FULLDEBUG, "core: %d blocks\n", core_blocks );
	dprintf( D_FULLDEBUG, "a.out hdr: %d blocks\n", hdr_blocks );
	dprintf( D_FULLDEBUG, "SLOP: %d blocks\n", SLOP );
	dprintf( D_FULLDEBUG, "Calculated image size: %dK\n", answer );

	return answer;

}

void
UserProc::store_core()
{
	int		core_size;
	char	virtual_working_dir[ _POSIX_PATH_MAX ];
	char	new_name[ _POSIX_PATH_MAX ];
	int		free_disk;
	priv_state	priv;

	if( !core_created ) {
		dprintf( D_ALWAYS, "No core file to send - probably ran out of disk\n");
		return;
	}

	priv = set_root_priv();
	core_size = physical_file_size( core_name );
	set_priv(priv);

	if( coredump_limit_exists ) {
		if( core_size > coredump_limit ) {
			dprintf( D_ALWAYS, "Core file size exceeds user defined limit\n" );
			dprintf( D_ALWAYS, "*NOT* sending core file.\n" );
			return;
		}
	}

	if( REMOTE_syscall(CONDOR_getwd,virtual_working_dir) < 0 ) {
		EXCEPT( "REMOTE_syscall(CONDOR_getwd)" );
	}

	free_disk = REMOTE_syscall( CONDOR_free_fs_blocks, virtual_working_dir);
	if( free_disk < 0 ) {
		EXCEPT( "REMOTE_syscall(CONDOR_free_fs_blocks)" );
	}

	dprintf( D_ALWAYS, "Core file size is %d kbytes\n", core_size );
	dprintf( D_ALWAYS, "Free disk on submitting machine is %d kbytes\n",
																free_disk );

	if( free_disk > core_size ) {
		sprintf( new_name, "%s/core.%d.%d", virtual_working_dir, cluster, proc);
		dprintf( D_ALWAYS, "Transferring core file to \"%s\"\n", new_name );
		delay( 15 );
		priv = set_root_priv();
		send_file( core_name, new_name, REGULAR_FILE_MODE );
		set_priv(priv);
		core_transferred = TRUE;
	} else {
		dprintf( D_ALWAYS, "*NOT* Transferring core file\n" );
		core_transferred = FALSE;
	}
}

void
UserProc::accumulate_cpu_time()
{
	struct tms	current;
	static struct tms	previous;

	(void)times( &current );
	user_time += current.tms_cutime - previous.tms_cutime;
	sys_time += current.tms_cstime - previous.tms_cstime;
	previous = current;
}

void
UserProc::commit_cpu_time()
{
	guaranteed_user_time = user_time;
	guaranteed_sys_time = sys_time;
}

void *
UserProc::accumulated_rusage()
{
	return bsd_rusage(user_time,sys_time);
}

void *
UserProc::guaranteed_rusage()
{
	return bsd_rusage(guaranteed_user_time, guaranteed_sys_time);
}

void *
UserProc::bsd_exit_status()
{
	return bsd_status( exit_status, state, ckpt_transferred, core_transferred );
}

void
UserProc::suspend()
{
	send_sig( SIGSTOP );
	state = SUSPENDED;
}

void
UserProc::resume()
{
	send_sig( SIGCONT );
	state = EXECUTING;
}

void
UserProc::request_ckpt()
{
	send_sig( SIGTSTP );
}

void
UserProc::request_periodic_ckpt()
{
	send_sig( SIGUSR2 );
}

void
UserProc::request_exit()
{
	exit_requested = TRUE;
	send_sig( soft_kill_sig );
}

void
UserProc::kill_forcibly()
{
	send_sig( SIGKILL );
}

void
UserProc::make_runnable()
{
	if( state != CHECKPOINTING ) {
		EXCEPT( "make_runnable() - state != CHECKPOINTING" );
	}
	state = RUNNABLE;
	restart = TRUE;
}

/*
  Create a new connection to the shadow using the existing remote
  system call stream.
*/
int
NewConnection( int id )
{
	int 	portno;
	int		syscall = CONDOR_new_connection;
	int		answer;

	SyscallStream->encode();

		// Send the request
	if( !SyscallStream->code(syscall) ) {
		EXCEPT( "Can't send CONDOR_new_connection request" );
	}
	if( !SyscallStream->code(id) ) {
		EXCEPT( "Can't send process id for CONDOR_new_connection request" );
	}

		// Turn the stream around
	SyscallStream->eom();
	SyscallStream->decode();

		// Read the port number
	if( !SyscallStream->code(portno) ) {
		EXCEPT( "Can't read port number for new connection" );
	}
	if( portno < 0 ) {
		SyscallStream->code( errno );
		EXCEPT( "Can't get port for new connection" );
	}
	SyscallStream->eom();

	answer = connect_to_port( portno );
	dprintf(D_FULLDEBUG, "New Socket: %d\n", answer);
	return answer;
}

/*
** Make a new TCP connection with the shadow on a given port number.  Return
** the new file descriptor.
*/
int
connect_to_port( int portnum )
{
	struct sockaddr_in		sin;
	int		fd;
	int		addr_len = sizeof(sin);

	if( getpeername(RSC_SOCK,(struct sockaddr *)&sin,&addr_len) < 0 ) {
		EXCEPT( "getpeername(%d,0x%x,0x%x)", RSC_SOCK, &sin, &addr_len);
	}

	if( (fd=socket(AF_INET,SOCK_STREAM,0)) < 0 ) {
		EXCEPT( "socket" );
	}

	sin.sin_port = htons( (u_short)portnum );

	if( connect(fd,(struct sockaddr *)&sin,addr_len) < 0 ) {
		EXCEPT( "connect(%d,0x%x,%d)", fd, &sin, addr_len );
	}
	return fd;
}


extern "C"
{
int
pre_open( int, int, int ) { return 0; }
}


/*
  Open a standard file (0, 1, or 2), given its fd number.
*/
void
open_std_file( int which )
{
	char	name[ _POSIX_PATH_MAX ];
	char	buf[ _POSIX_PATH_MAX + 50 ];
	int	answer;

	answer = REMOTE_syscall( CONDOR_get_std_file_info, which, name );
	if(!answer) {
		EXCEPT("Couldn't get info about standard files!");
	}

	switch( which ) {
		case 0:
			answer = open( name, O_RDONLY, 0 );
			break;
		case 1:
		case 2:
			answer = open( name, O_WRONLY, 0 );
			break;
	}

	if( answer < 0 ) {
		sprintf( buf, "Can't open \"%s\" - %s", name, strerror(errno) );
		REMOTE_syscall(CONDOR_report_error, buf );
		exit( 4 );
	} else {
		if( answer != which ) {
			dup2( answer, which );
		}
	}
}

UserProc::UserProc( STARTUP_INFO &s ) :
	cluster( s.cluster ),
	proc( s.proc ),
	uid( s.uid ),
	gid( s.gid ),
	v_pid( s.virt_pid ),
	pid( 0 ),
	exit_status_valid( FALSE ),
	exit_status( 0 ),
	soft_kill_sig( s.soft_kill_sig ),
	job_class( s.job_class ),
	ckpt_wanted( s.ckpt_wanted ),
	state( NEW ),
	new_ckpt_created( FALSE ),
	ckpt_transferred( FALSE ),
	core_created( FALSE ),
	core_transferred( FALSE ),
	exit_requested( FALSE ),
	image_size( -1 ),
	user_time( 0 ),
	sys_time( 0 ),
	guaranteed_user_time( 0 ),
	guaranteed_sys_time( 0 )
{
	char	buf[ _POSIX_PATH_MAX ];
	char	*value;
	mode_t 	omask;

	cmd = new char [ strlen(s.cmd) + 1 ];
	strcpy( cmd, s.cmd );

	args = new char [ strlen(s.args) + 1 ];
	strcpy( args, s.args );

	env = new char [ strlen(s.env) + 1 ];
	strcpy( env, s.env );

	env_obj.add_string( env );  // set up environment as an object


		// Generate a directory where process can run and do its checkpointing
	omask = umask(0);
	sprintf( buf, "dir_%d", getpid() );
	local_dir = new char [ strlen(buf) + 1 ];
	strcpy( local_dir, buf );
	if( mkdir(local_dir,LOCAL_DIR_MODE) < 0 ) {
		EXCEPT( "mkdir(%s,0%o)", local_dir, LOCAL_DIR_MODE );
	}
	(void)umask(omask);

	sprintf( buf, "%s/condor_exec.%d.%d", local_dir, cluster, proc );
	cur_ckpt = new char [ strlen(buf) + 1 ];
	strcpy( cur_ckpt, buf );

	sprintf( buf, "%s/core", local_dir );
	core_name = new char [ strlen(buf) + 1 ];
	strcpy( core_name, buf );

		// Find out if user wants checkpointing
#if defined(NO_CKPT)
	ckpt_wanted = FALSE;
	dprintf(D_ALWAYS,
			"This platform doesn't implement checkpointing yet\n"
	);
#else
	ckpt_wanted = s.ckpt_wanted;
#endif

	restart = s.is_restart;
	coredump_limit_exists = s.coredump_limit_exists;
	coredump_limit = s.coredump_limit;

	family = NULL;
}

void
set_iwd()
{
	char	iwd[ _POSIX_PATH_MAX ];
	char	buf[ _POSIX_PATH_MAX + 50 ];

	if( REMOTE_syscall(CONDOR_get_iwd,iwd) < 0 ) {
		REMOTE_syscall(
			CONDOR_report_error,
			"Can't determine initial working directory"
		);
		exit( 4 );
	}
	if( chdir(iwd) < 0 ) {

		int rval = -1;
		for (int count = 0; count < 360 && rval == -1 &&
				 (errno == ETIMEDOUT || errno == ENODEV); count++) {
			dprintf(D_ALWAYS, "Connection timed out on chdir(%s), trying again"
					" in 5 seconds\n", iwd);
			sleep(5);
			rval = chdir(iwd);
		}
		if (errno == ETIMEDOUT || errno == ENODEV) {
			EXCEPT("Connection timed out for 30 minutes on chdir(%s)", iwd);
		}
			
		sprintf( buf, "Can't open working directory \"%s\", errno = %d", iwd,
			    errno );
		REMOTE_syscall( CONDOR_report_error, buf );
		exit( 4 );
	}
}

extern "C"	int MappingFileDescriptors();

extern "C" int
MarkOpen( const char *file, int flags, int fd, int is_remote )
{
	if( MappingFileDescriptors() ) {
		EXCEPT( "MarkOpen() called, but should never be used!" );
	}
	return fd;
}
