/***************************Copyright-DO-NOT-REMOVE-THIS-LINE**
  *
  * Condor Software Copyright Notice
  * Copyright (C) 1990-2004, Condor Team, Computer Sciences Department,
  * University of Wisconsin-Madison, WI.
  *
  * This source code is covered by the Condor Public License, which can
  * be found in the accompanying LICENSE.TXT file, or online at
  * www.condorproject.org.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  * AND THE UNIVERSITY OF WISCONSIN-MADISON "AS IS" AND ANY EXPRESS OR
  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  * WARRANTIES OF MERCHANTABILITY, OF SATISFACTORY QUALITY, AND FITNESS
  * FOR A PARTICULAR PURPOSE OR USE ARE DISCLAIMED. THE COPYRIGHT
  * HOLDERS AND CONTRIBUTORS AND THE UNIVERSITY OF WISCONSIN-MADISON
  * MAKE NO MAKE NO REPRESENTATION THAT THE SOFTWARE, MODIFICATIONS,
  * ENHANCEMENTS OR DERIVATIVE WORKS THEREOF, WILL NOT INFRINGE ANY
  * PATENT, COPYRIGHT, TRADEMARK, TRADE SECRET OR OTHER PROPRIETARY
  * RIGHT.
  *
  ****************************Copyright-DO-NOT-REMOVE-THIS-LINE**/

#include "condor_common.h"
#include "shadow.h"
#include "../condor_daemon_core.V6/condor_daemon_core.h"
#include "condor_qmgr.h"         // need to talk to schedd's qmgr
#include "condor_attributes.h"   // for ATTR_ ClassAd stuff
#include "condor_email.h"        // for email.
#include "metric_units.h"

extern "C" char* d_format_time(double);

UniShadow::UniShadow() {
		// pass RemoteResource ourself, so it knows where to go if
		// it has to call something like shutDown().
	remRes = new RemoteResource( this );
}

UniShadow::~UniShadow() {
	if ( remRes ) delete remRes;
}


int
UniShadow::updateFromStarter(int command, Stream *s)
{
	ClassAd updateAd;
	ClassAd *jobad = getJobAd();
	char buf[300];
	int int_val;
	struct rusage rusage_val;
	
	// get info from the starter encapsulated in a ClassAd
	s->decode();
	if( ! updateAd.initFromStream(*s) ) {
		dprintf( D_ALWAYS, "ERROR in UniShadow::updateFromStarter:"
				 "Can't read ClassAd, aborting.\n" );
		return FALSE;
	}
	s->end_of_message();

	if ( !jobad ) {
		// should never really happen...
		return FALSE;
	}

	int prev_image = remRes->getImageSize();
	int prev_disk = remRes->getDiskUsage();
	struct rusage prev_rusage = remRes->getRUsage();

		// Stick everything we care about in our RemoteResource. 
	remRes->updateFromStarter( &updateAd );

		// Now, update our local copy of the job classad for
		// anything that's changed. 
	int_val = remRes->getImageSize();
	if( int_val > prev_image ) {
		sprintf( buf, "%s=%d", ATTR_IMAGE_SIZE, int_val );
		jobad->Insert( buf );

			// also update the User Log with an image size event
		JobImageSizeEvent event;
		event.size = int_val;
		if (!uLog.writeEvent (&event)) {
			dprintf( D_ALWAYS, "Unable to log ULOG_IMAGE_SIZE event\n" );
		}
	}

	int_val = remRes->getDiskUsage();
	if( int_val > prev_disk ) {
		sprintf( buf, "%s=%d", ATTR_DISK_USAGE, int_val );
		jobad->Insert( buf );
	}

	rusage_val = remRes->getRUsage();
	if( rusage_val.ru_stime.tv_sec > prev_rusage.ru_stime.tv_sec ) {
		sprintf( buf, "%s=%f", ATTR_JOB_REMOTE_SYS_CPU,
				 (float)rusage_val.ru_stime.tv_sec );
		jobad->Insert( buf );
	}
	if( rusage_val.ru_utime.tv_sec > prev_rusage.ru_utime.tv_sec ) {
		sprintf( buf, "%s=%f", ATTR_JOB_REMOTE_USER_CPU,
				 (float)rusage_val.ru_utime.tv_sec );
		jobad->Insert( buf );
	}

	return TRUE;
}



void
UniShadow::init( ClassAd* job_ad, const char* schedd_addr )
{
	if ( !job_ad ) {
		EXCEPT("No job_ad defined!");
	}

		// base init takes care of lots of stuff:
	baseInit( job_ad, schedd_addr );

		// we're only dealing with one host, so the rest is pretty
		// trivial.  we can just lookup everything we need in the job
		// ad, since it'll have the ClaimId, address (in the ClaimId)
		// startd's name (RemoteHost) and pool (RemotePool).
	remRes->setStartdInfo( jobAd );
	
		// In this case we just pass the pointer along...
	remRes->setJobAd( jobAd );
	
		// Register command which gets updates from the starter
		// on the job's image size, cpu usage, etc.  Each kind of
		// shadow implements it's own version of this to deal w/ it
		// properly depending on parallel vs. serial jobs, etc. 
	daemonCore->
		Register_Command( SHADOW_UPDATEINFO, "SHADOW_UPDATEINFO",
						  (CommandHandlercpp)&UniShadow::updateFromStarter, 
						  "UniShadow::updateFromStarter", this, DAEMON );

}


void
UniShadow::spawn( void )
{
	if( ! remRes->activateClaim() ) {
			// we're screwed, give up:
		shutDown( JOB_NOT_STARTED );
	}
}


void
UniShadow::reconnect( void )
{
	remRes->reconnect();
}


bool 
UniShadow::supportsReconnect( void )
{
		// For the UniShadow, the answer to this depends on our remote
		// starter.  If that supports it, so do we.  If not, we don't. 
	return remRes->supportsReconnect();
}


void
UniShadow::logExecuteEvent( void )
{
	ExecuteEvent event;
	char* sinful = event.executeHost;
	remRes->getStartdAddress( sinful );
	if( !uLog.writeEvent(&event) ) {
		dprintf( D_ALWAYS, "Unable to log ULOG_EXECUTE event: "
				 "can't write to UserLog!\n" );
	}
}


void
UniShadow::cleanUp( void )
{
		// Deactivate (fast) the claim
	if ( remRes ) {
		remRes->killStarter();
	}
}


void
UniShadow::gracefulShutDown( void )
{
		// Deactivate (gracefully) the claim
	if ( remRes ) {
		remRes->killStarter( true );
	}
}


int
UniShadow::getExitReason( void )
{
	if( remRes ) {
		return remRes->getExitReason();
	}
	return -1;
}


void
UniShadow::emailTerminateEvent( int exitReason )
{
	FILE* mailer;
	mailer = shutDownEmail( exitReason );
	if( ! mailer ) {
			// nothing to do
		return;
	}

		// gather all the info out of the job ad which we want to 
		// put into the email message.
	char JobName[_POSIX_PATH_MAX];
	JobName[0] = '\0';
	jobAd->LookupString( ATTR_JOB_CMD, JobName );

	char Args[_POSIX_ARG_MAX];
	Args[0] = '\0';
	jobAd->LookupString(ATTR_JOB_ARGUMENTS, Args);
	
	int had_core = FALSE;
	jobAd->LookupBool( ATTR_JOB_CORE_DUMPED, had_core );

	int q_date = 0;
	jobAd->LookupInteger(ATTR_Q_DATE,q_date);
	
	float remote_sys_cpu = 0.0;
	jobAd->LookupFloat(ATTR_JOB_REMOTE_SYS_CPU, remote_sys_cpu);
	
	float remote_user_cpu = 0.0;
	jobAd->LookupFloat(ATTR_JOB_REMOTE_USER_CPU, remote_user_cpu);
	
	int image_size = 0;
	jobAd->LookupInteger(ATTR_IMAGE_SIZE, image_size);
	
	int shadow_bday = 0;
	jobAd->LookupInteger( ATTR_SHADOW_BIRTHDATE, shadow_bday );
	
	float previous_runs = 0;
	jobAd->LookupFloat( ATTR_JOB_REMOTE_WALL_CLOCK, previous_runs );
	
	time_t arch_time=0;	/* time_t is 8 bytes some archs and 4 bytes on other
						   archs, and this means that doing a (time_t*)
						   cast on & of a 4 byte int makes my life hell.
						   So we fix it by assigning the time we want to
						   a real time_t variable, then using ctime()
						   to convert it to a string */
	
	time_t now = time(NULL);
	
	fprintf( mailer, "Your Condor job %d.%d \n",getCluster(),getProc());
	if ( JobName[0] ) {
		fprintf(mailer,"\t%s %s\n",JobName,Args);
	}
	
	fprintf(mailer,"has ");
	remRes->printExit( mailer );
	
	if( had_core ) {
		fprintf( mailer, "Core file is: %s\n", getCoreName() );
	}

	arch_time = q_date;
	fprintf(mailer, "\n\nSubmitted at:        %s", ctime(&arch_time));
	
	if( exitReason == JOB_EXITED || exitReason == JOB_COREDUMPED ) {
		double real_time = now - q_date;
		arch_time = now;
		fprintf(mailer, "Completed at:        %s", ctime(&arch_time));
		
		fprintf(mailer, "Real Time:           %s\n", 
				d_format_time(real_time));
	}	


	fprintf( mailer, "\n" );
	
	fprintf(mailer, "Virtual Image Size:  %d Kilobytes\n\n", image_size);
	
	double rutime = remote_user_cpu;
	double rstime = remote_sys_cpu;
	double trtime = rutime + rstime;
	double wall_time = now - shadow_bday;
	fprintf(mailer, "Statistics from last run:\n");
	fprintf(mailer, "Allocation/Run time:     %s\n",d_format_time(wall_time) );
	fprintf(mailer, "Remote User CPU Time:    %s\n", d_format_time(rutime) );
	fprintf(mailer, "Remote System CPU Time:  %s\n", d_format_time(rstime) );
	fprintf(mailer, "Total Remote CPU Time:   %s\n\n", d_format_time(trtime));
	
	double total_wall_time = previous_runs + wall_time;
	fprintf(mailer, "Statistics totaled from all runs:\n");
	fprintf(mailer, "Allocation/Run time:     %s\n",
			d_format_time(total_wall_time) );

		// TODO: deal w/ total bytes
	float network_bytes;
	network_bytes = bytesSent();
	fprintf(mailer, "\nNetwork:\n" );
	fprintf(mailer, "%10s Run Bytes Received By Job\n", 
			metric_units(network_bytes) );
	network_bytes = bytesReceived();
	fprintf(mailer, "%10s Run Bytes Sent By Job\n",
			metric_units(network_bytes) );

	email_close(mailer);
}

int UniShadow::handleJobRemoval(int sig) {
    dprintf ( D_FULLDEBUG, "In handleJobRemoval(), sig %d\n", sig );
	remRes->setExitReason( JOB_KILLED );
	remRes->killStarter();
		// more?
	return 0;
}


float
UniShadow::bytesSent()
{
	return remRes->bytesSent();
}


float
UniShadow::bytesReceived()
{
	return remRes->bytesReceived();
}


struct rusage
UniShadow::getRUsage( void ) 
{
	return remRes->getRUsage();
}


int
UniShadow::getImageSize( void )
{
	return remRes->getImageSize();
}


int
UniShadow::getDiskUsage( void )
{
	return remRes->getDiskUsage();
}


bool
UniShadow::exitedBySignal( void )
{
	return remRes->exitedBySignal();
}


int
UniShadow::exitSignal( void )
{
	return remRes->exitSignal();
}


int
UniShadow::exitCode( void )
{
	return remRes->exitCode();
}


void
UniShadow::resourceBeganExecution( RemoteResource* rr )
{
	ASSERT( rr == remRes );

		// We've only got one remote resource, so if it's started
		// executing, we can safely log our execute event
	logExecuteEvent();

		// Start the timer for the periodic user job policy  
	shadow_user_policy.startTimer();

		// Start the timer for updating the job queue for this job 
	startQueueUpdateTimer();
}


void
UniShadow::resourceReconnected( RemoteResource* rr )
{
	ASSERT( rr == remRes );

		// We've only got one remote resource, so if it successfully
		// reconnected, we can safely log our reconnect event
		// TODO!

		// Start the timer for the periodic user job policy  
	shadow_user_policy.startTimer();

		// Start the timer for updating the job queue for this job 
	startQueueUpdateTimer();
}


