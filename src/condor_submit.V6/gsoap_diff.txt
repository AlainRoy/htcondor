Only in j/scratch/ian/gsoap_extras: dom.o
Only in j/scratch/ian/gsoap_extras: how
diff -cr gsoap_extras/plugin/smdevp.C j/scratch/ian/gsoap_extras/plugin/smdevp.C
*** gsoap_extras/plugin/smdevp.C	Tue Aug 16 19:52:57 2005
--- j/scratch/ian/gsoap_extras/plugin/smdevp.C	Fri Feb 23 10:49:54 2007
***************
*** 389,395 ****
  */
  int
  soap_smd_final(struct soap *soap, struct soap_smd_data *data, char *buf, int *len)
! { int n = 0, err = 1;
    /* finalize the digest or signature computation */
    switch (data->alg)
    { case SOAP_SMD_DGST_MD5:
--- 389,395 ----
  */
  int
  soap_smd_final(struct soap *soap, struct soap_smd_data *data, char *buf, int *len)
! { unsigned int n = 0, err = 1;
    /* finalize the digest or signature computation */
    switch (data->alg)
    { case SOAP_SMD_DGST_MD5:
Only in j/scratch/ian/gsoap_extras/plugin: smdevp.o
diff -cr gsoap_extras/plugin/wsseapi.C j/scratch/ian/gsoap_extras/plugin/wsseapi.C
*** gsoap_extras/plugin/wsseapi.C	Fri Aug 19 09:41:29 2005
--- j/scratch/ian/gsoap_extras/plugin/wsseapi.C	Fri Feb 23 11:37:09 2007
***************
*** 918,924 ****
    { time_t now = time(NULL), expired;
      soap_s2dateTime(soap, timestamp->Expires, &expired);
      if (expired + SOAP_WSSE_CLKSKEW <= now)
!     { const char *code = soap_wsu__tTimestampFault2s(soap, 0);
        return soap_sender_fault_subcode(soap, code, "Message has expired", timestamp->Expires);
      }
    }
--- 918,924 ----
    { time_t now = time(NULL), expired;
      soap_s2dateTime(soap, timestamp->Expires, &expired);
      if (expired + SOAP_WSSE_CLKSKEW <= now)
!     { const char *code = soap_wsu__tTimestampFault2s(soap, (wsu__tTimestampFault)0);
        return soap_sender_fault_subcode(soap, code, "Message has expired", timestamp->Expires);
      }
    }
***************
*** 987,998 ****
    DBGFUN2("soap_wsse_add_UsernameTokenDigest", "id=%s", id?id:"", "username=%s", username?username:"");
    /* generate a nonce */
    calc_nonce(soap, nonce);
!   nonceBase64 = soap_s2base64(soap, nonce, NULL, SOAP_WSSE_NONCELEN);
    /* TODO: the specs are not clear: compute digest over binary nonce or base64 nonce?
    calc_digest(soap, created, nonce, SOAP_WSSE_NONCELEN, password, HA); */
    /* compute SHA1(created, nonce, password) */
    calc_digest(soap, created, nonceBase64, strlen(nonceBase64), password, HA);
!   soap_s2base64(soap, HA, HABase64, SOAP_SMD_SHA1_SIZE);
    /* populate the UsernameToken with digest */
    soap_wsse_add_UsernameTokenText(soap, id, username, HABase64);
    /* populate the remainder of the password, nonce, and created */
--- 987,998 ----
    DBGFUN2("soap_wsse_add_UsernameTokenDigest", "id=%s", id?id:"", "username=%s", username?username:"");
    /* generate a nonce */
    calc_nonce(soap, nonce);
!   nonceBase64 = soap_s2base64(soap, (const unsigned char *)nonce, NULL, SOAP_WSSE_NONCELEN);
    /* TODO: the specs are not clear: compute digest over binary nonce or base64 nonce?
    calc_digest(soap, created, nonce, SOAP_WSSE_NONCELEN, password, HA); */
    /* compute SHA1(created, nonce, password) */
    calc_digest(soap, created, nonceBase64, strlen(nonceBase64), password, HA);
!   soap_s2base64(soap, (const unsigned char *)HA, HABase64, SOAP_SMD_SHA1_SIZE);
    /* populate the UsernameToken with digest */
    soap_wsse_add_UsernameTokenText(soap, id, username, HABase64);
    /* populate the remainder of the password, nonce, and created */
***************
*** 1174,1180 ****
  soap_wsse_add_BinarySecurityTokenPEM(struct soap *soap, const char *id, const char *filename)
  { FILE *fd;
    DBGFUN2("soap_wsse_add_BinarySecurityTokenPEM", "id=%s", id?id:"", "filename=%s", filename?filename:"");
!   if ((fd = fopen(filename, "r")))
    { /* read the certificate */
      X509 *cert = PEM_read_X509(fd, NULL, NULL, NULL);
      fclose(fd);
--- 1174,1180 ----
  soap_wsse_add_BinarySecurityTokenPEM(struct soap *soap, const char *id, const char *filename)
  { FILE *fd;
    DBGFUN2("soap_wsse_add_BinarySecurityTokenPEM", "id=%s", id?id:"", "filename=%s", filename?filename:"");
!   if ((fd = safe_fopen_wrapper(filename, "r", NULL)))
    { /* read the certificate */
      X509 *cert = PEM_read_X509(fd, NULL, NULL, NULL);
      fclose(fd);
***************
*** 1406,1412 ****
    /* the DigestMethod algorithm is always SHA1 */
    reference->DigestMethod->Algorithm = (char*)ds_sha1URI;
    /* populate the DigestValue element */
!   reference->DigestValue = soap_s2base64(soap, HA, NULL, SOAP_SMD_SHA1_SIZE);
    /* add the fresh new reference to the array */
    signedInfo->Reference[signedInfo->__sizeReference] = reference;
    signedInfo->__sizeReference++;
--- 1406,1412 ----
    /* the DigestMethod algorithm is always SHA1 */
    reference->DigestMethod->Algorithm = (char*)ds_sha1URI;
    /* populate the DigestValue element */
!   reference->DigestValue = soap_s2base64(soap, (const unsigned char *)HA, NULL, SOAP_SMD_SHA1_SIZE);
    /* add the fresh new reference to the array */
    signedInfo->Reference[signedInfo->__sizeReference] = reference;
    signedInfo->__sizeReference++;
***************
*** 1551,1557 ****
    /* restore c14nexclude */
    soap->c14nexclude = c14nexclude;
    /* populate the SignatureValue element */
!   signature->SignatureValue = soap_s2base64(soap, sig, NULL, siglen);
    return SOAP_OK;
  }
  
--- 1551,1557 ----
    /* restore c14nexclude */
    soap->c14nexclude = c14nexclude;
    /* populate the SignatureValue element */
!   signature->SignatureValue = soap_s2base64(soap, (const unsigned char *)sig, NULL, siglen);
    return SOAP_OK;
  }
  
***************
*** 1693,1699 ****
  	  || strcmp(reference->Transforms->Transform[0].Algorithm, c14n_URI)))
            return soap_wsse_fault(soap, wsse__UnsupportedAlgorithm, reference->Transforms->Transform[0].Algorithm);
  	/* convert base64 digest to binary */
! 	soap_base642s(soap, reference->DigestValue, hash, SOAP_SMD_MAX_SIZE, NULL);
  	/* verify the digest of a locally signed element */
          if (soap_wsse_verify_digest(soap, alg, reference->URI + 1, hash))
  	  return soap->error;
--- 1693,1699 ----
  	  || strcmp(reference->Transforms->Transform[0].Algorithm, c14n_URI)))
            return soap_wsse_fault(soap, wsse__UnsupportedAlgorithm, reference->Transforms->Transform[0].Algorithm);
  	/* convert base64 digest to binary */
! 	soap_base642s(soap, reference->DigestValue, (char *)hash, SOAP_SMD_MAX_SIZE, NULL);
  	/* verify the digest of a locally signed element */
          if (soap_wsse_verify_digest(soap, alg, reference->URI + 1, hash))
  	  return soap->error;
***************
*** 1738,1744 ****
            /* compute digest */
  	  if (soap_smd_begin(soap, alg, NULL, 0)
  	   || soap_out_xsd__anyType(soap, NULL, 0, elt, NULL)
! 	   || soap_smd_end(soap, HA, &len))
              return soap_wsse_fault(soap, wsse__FailedCheck, "Could not compute digest");
  	  /* compare digests, success if identical */
  	  if (!memcmp(hash, HA, (size_t)len))
--- 1738,1744 ----
            /* compute digest */
  	  if (soap_smd_begin(soap, alg, NULL, 0)
  	   || soap_out_xsd__anyType(soap, NULL, 0, elt, NULL)
! 	   || soap_smd_end(soap, (char *)HA, &len))
              return soap_wsse_fault(soap, wsse__FailedCheck, "Could not compute digest");
  	  /* compare digests, success if identical */
  	  if (!memcmp(hash, HA, (size_t)len))
***************
*** 1968,1974 ****
     || !keyInfo->wsse__SecurityTokenReference
     || !keyInfo->wsse__SecurityTokenReference->KeyIdentifier)
      return NULL;
!   return soap_base642s(soap, keyInfo->wsse__SecurityTokenReference->KeyIdentifier->__item, NULL, 0, size);
  }
  
  /******************************************************************************\
--- 1968,1974 ----
     || !keyInfo->wsse__SecurityTokenReference
     || !keyInfo->wsse__SecurityTokenReference->KeyIdentifier)
      return NULL;
!   return (const unsigned char *)soap_base642s(soap, keyInfo->wsse__SecurityTokenReference->KeyIdentifier->__item, NULL, 0, size);
  }
  
  /******************************************************************************\
***************
*** 2492,2498 ****
      { soap_smd_update(soap, &data->digest->smd, buf, len);
        if (soap->level < data->digest->level)
        { soap->part = SOAP_END_SECURITY;
! 	soap_smd_final(soap, &data->digest->smd, data->digest->hash, NULL);
          data->digest->level = 0;
        }
      }
--- 2492,2498 ----
      { soap_smd_update(soap, &data->digest->smd, buf, len);
        if (soap->level < data->digest->level)
        { soap->part = SOAP_END_SECURITY;
! 	soap_smd_final(soap, &data->digest->smd, (char *)data->digest->hash, NULL);
          data->digest->level = 0;
        }
      }
***************
*** 2540,2546 ****
        return soap_set_receiver_error(soap, "wsse error", "Cannot use soap_wsse_sign with populated SignedInfo", SOAP_SSL_ERROR);
      /* add the SignedInfo/Reference elements for each digest */
      for (digest = data->digest; digest; digest = digest->next)
!       soap_wsse_add_SignedInfo_Reference(soap, digest->id, transform, "", digest->hash);
      /* then compute the signature and add it */
      soap_wsse_add_SignatureValue(soap, data->sign_alg, data->sign_key, data->sign_keylen);
      /* the code below ensures we increase the message length counter */
--- 2540,2546 ----
        return soap_set_receiver_error(soap, "wsse error", "Cannot use soap_wsse_sign with populated SignedInfo", SOAP_SSL_ERROR);
      /* add the SignedInfo/Reference elements for each digest */
      for (digest = data->digest; digest; digest = digest->next)
!       soap_wsse_add_SignedInfo_Reference(soap, digest->id, transform, "", (const char *)digest->hash);
      /* then compute the signature and add it */
      soap_wsse_add_SignatureValue(soap, data->sign_alg, data->sign_key, data->sign_keylen);
      /* the code below ensures we increase the message length counter */
Only in j/scratch/ian/gsoap_extras/plugin: wsseapi.o
Only in j/scratch/ian/gsoap_extras: stdsoap2.o
