/***************************Copyright-DO-NOT-REMOVE-THIS-LINE**
  *
  * Condor Software Copyright Notice
  * Copyright (C) 1990-2004, Condor Team, Computer Sciences Department,
  * University of Wisconsin-Madison, WI.
  *
  * This source code is covered by the Condor Public License, which can
  * be found in the accompanying LICENSE.TXT file, or online at
  * www.condorproject.org.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  * AND THE UNIVERSITY OF WISCONSIN-MADISON "AS IS" AND ANY EXPRESS OR
  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  * WARRANTIES OF MERCHANTABILITY, OF SATISFACTORY QUALITY, AND FITNESS
  * FOR A PARTICULAR PURPOSE OR USE ARE DISCLAIMED. THE COPYRIGHT
  * HOLDERS AND CONTRIBUTORS AND THE UNIVERSITY OF WISCONSIN-MADISON
  * MAKE NO MAKE NO REPRESENTATION THAT THE SOFTWARE, MODIFICATIONS,
  * ENHANCEMENTS OR DERIVATIVE WORKS THEREOF, WILL NOT INFRINGE ANY
  * PATENT, COPYRIGHT, TRADEMARK, TRADE SECRET OR OTHER PROPRIETARY
  * RIGHT.
  *
  ****************************Copyright-DO-NOT-REMOVE-THIS-LINE**/

#include "condor_common.h"
#include "condor_io.h"

#include "requestservice.h"
#include "../condor_schedd.V6/qmgmt_constants.h"
#include "classad_collection.h"

// for EvalBool
#include "../condor_includes/condor_classad_util.h"

#include "condor_attributes.h"

#define return_on_fail(x) if (!(x)) return FAILURE;

//! constructor
/*! \param DBConn DB connection string
 */
RequestService::RequestService(const char* DBConn) {
	jqSnapshot = new JobQueueSnapshot(DBConn);
}

//! destructor
RequestService::~RequestService() {
	jqSnapshot->release();
	delete jqSnapshot;
}

//! service requests from condor_q via socket
/*  NOTE:	
	Much of this method is borrowed from do_Q_request() in qmgmt.C
*/
QuillErrCode
RequestService::service(ReliSock *syscall_sock) {
  int request_num;
  QuillErrCode ret_st;
  int rval=0;

  syscall_sock->decode();
  
  return_on_fail(syscall_sock->code(request_num));
  
  dprintf(D_SYSCALLS, "Got request #%d\n", request_num);
  
  switch(request_num) {

  case CONDOR_InitializeReadOnlyConnection: {
		  //
		  // NOTE:
		  // I looked into qmgmt.C file.
		  // However, the below call doesn't do anything.
		  // So I just do nothing, here. 
		  // (By Youngsang)
		  //
		  /* ----- start of the original code 
			 
			  // same as InitializeConnection but no authenticate()
			  InitializeConnection(NULL, NULL);
			  
			  end of the original code ---- */
      return SUCCESS;
  }
  case CONDOR_CloseConnection: {
      int terrno;
      
      return_on_fail( syscall_sock->end_of_message() );;
      
      errno = 0;
      ret_st = closeConnection( );
      terrno = errno;
      dprintf( D_SYSCALLS, "\tret_st = %d, errno = %d\n", ret_st, terrno );
      
      syscall_sock->encode();
      return_on_fail( syscall_sock->code(rval) );
      if( rval < 0 ) {
		  return_on_fail( syscall_sock->code(terrno) );
      }
      return_on_fail( syscall_sock->end_of_message() );;
      
      return FAILURE;
  }
	  
  case CONDOR_GetNextJobByConstraint: {
	  char *constraint=NULL;
	  ClassAd *ad;
	  int initScan;
	  int terrno;
      
	  return_on_fail( syscall_sock->code(initScan) );
      
      if ( !(syscall_sock->code(constraint)) ) {
		  if (constraint != NULL) {
			  free(constraint);
			  constraint = NULL;
		  }
		  return FAILURE;
      }
      return_on_fail( syscall_sock->end_of_message() );
	  
      errno = 0;
	  
      ad = getNextJobByConstraint( constraint, initScan );
	  
      terrno = errno;
	  
      ret_st = ad ? SUCCESS : FAILURE;
      
      syscall_sock->encode();
      return_on_fail( syscall_sock->code(rval) );
      if( rval < 0 ) {
		  return_on_fail( syscall_sock->code(terrno) );
      }
      if( rval >= 0 ) {
		  return_on_fail( ad->put(*syscall_sock) );
      }
      freeJobAd(ad);
      free( (char *)constraint );
      return_on_fail( syscall_sock->end_of_message() );;
      
      return SUCCESS;
  } 
	  
  }
  
  return FAILURE;
}

/* parseConstraint takes a constraint string and gets the interesting
   parameters out of the string.  
   For example, a typical constraint string would look like 
              (ClusterId == 2 && ProcId == 4)
   In this case, we would set the cluster/proc return values to 2 and 4
   respectively.  Currently, due to schema constraints, the 'owner' 
   constraint cannot be pushed down to the DB and as such we don't get
   it out.  If the user issues condor_q with no constraints, the constraint
   string contains "TRUE" and so that case is handled too.
*/


bool
RequestService::parseConstraint(const char *constraint, 
				int &cluster, int &proc, char *owner) {
  char *ptrC, *ptrP, *ptrT;
  int index_rparen=0, length=0;
  bool isfullscan = false;
  char *temp_constraint = 
    (char *) malloc((strlen(constraint) + 1) * sizeof(char));
  temp_constraint = strcpy(temp_constraint, constraint);
  
  ptrC = strstr( temp_constraint, "ClusterId == ");
  if(ptrC != NULL) {
    index_rparen = strchr(ptrC, ')') - ptrC;
    ptrC += 13;
    sscanf(ptrC, "%d", &cluster);
    ptrC -= 13;
    for(int i=0; i < index_rparen; i++) ptrC[i] = ' ';
  }
  ptrP = strstr( temp_constraint, "ProcId == ");
  if(ptrP != NULL) {
    index_rparen = strchr(ptrP, ')') - ptrP;
    ptrP += 10;
    sscanf(ptrP, "%d", &proc);
    ptrP -= 10;
    for(int i=0; i < index_rparen; i++) ptrP[i] = ' ';
  }
  
  /* turns out that since we have a vertical schema, we can only
     push the cluster,proc constraint down to SQL.  The owner would
     be a vertical attribute and can't be pushed down.  But I'm keeping
	 the code in here in case we want to change the schema to a hybrid
	 schema (part horizontal, part vertical) just like the historical 
	 schema

	 ptrO = strstr( temp_constraint, "TARGET.Owner == ");
	 if(ptrO != NULL) {
	 index_rparen = strchr(ptrO, ')') - ptrO;
	 ptrO += 17;
	 sscanf(ptrO, "%s", owner);
	 ptrO -= 17;
	 for(int i=0; i < index_rparen; i++) ptrO[i] = ' ';
	 index_equals = strchr(owner, '"') - owner;
    owner[index_equals] = '\0';
	}
  */
  
  ptrT = strstr( temp_constraint, "TRUE");
  if(ptrT != NULL) {
	  for(int i=0; i < 4; i++) ptrT[i] = ' ';
  }
    
  length = strlen(temp_constraint);
  for(int i=0; i < length; i++) {
    if(isalnum(temp_constraint[i])) {
      isfullscan = true;
      break;
    }
  }
  
  free(temp_constraint);
  return isfullscan;
}

//! handle GetNextJobByConstraint request 
/*! \param constraint query 
 *	\param initScan is it the first call?
 */
ClassAd*
RequestService::getNextJobByConstraint(const char* constraint, int initScan)
{
	ClassAd *ad;

	bool isfullscan = false;
	int cluster=-1, proc=-1;
	char owner[20] = "";

	if (initScan) { // is it the first request?
	  isfullscan = parseConstraint(constraint, cluster, proc, owner);

	  if (jqSnapshot->startIterateAllClassAds(cluster, 
						  proc, 
						  owner, 
						  isfullscan) <= 0)
		  return NULL;
	  
	}



	while(jqSnapshot->iterateAllClassAds(ad)) {

		if (!constraint || !constraint[0] || EvalBool(ad, constraint)) {
			return ad;		      
		}
		
		freeJobAd(ad);
	}

	return NULL;
}


void
RequestService::freeJobAd(ClassAd*& ad) 
{
	if (ad != NULL) {
	  ad->clear();
	  delete ad;
	}
	ad = NULL;
}

/*
	Not doing much here
*/
QuillErrCode
RequestService::closeConnection()
{
    return SUCCESS;
}
