/***************************Copyright-DO-NOT-REMOVE-THIS-LINE**
 * CONDOR Copyright Notice
 *
 * See LICENSE.TXT for additional notices and disclaimers.
 *
 * Copyright (c)1990-1998 CONDOR Team, Computer Sciences Department, 
 * University of Wisconsin-Madison, Madison, WI.  All Rights Reserved.  
 * No use of the CONDOR Software Program Source Code is authorized 
 * without the express consent of the CONDOR Team.  For more information 
 * contact: CONDOR Team, Attention: Professor Miron Livny, 
 * 7367 Computer Sciences, 1210 W. Dayton St., Madison, WI 53706-1685, 
 * (608) 262-0856 or miron@cs.wisc.edu.
 *
 * U.S. Government Rights Restrictions: Use, duplication, or disclosure 
 * by the U.S. Government is subject to restrictions as set forth in 
 * subparagraph (c)(1)(ii) of The Rights in Technical Data and Computer 
 * Software clause at DFARS 252.227-7013 or subparagraphs (c)(1) and 
 * (2) of Commercial Computer Software-Restricted Rights at 48 CFR 
 * 52.227-19, as applicable, CONDOR Team, Attention: Professor Miron 
 * Livny, 7367 Computer Sciences, 1210 W. Dayton St., Madison, 
 * WI 53706-1685, (608) 262-0856 or miron@cs.wisc.edu.
****************************Copyright-DO-NOT-REMOVE-THIS-LINE**/

#include "condor_common.h"
#include "condor_debug.h"
#include "condor_config.h"
#include "../condor_daemon_core.V6/condor_daemon_core.h"
#include "globus_utils.h"
#include "get_port_range.h"
#include "MyString.h"
#include "util_lib_proto.h"
#include "gahp-client.h"
#include "gridmanager.h"

	// Initialize static data members
GahpServer *GahpServer::main_gahp_server = NULL;


#ifndef WIN32
	// Explicit template instantiation.  Sigh.
	template class HashTable<int,GahpClient*>;
	template class ExtArray<Gahp_Args*>;
	template class Queue<int>;
template class HashTable<HashKey, GahpServer *>;
template class HashBucket<HashKey, GahpServer *>;
template class HashTable<HashKey, GahpProxyInfo *>;
template class HashBucket<HashKey, GahpProxyInfo *>;
#endif	

#define NULLSTRING "NULL"
#define GAHP_PREFIX "GAHP:"
#define GAHP_PREFIX_LEN 5

#define HASH_TABLE_SIZE			50

HashTable <HashKey, GahpServer *>
    GahpServer::GahpServersById( HASH_TABLE_SIZE,
								 hashFunction );

const char *escapeGahpString(const char * input);

GahpServer *GahpServer::FindOrCreateGahpServer(const char *id, const char *path)
{
	int rc;
	GahpServer *server = NULL;

	if ( path == NULL ) {
		path = "DEFAULT";
	}

	rc = GahpServersById.lookup( HashKey( id ), server );
	if ( rc != 0 ) {
		server = new GahpServer( id, path );
		ASSERT(server);
		GahpServersById.insert( HashKey( id ), server );
	} else {
		ASSERT(server);
	}

	return server;
}

GahpServer::GahpServer(const char *id, const char *path)
{
	m_gahp_pid = -1;
	m_reaperid = -1;
	m_gahp_readfd = -1;
	m_gahp_writefd = -1;
	m_reference_count = 0;
	m_commands_supported = NULL;
	m_pollInterval = 5;
	poll_tid = -1;
	max_pending_requests = 50;
	num_pending_requests = 0;
	globus_gt2_gram_user_callback_arg = NULL;
	globus_gt2_gram_callback_func = NULL;
	globus_gt2_gram_callback_reqid = 0;
	poll_pending = false;
	use_prefix = false;
	requestTable = NULL;
	current_cache_id = GAHPCLIENT_CACHE_DEFAULT_PROXY;
	skip_next_r = false;

	requestTable = new HashTable<int,GahpClient*>( 300, &hashFuncInt );
	ASSERT(requestTable);

	globus_gass_server_url = NULL;
	globus_gt2_gram_callback_contact = NULL;

	my_id = strdup(id);
	binary_path = strdup(path);
	proxy_check_tid = TIMER_UNSET;
	master_proxy = NULL;
	is_initialized = false;
	ProxiesByFilename = NULL;
}

GahpServer::~GahpServer()
{
	if ( globus_gass_server_url != NULL ) {
		free( globus_gass_server_url );
	}
	if ( globus_gt2_gram_callback_contact != NULL ) {
		free( globus_gt2_gram_callback_contact );
	}
	if ( my_id != NULL ) {
		free(my_id);
	}
	if ( binary_path != NULL ) {
		free(binary_path);
	}
	if ( master_proxy != NULL ) {
		ReleaseProxy( master_proxy->proxy );
		delete master_proxy;
	}
	if ( proxy_check_tid != TIMER_UNSET ) {
		daemonCore->Cancel_Timer( proxy_check_tid );
	}
	if ( ProxiesByFilename != NULL ) {
		GahpProxyInfo *gahp_proxy;

		ProxiesByFilename->startIterations();
		while ( ProxiesByFilename->iterate( gahp_proxy ) != 0 ) {
			ReleaseProxy( gahp_proxy->proxy );
			delete gahp_proxy;
		}

		delete ProxiesByFilename;
	}
}

void
GahpServer::write_line(const char *command)
{
dprintf(D_FULLDEBUG,"GAHP <- '%s'\n", command );
	if ( !command || m_gahp_writefd == -1 ) {
		return;
	}
	
	write(m_gahp_writefd,command,strlen(command));
	write(m_gahp_writefd,"\r\n",2);

	return;
}

void
GahpServer::write_line(const char *command, int req, const char *args)
{
	if ( !command || m_gahp_writefd == -1 ) {
		return;
	}

	char buf[20];
	sprintf(buf," %d ",req);
	write(m_gahp_writefd,command,strlen(command));
	write(m_gahp_writefd,buf,strlen(buf));
	if ( args ) {
		write(m_gahp_writefd,args,strlen(args));
dprintf(D_FULLDEBUG,"GAHP <- '%s%s%s'\n", command, buf, args );
}else{dprintf(D_FULLDEBUG,"GAHP <- '%s%s'\n", command, buf );
	}
	write(m_gahp_writefd,"\r\n",2);

	return;
}

void
GahpServer::Reaper(Service*,int pid,int status)
{
	/* This should be much better.... for now, if our Gahp Server
	   goes away for any reason, we EXCEPT. */

	char buf2[800];

	if( WIFSIGNALED(status) ) {
		sprintf( buf2, "died due to %s", 
			daemonCore->GetExceptionString(status) );
	} else {
		sprintf( buf2, "exited with status %d", WEXITSTATUS(status) );
	}

	EXCEPT("Gahp Server (pid=%d) %s\n",pid,buf2);
}


GahpClient::GahpClient(const char *id, const char *path)
{
	server = GahpServer::FindOrCreateGahpServer(id,path);
	m_timeout = 0;
	m_mode = normal;
	server->m_reference_count++;
	pending_command[0] = '\0';
	pending_args = NULL;
	pending_reqid = 0;
	pending_result = NULL;
	pending_timeout = 0;
	pending_timeout_tid = -1;
	pending_submitted_to_gahp = false;
	pending_cache_id = GAHPCLIENT_CACHE_DEFAULT_PROXY;
	user_timerid = -1;
	normal_proxy_cache_id = GAHPCLIENT_CACHE_LAST_PROXY;
	deleg_proxy_cache_id = GAHPCLIENT_CACHE_DEFAULT_PROXY;
}

GahpClient::~GahpClient()
{
		// call clear_pending to remove this object from hash table,
		// and deallocate any memory associated w/ a pending command.
	clear_pending();
	server->m_reference_count--;
	if ( server->m_reference_count == 0 ) {
		// all objects are gone - remove request table
		if (server->requestTable) delete server->requestTable;
		server->requestTable = NULL;
		// TODO someday --- perhaps send a QUIT to the Gahp Server?
	}
}


Gahp_Buf::Gahp_Buf(int size)
{
	buffer = (char *)malloc(size);
	ASSERT(buffer);
}

Gahp_Buf::~Gahp_Buf()
{
	free(buffer);
}

Gahp_Args::Gahp_Args()
{
	argv = NULL;
	argc = 0;
}

Gahp_Args::~Gahp_Args()
{
	free_argv();
}
	
void
Gahp_Args::free_argv()
{
	int i=0;

	if (argv == NULL ) {
		return;
	}
			
	while ( argv[i] ) {
		free(argv[i]);
		i++;
	}
	free(argv);
	argv = NULL;
	argc = 0;
	return;
}
	

char **
GahpServer::read_argv(Gahp_Args &g_args)
{
	static char* buf = NULL;
	int ibuf = 0;
	int iargv = 0;
	int result = 0;
	bool trash_this_line;
	static const int buf_size = 1024 * 500;
	static const int argv_size = 60;

	g_args.free_argv();
	g_args.argv = (char**)calloc(argv_size, sizeof(char*));

	if ( m_gahp_readfd == -1 ) {
dprintf(D_FULLDEBUG,"GAHP -> (no pipe)\n");
		return g_args.argv;
	}

	if ( buf == NULL ) {
		buf = (char*)malloc(buf_size);
	}

	ibuf = 0;
	iargv = 0;

	for (;;) {

		ASSERT(ibuf < buf_size);
		result = read(m_gahp_readfd, &(buf[ibuf]), 1 );

		/* Check return value from read() */
		if ( result < 0 ) {		/* Error - try reading again */
			continue;
		}
		if ( result == 0 ) {	/* End of File */
			int i;
				// clear out all entries
			for (i=0;g_args.argv[i];i++) {
				free(g_args.argv[i]);
				g_args.argv[i] = NULL;
			}
			g_args.argc = 0;
dprintf(D_FULLDEBUG,"GAHP -> EOF\n");
			return g_args.argv;
		}

		/* Check if character read was whitespace */
		if ( buf[ibuf]==' ' || buf[ibuf]=='\t' || buf[ibuf]=='\r' ) {
			/* Ignore leading whitespace */
			if ( ibuf == 0 ) {	
				continue;
			}
			/* Handle Transparency: if char is '\' followed by a space,
			 * it should be considered a space and not as a seperator
			 * between arguments. */
			if ( buf[ibuf]==' ' && buf[ibuf-1]=='\\' ) {
				buf[ibuf-1] = ' ';
				continue;
			}
			/* Trailing whitespace delimits a parameter to copy into argv */
			buf[ibuf] = '\0';
			g_args.argv[iargv] = (char*)malloc(ibuf + 5);
			strcpy(g_args.argv[iargv],buf);
			ibuf = 0;
			iargv++;
			ASSERT(iargv < argv_size);
			continue;
		}

		/* If character was a newline, copy into argv and return */
		if ( buf[ibuf]=='\n' ) { 
			if ( ibuf > 0 ) {
				buf[ibuf] = '\0';
				g_args.argv[iargv] = (char*)malloc(ibuf + 5);
				strcpy(g_args.argv[iargv],buf);
			}
			g_args.argc = iargv + 1;

			// We are all done and about to return.  But first,
			// check for our prefix if using one.
			trash_this_line = false;
			if ( use_prefix ) {
				if ( g_args.argv[0] && 
					 strncmp(GAHP_PREFIX,g_args.argv[0],GAHP_PREFIX_LEN)==0)
				{
					// Prefix is good.
					// Fixup argv[0] so prefix is transparent.
					memmove(g_args.argv[0],&(g_args.argv[0][GAHP_PREFIX_LEN]),
							1 + strlen(&(g_args.argv[0][GAHP_PREFIX_LEN])));
				} else {
					// Prefix is bad.
					trash_this_line = true;
				}
			}

			// check for a single "R".  This means we should check
			// for results in gahp async mode.  
			if ( trash_this_line==false && g_args.argv[0] &&
				 g_args.argv[0][0] == 'R' ) {
				if ( skip_next_r ) {
					// we should not poll this time --- apparently we saw
					// this R come through via our pipe handler.
					skip_next_r = false;
				} else {
					poll_real_soon();
				}
					// ignore anything else on this line & read again
				trash_this_line = true;
			}

			if ( trash_this_line ) {
				// reset all our buffers and read the next line
				g_args.free_argv();
				g_args.argv = (char**)calloc(argv_size, sizeof(char*));
				ibuf = 0;
				iargv = 0;
				continue;	// go back to the top of the for loop
			}

buf[0]='\0';
if(g_args.argc>0){
strcat(buf,"'");
for(int i=0;i<g_args.argc;i++){
if(i!=0)strcat(buf,"' '");
if(g_args.argv[i])strcat(buf,g_args.argv[i]);
}
strcat(buf,"'");
}
dprintf(D_FULLDEBUG,"GAHP -> %s\n",buf);
			return g_args.argv;
		}

		/* Character read was just a regular one.. increment index
		 * and loop back up to read the next character */
		ibuf++;

	}	/* end of infinite for loop */
}

int
GahpClient::new_reqid()
{
	static int next_reqid = 1;
	static bool had_to_rotate = false;
	int starting_reqid;
	GahpClient* unused;

	starting_reqid  = next_reqid;
	
	next_reqid++;
	while (starting_reqid != next_reqid) {
		if ( next_reqid > 990000000 ) {
			next_reqid = 1;
			had_to_rotate = true;
		}
			// Make certain this reqid is not already in use.
			// Optimization: only need to do the lookup if we have
			// rotated request ids...
		if ( (!had_to_rotate) || 
			 (server->requestTable->lookup(next_reqid,unused) == -1) ) {
				// not in use, we are done
			return next_reqid;
		}
		next_reqid++;
	}

		// If we made it here, we are out of request ids
	EXCEPT("GAHP client - out of request ids !!!?!?!?");
	
	return -1;  // just to make C++ not give a warning...
}

bool
GahpClient::Startup()
{
	return server->Startup();
}

bool
GahpServer::Startup()
{
	char *gahp_path = NULL;
	char *gahp_args = NULL;
	int stdin_pipefds[2];
	int stdout_pipefds[2];
	int low_port;
	int high_port;
	char *newenv = NULL;

		// Check if we already have spawned a GAHP server.  
	if ( m_gahp_pid != -1 ) {
			// GAHP already running...
		return true;
	}

		// No GAHP server is running yet, so we need to start one up.
		// First, get path to the GAHP server.
	if ( binary_path && strcmp( binary_path, GAHPCLIENT_DEFAULT_PATH ) != 0 ) {
		gahp_path = strdup(binary_path);
	} else {
		gahp_path = param("GAHP");
		gahp_args = param("GAHP_ARGS");
	}

	if (!gahp_path) return false;

	if ( get_port_range( &low_port, &high_port ) == TRUE ) {
		newenv = (char *)malloc( 64 );
		snprintf( newenv, 64, "GLOBUS_TCP_PORT_RANGE=%d,%d", low_port,
				  high_port );
	}

		// Now register a reaper, if we haven't already done so.
		// Note we use ReaperHandler instead of ReaperHandlercpp
		// for the callback prototype, because our handler is 
		// a static method.
	if ( m_reaperid == -1 ) {
		m_reaperid = daemonCore->Register_Reaper(
				"GAHP Server",					
				(ReaperHandlercpp)&GahpServer::Reaper,	// handler
				"GahpServer::Reaper",
				this
				);
	}

		// Create two pairs of pipes which we will use to 
		// communicate with the GAHP server.
	if ( (daemonCore->Create_Pipe(stdin_pipefds) == FALSE) ||
		 (daemonCore->Create_Pipe(stdout_pipefds) == FALSE) ) 
	{
		dprintf(D_ALWAYS,"GahpClient::Initialize - pipe() failed, errno=%d\n",
			errno);
		free( gahp_path );
		if (gahp_args) free(gahp_args);
		if (newenv) free(newenv);
		return false;
	}

	int io_redirect[3];
	io_redirect[0] = stdin_pipefds[0];	// stdin gets read side of in pipe
	io_redirect[1] = stdout_pipefds[1]; // stdout get write side of out pipe
	io_redirect[2] = -1;				// stderr we don't care about

	// we don't care about stderr - on UNIX, set it to /dev/null. On Windows,
	// leave it set to -1
#ifndef WIN32
	if ((io_redirect[2]=open("/dev/null",
								O_WRONLY|O_CREAT|O_TRUNC,0666)) < 0 ) {
		// if failed, try again without O_TRUNC
		if ( (io_redirect[2]=open( "/dev/null", 
									O_WRONLY | O_CREAT, 0666)) < 0 ) {
			dprintf(D_ALWAYS,
				"failed to open stderr file /dev/null, errno %d\n", errno);
		}
	}
#endif

	m_gahp_pid = daemonCore->Create_Process(
			gahp_path,		// Name of executable
			gahp_args,		// Args
			PRIV_UNKNOWN,	// Priv State ---- keep the same 
			m_reaperid,		// id for our registered reaper
			FALSE,			// do not want a command port
			newenv,			// env
			NULL,			// cwd
			FALSE,			// new process group?
			NULL,			// network sockets to inherit
			io_redirect 	// redirect stdin/out/err
			);

	if ( m_gahp_pid == FALSE ) {
		dprintf(D_ALWAYS,"Failed to start GAHP server (%s)\n",
				gahp_path);
		free( gahp_path );
		if (gahp_args) free(gahp_args);
		if (newenv) free(newenv);
		m_gahp_pid = -1;
		return false;
	} else {
		dprintf(D_ALWAYS,"GAHP server pid = %d\n",m_gahp_pid);
	}

	free( gahp_path );
	if (gahp_args) free(gahp_args);
	if (newenv) free(newenv);

		// Now that the GAHP server is running, close the sides of
		// the pipes we gave away to the server, and stash the ones
		// we want to keep in an object data member.
	daemonCore->Close_Pipe( io_redirect[0] );
	daemonCore->Close_Pipe( io_redirect[1] );
	if( io_redirect[2] > -1 ) {
		close(io_redirect[2]);
	}
	m_gahp_readfd = stdout_pipefds[0];
	m_gahp_writefd = stdin_pipefds[1];

		// Read in the initial greeting from the GAHP, which is the version.
	if ( command_version(true) == false ) {
		dprintf(D_ALWAYS,"Failed to read GAHP server version\n");
		// consider this a bad situation...
		return false;
	} else {
		dprintf(D_FULLDEBUG,"GAHP server version: %s\n",m_gahp_version);
	}

		// Now see what commands this server supports.
	if ( command_commands() == false ) {
		return false;
	}

		// Try and use a reponse prefix, to shield against
		// errors which could arise if the Globus libraries
		// linked with the GAHP server spit out crap to stdout.
	use_prefix = command_response_prefix( GAHP_PREFIX );

		// try to turn on gahp async notification mode
	if  ( !command_async_mode_on() ) {
		// not supported, set a poll interval
		setPollInterval(m_pollInterval);
	} else {
		// command worked... register the pipe and stop polling
		int result = daemonCore->Register_Pipe(m_gahp_readfd,
			"m_gahp_readfd",(PipeHandlercpp)&GahpServer::pipe_ready,
			"&GahpServer::pipe_ready",this);
		if ( result == -1 ) {
			// failed to register the pipe for some reason; fall 
			// back on polling (yuck).
			setPollInterval(m_pollInterval);
		} else {
			// pipe all registered.  stop polling.
//			setPollInterval(0);
		        // temporary kludge to work around gahp server hanging
		        setPollInterval(m_pollInterval * 12);
		}
	}
		
	return true;
}

bool
GahpClient::Initialize(const char *proxy_path)
{
	return server->Initialize(proxy_path);
}

bool
GahpServer::Initialize(const char *proxy_path)
{
	int rc;

		// Check if Initialize() has already been successfully called
	if ( is_initialized == true ) {
		return true;
	}

		// Check if we already have spawned a GAHP server.  
	if ( m_gahp_pid == -1 ) {
			// GAHP not running, start it up
		if ( Startup() == false ) {
			return false;
		}
	}

	ProxiesByFilename = new HashTable<HashKey,GahpProxyInfo*>( 500,
															   &hashFunction );
	ASSERT(ProxiesByFilename);

	MyString filename;
	filename.sprintf( "%s/master_proxy.%p", GridmanagerScratchDir, this );

	rc = copy_file( proxy_path, filename.Value() );
	if ( rc != 0 ) {
			// bad stuff!
		EXCEPT( "copy_file() failed!\n" );
	}

	proxy_check_tid = daemonCore->Register_Timer( TIMER_NEVER,
								(TimerHandlercpp)&GahpServer::doProxyCheck,
								"GahpServer::doProxyCheck", (Service*) this );
	master_proxy = new GahpProxyInfo;
	master_proxy->proxy = AcquireProxy( filename.Value(), proxy_check_tid );
	master_proxy->cached_expiration = 0;

		// Give the server our x509 proxy.
	if ( command_initialize_from_file(filename.Value()) == false ) {
		EXCEPT( "Failed to initialize from file" );
	}

	if ( cacheProxyFromFile( master_proxy->proxy->gahp_proxy_id,
							 master_proxy->proxy->proxy_filename ) == false ) {
		EXCEPT( "Failed to cache proxy from file!" );
	}

	master_proxy->cached_expiration = master_proxy->proxy->expiration_time;

	is_initialized = true;

	return true;
}

bool
GahpServer::cacheProxyFromFile( int id, const char *proxy_path )
{
	static const char *command = "CACHE_PROXY_FROM_FILE";

	ASSERT(proxy_path);		// Gotta have it...

		// Check if this command is supported
	if  (m_commands_supported->contains_anycase(command)==FALSE) {
		return false;
	}

	char buf[_POSIX_PATH_MAX];
	int x = snprintf(buf,sizeof(buf),"%s %d %s",command,id,
					 escapeGahpString(proxy_path));
	ASSERT( x > 0 && x < (int)sizeof(buf) );
	write_line(buf);
	Gahp_Args result;
	char **argv = read_argv(result);
	if ( argv[0] == NULL || argv[0][0] != 'S' ) {
		char *reason;
		if ( argv[1] ) {
			reason = argv[1];
		} else {
			reason = "Unspecified error";
		}
		dprintf(D_ALWAYS,"GAHP command '%s' failed: %s\n",command,reason);
		return false;
	}

	if ( id == current_cache_id ) {
		useCachedProxy( id, true );
	}

	return true;
}

bool
GahpServer::uncacheProxy( int id )
{
	static const char *command = "UNCACHE_PROXY";

		// Check if this command is supported
	if  (m_commands_supported->contains_anycase(command)==FALSE) {
		return false;
	}

	char buf[_POSIX_PATH_MAX];
	int x = snprintf(buf,sizeof(buf),"%s %d",command,id);
	ASSERT( x > 0 && x < (int)sizeof(buf) );
	write_line(buf);
	Gahp_Args result;
	char **argv = read_argv(result);
	if ( argv[0] == NULL || argv[0][0] != 'S' ) {
		char *reason;
		if ( argv[1] ) {
			reason = argv[1];
		} else {
			reason = "Unspecified error";
		}
		dprintf(D_ALWAYS,"GAHP command '%s' failed: %s\n",command,reason);
		return false;
	}

	if ( current_cache_id == id ) {
		if ( useCachedProxy( GAHPCLIENT_CACHE_DEFAULT_PROXY ) == false ) {
			EXCEPT( "useCachedProxy failed in uncacheProxy" );
		}
	}

	return true;
}

bool
GahpServer::useCachedProxy( int id, bool force )
{
	static const char *command = "USE_CACHED_PROXY";

		// Check if this command is supported
	if  (m_commands_supported->contains_anycase(command)==FALSE) {
		return false;
	}

	if ( force == false && id == current_cache_id ) {
		return true;
	}

	char buf[_POSIX_PATH_MAX];
	if ( id == GAHPCLIENT_CACHE_LAST_PROXY ) {
		return true;
	} else if ( id == GAHPCLIENT_CACHE_DEFAULT_PROXY ) {
		int x = snprintf(buf,sizeof(buf),"%s DEFAULT",command);
		ASSERT( x > 0 && x < (int)sizeof(buf) );
	} else if ( id >= 0 ) {
		int x = snprintf(buf,sizeof(buf),"%s %d",command,id);
		ASSERT( x > 0 && x < (int)sizeof(buf) );
	} else {
		dprintf(D_ALWAYS,
				"GahpClient::useCachedProxy called with invalid id=%d\n",id);
		return false;
	}
	write_line(buf);
	Gahp_Args result;
	char **argv = read_argv(result);
	if ( argv[0] == NULL || argv[0][0] != 'S' ) {
		char *reason;
		if ( argv[1] ) {
			reason = argv[1];
		} else {
			reason = "Unspecified error";
		}
		dprintf(D_ALWAYS,"GAHP command '%s' failed: %s\n",command,reason);
		return false;
	}

	current_cache_id = id;

	return true;
}

int
GahpServer::doProxyCheck()
{
	daemonCore->Reset_Timer( proxy_check_tid, TIMER_NEVER );

	if ( m_gahp_pid == -1 ) {
		return 0;
	}

	if ( master_proxy->proxy->expiration_time !=
		 master_proxy->cached_expiration ) {

		static const char *command = "REFRESH_PROXY_FROM_FILE";
		if ( command_initialize_from_file( master_proxy->proxy->proxy_filename,
										   command) == false ) {
			EXCEPT( "Failed to refresh proxy!" );
		}

		if ( cacheProxyFromFile( master_proxy->proxy->gahp_proxy_id,
								 master_proxy->proxy->proxy_filename ) == false ) {
			EXCEPT( "Failed to refresh proxy!" );
		}

		master_proxy->cached_expiration = master_proxy->proxy->expiration_time;
	}

	GahpProxyInfo *next_proxy;

	ProxiesByFilename->startIterations();
	while ( ProxiesByFilename->iterate( next_proxy ) != 0 ) {

		if ( next_proxy->proxy->expiration_time != next_proxy->cached_expiration ) {
			if ( cacheProxyFromFile( next_proxy->proxy->gahp_proxy_id,
									 next_proxy->proxy->proxy_filename ) == false ) {
				EXCEPT( "Failed to refresh proxy!" );
			}

			next_proxy->cached_expiration = next_proxy->proxy->expiration_time;
		}

	}

	return 0;
}

bool
GahpServer::RegisterProxy( const char *proxy_path )
{
	int rc;
	GahpProxyInfo *gahp_proxy = NULL;

	if ( ProxiesByFilename == NULL ) {
		return false;
	}

	rc = ProxiesByFilename->lookup( HashKey( proxy_path ), gahp_proxy );

	if ( rc != 0 ) {
		gahp_proxy = new GahpProxyInfo;
		ASSERT(gahp_proxy);
		gahp_proxy->proxy = AcquireProxy( proxy_path, proxy_check_tid );
		gahp_proxy->cached_expiration = 0;
//		daemonCore->Reset_Timer( proxy_check_tid, 0 );
		if ( cacheProxyFromFile( gahp_proxy->proxy->gahp_proxy_id,
								 gahp_proxy->proxy->proxy_filename ) == false ) {
			EXCEPT( "Failed to cache proxy!" );
		}
		gahp_proxy->cached_expiration = gahp_proxy->proxy->expiration_time;

		ProxiesByFilename->insert( HashKey( proxy_path ), gahp_proxy );
	} else {
			// do nothing
	}

	return true;
}

void
GahpServer::setPollInterval(unsigned int interval)
{
	if (poll_tid != -1) {
		daemonCore->Cancel_Timer(poll_tid);
		poll_tid = -1;
	}
	m_pollInterval = interval;
	if ( m_pollInterval > 0 ) {
		poll_tid = daemonCore->Register_Timer(m_pollInterval,
											m_pollInterval,
											(TimerHandlercpp)&GahpServer::poll,
											"GahpServer::poll",this);
	}
}

unsigned int
GahpServer::getPollInterval()
{
	return m_pollInterval;
}

const char *
escapeGahpString(const char * input) 
{
	static MyString output;

	if (!input) return NULL;

	output = "";

	unsigned int i = 0;
	size_t input_len = strlen(input);
	for (i=0; i < input_len; i++) {
		if ( input[i] == ' ' ) {
			output += '\\';
		}
		output += input[i];
	}

	return output.Value();
}


int
GahpClient::globus_gram_client_set_credentials(const char *proxy_path)
{

	static const char *command = "REFRESH_PROXY_FROM_FILE";

		// Check if this command is supported
	if  (server->m_commands_supported->contains_anycase(command)==FALSE) {
		return 1;
	}

		// This command is always synchronous, so results_only mode
		// must always fail...
	if ( m_mode == results_only ) {
		return 1;
	}

	if ( server->command_initialize_from_file(proxy_path,command) == true ) {
		return 0;
	} else {
		return 1;
	}
}

void
GahpServer::poll_real_soon()
{
	// Poll for results asap via a timer, unless a request
	// to poll for resuts is already pending.
	if (!poll_pending) {
		int tid = daemonCore->Register_Timer(0,
			(TimerHandlercpp)&GahpServer::poll,
			"GahpServer::poll from poll_real_soon",this);
		if ( tid != -1 ) {
			poll_pending = true;
		}
	}
}


int
GahpServer::pipe_ready()
{
	skip_next_r = true;
	poll_real_soon();
	return TRUE;
}


bool
GahpServer::command_initialize_from_file(const char *proxy_path,
										 const char *command)
{

	ASSERT(proxy_path);		// Gotta have it...

	char buf[_POSIX_PATH_MAX];
	if ( command == NULL ) {
		command = "INITIALIZE_FROM_FILE";
	}
	int x = snprintf(buf,sizeof(buf),"%s %s",command,
					 escapeGahpString(proxy_path));
	ASSERT( x > 0 && x < (int)sizeof(buf) );
	write_line(buf);
	Gahp_Args result;
	char **argv = read_argv(result);
	if ( argv[0] == NULL || argv[0][0] != 'S' ) {
		char *reason;
		if ( argv[1] ) {
			reason = argv[1];
		} else {
			reason = "Unspecified error";
		}
		dprintf(D_ALWAYS,"GAHP command '%s' failed: %s\n",command,reason);
		return false;
	}

	return true;
}


bool
GahpServer::command_response_prefix(const char *prefix)
{
	static const char* command = "RESPONSE_PREFIX";

	if  (m_commands_supported->contains_anycase(command)==FALSE) {
		return false;
	}

	char buf[_POSIX_PATH_MAX];
	int x = snprintf(buf,sizeof(buf),"%s %s",command,escapeGahpString(prefix));
	ASSERT( x > 0 && x < (int)sizeof(buf) );
	write_line(buf);
	Gahp_Args result;
	char **argv = read_argv(result);
	if ( argv[0] == NULL || argv[0][0] != 'S' ) {
		dprintf(D_ALWAYS,"GAHP command '%s' failed\n",command);
		return false;
	}

	return true;
}

bool
GahpServer::command_async_mode_on()
{
	static const char* command = "ASYNC_MODE_ON";

	if  (m_commands_supported->contains_anycase(command)==FALSE) {
		return false;
	}

	write_line(command);
	Gahp_Args result;
	char **argv = read_argv(result);
	if ( argv[0] == NULL || argv[0][0] != 'S' ) {
		dprintf(D_ALWAYS,"GAHP command '%s' failed\n",command);
		return false;
	}

	return true;
}


bool
GahpServer::command_commands()
{
	write_line("COMMANDS");
	Gahp_Args result;
	char **argv = read_argv(result);
	if ( argv[0] == NULL || argv[0][0] != 'S' ) {
		dprintf(D_ALWAYS,"GAHP command 'COMMANDS' failed\n");
		return false;
	}

	if ( m_commands_supported ) {
		delete m_commands_supported;
		m_commands_supported = NULL;
	}
	m_commands_supported = new StringList();
	ASSERT(m_commands_supported);
	for ( int i = 1; argv[i]; i++ ) {
		m_commands_supported->append(argv[i]);
	}

	return true;
}
	
bool
GahpServer::command_version(bool banner_string)
{
	int i,j,result;
	bool ret_val = false;

	j = sizeof(m_gahp_version);
	i = 0;
	while ( i < j ) {
		result = read(m_gahp_readfd, &(m_gahp_version[i]), 1 );
		/* Check return value from read() */
		if ( result < 0 ) {		/* Error - try reading again */
			continue;
		}
		if ( result == 0 ) {	/* End of File */
				// may as well just return false, and let reaper cleanup
			return false;
		}
		if ( i==0 && m_gahp_version[0] != '$' ) {
			continue;
		}
		if ( m_gahp_version[i] == '\\' ) {
			continue;
		}
		if ( m_gahp_version[i] == '\n' ) {
			ret_val = true;
			m_gahp_version[i] = '\0';
			break;
		}
		i++;
	}

	return ret_val;
}

const char *
GahpClient::globus_gram_client_error_string(int error_code)
{
	static char buf[200];
	static const char* command = "GRAM_ERROR_STRING";

		// Return "Unknown error" if GAHP doesn't support this command
	if  (server->m_commands_supported->contains_anycase(command)==FALSE) {
		strcpy(buf,"Unknown error");
		return buf;
	}

	int x = snprintf(buf,sizeof(buf),"%s %d",command,error_code);
	ASSERT( x > 0 && x < (int)sizeof(buf) );
	server->write_line(buf);
	Gahp_Args result;
	char **argv = server->read_argv(result);
	if ( argv[0] == NULL || argv[0][0] != 'S' || argv[1] == NULL ) {
		dprintf(D_ALWAYS,"GAHP command '%s' failed: error_code=%d\n",
						command,error_code);
		return NULL;
	}
		// Copy error string into our static buffer.
	strncpy(buf,argv[1],sizeof(buf));
	
	return buf;
}

int 
GahpClient::globus_gass_server_superez_init( char **gass_url, int port )
{

	static const char* command = "GASS_SERVER_INIT";

	if ( server->globus_gass_server_url != NULL ) {
		*gass_url = strdup( server->globus_gass_server_url );
		return 0;
	}

		// Check if this command is supported
	if  (server->m_commands_supported->contains_anycase(command)==FALSE) {
		return GAHPCLIENT_COMMAND_NOT_SUPPORTED;
	}

		// Generate request line
	int size = 150;
	Gahp_Buf reqline(size);
	char *buf = reqline.buffer;
	int x = snprintf(buf,size,"%d",port);
	ASSERT( x > 0 && x < size );

		// Check if this request is currently pending.  If not, make
		// it the pending request.
	if ( !is_pending(command,buf) ) {
		// Command is not pending, so go ahead and submit a new one
		// if our command mode permits.
		if ( m_mode == results_only ) {
			return GAHPCLIENT_COMMAND_NOT_SUBMITTED;
		}
		now_pending(command,buf);
	}

		// If we made it here, command is pending.
		
		// Check first if command completed.
	Gahp_Args* result = get_pending_result(command,buf);
	if ( result ) {
		// command completed.
		if (result->argc != 3) {
			EXCEPT("Bad %s Result",command);
		}
		int rc = atoi(result->argv[1]);
		if ( result->argv[2] && strcasecmp(result->argv[2], NULLSTRING) ) {
			*gass_url = strdup(result->argv[2]);
			server->globus_gass_server_url = strdup(result->argv[2]);
		}
		delete result;
		return rc;
	}

		// Now check if pending command timed out.
	if ( check_pending_timeout(command,buf) ) {
		// pending command timed out.
		return GAHPCLIENT_COMMAND_TIMED_OUT;
	}

		// If we made it here, command is still pending...
	return GAHPCLIENT_COMMAND_PENDING;
}

int 
GahpClient::globus_gram_client_job_request(
	const char * resource_manager_contact,
	const char * description,
	const int job_state_mask,
	const char * callback_contact,
	char ** job_contact)
{

	static const char* command = "GRAM_JOB_REQUEST";

		// Check if this command is supported
	if  (server->m_commands_supported->contains_anycase(command)==FALSE) {
		return GAHPCLIENT_COMMAND_NOT_SUPPORTED;
	}

		// Generate request line
	if (!resource_manager_contact) resource_manager_contact=NULLSTRING;
	if (!description) description=NULLSTRING;
	if (!callback_contact) callback_contact=NULLSTRING;
	int size = strlen(resource_manager_contact) + strlen(description) +
			strlen(callback_contact) + 150;
	Gahp_Buf reqline(size);
	char *buf = reqline.buffer;
	char *esc1 = strdup( escapeGahpString(resource_manager_contact) );
	char *esc2 = strdup( escapeGahpString(callback_contact) );
	char *esc3 = strdup( escapeGahpString(description) );
	int x = snprintf(buf,size,"%s %s 1 %s", esc1, esc2, esc3 );
	free( esc1 );
	free( esc2 );
	free( esc3 );
	ASSERT( x > 0 && x < size );

		// Check if this request is currently pending.  If not, make
		// it the pending request.
	if ( !is_pending(command,buf) ) {
		// Command is not pending, so go ahead and submit a new one
		// if our command mode permits.
		if ( m_mode == results_only ) {
			return GAHPCLIENT_COMMAND_NOT_SUBMITTED;
		}
		now_pending(command,buf,deleg_proxy_cache_id);
	}

		// If we made it here, command is pending.
		
		// Check first if command completed.
	Gahp_Args* result = get_pending_result(command,buf);
	if ( result ) {
		// command completed.
		if (result->argc != 3) {
			EXCEPT("Bad %s Result",command);
		}
		int rc = atoi(result->argv[1]);
		if ( result->argv[2] && strcasecmp(result->argv[2], NULLSTRING) ) {
			*job_contact = strdup(result->argv[2]);
		}
		delete result;
		return rc;
	}

		// Now check if pending command timed out.
	if ( check_pending_timeout(command,buf) ) {
		// pending command timed out.
		return GAHPCLIENT_COMMAND_TIMED_OUT;
	}

		// If we made it here, command is still pending...
	return GAHPCLIENT_COMMAND_PENDING;
}

int 
GahpClient::globus_gram_client_job_cancel(const char * job_contact)
{

	static const char* command = "GRAM_JOB_CANCEL";

		// Check if this command is supported
	if  (server->m_commands_supported->contains_anycase(command)==FALSE) {
		return GAHPCLIENT_COMMAND_NOT_SUPPORTED;
	}

		// Generate request line
	if (!job_contact) job_contact=NULLSTRING;
	int size = strlen(job_contact) + 150;
	Gahp_Buf reqline(size);
	char *buf = reqline.buffer;
	int x = snprintf(buf,size,"%s",escapeGahpString(job_contact));
	ASSERT( x > 0 && x < size );

		// Check if this request is currently pending.  If not, make
		// it the pending request.
	if ( !is_pending(command,buf) ) {
		// Command is not pending, so go ahead and submit a new one
		// if our command mode permits.
		if ( m_mode == results_only ) {
			return GAHPCLIENT_COMMAND_NOT_SUBMITTED;
		}
		now_pending(command,buf,normal_proxy_cache_id);
	}

		// If we made it here, command is pending.
		
		// Check first if command completed.
	Gahp_Args* result = get_pending_result(command,buf);
	if ( result ) {
		// command completed.
		if (result->argc != 2) {
			EXCEPT("Bad %s Result",command);
		}
		int rc = atoi(result->argv[1]);
		delete result;
		return rc;
	}

		// Now check if pending command timed out.
	if ( check_pending_timeout(command,buf) ) {
		// pending command timed out.
		return GAHPCLIENT_COMMAND_TIMED_OUT;
	}

		// If we made it here, command is still pending...
	return GAHPCLIENT_COMMAND_PENDING;
}

int
GahpClient::globus_gram_client_job_status(const char * job_contact,
	int * job_status,
	int * failure_code)
{
	static const char* command = "GRAM_JOB_STATUS";

		// Check if this command is supported
	if  (server->m_commands_supported->contains_anycase(command)==FALSE) {
		return GAHPCLIENT_COMMAND_NOT_SUPPORTED;
	}

		// Generate request line
	if (!job_contact) job_contact=NULLSTRING;
	int size = strlen(job_contact) + 150;
	Gahp_Buf reqline(size);
	char *buf = reqline.buffer;
	int x = snprintf(buf,size,"%s",escapeGahpString(job_contact));
	ASSERT( x > 0 && x < size );

		// Check if this request is currently pending.  If not, make
		// it the pending request.
	if ( !is_pending(command,buf) ) {
		// Command is not pending, so go ahead and submit a new one
		// if our command mode permits.
		if ( m_mode == results_only ) {
			return GAHPCLIENT_COMMAND_NOT_SUBMITTED;
		}
		now_pending(command,buf,normal_proxy_cache_id);
	}

		// If we made it here, command is pending.
		
		// Check first if command completed.
	Gahp_Args* result = get_pending_result(command,buf);
	if ( result ) {
		// command completed.
		if (result->argc != 4) {
			EXCEPT("Bad %s Result",command);
		}
		int rc = atoi(result->argv[1]);
		*failure_code = atoi(result->argv[2]);
		if ( rc == 0 ) {
			*job_status = atoi(result->argv[3]);
		}
		delete result;
		return rc;
	}

		// Now check if pending command timed out.
	if ( check_pending_timeout(command,buf) ) {
		// pending command timed out.
		return GAHPCLIENT_COMMAND_TIMED_OUT;
	}

		// If we made it here, command is still pending...
	return GAHPCLIENT_COMMAND_PENDING;
}


int
GahpClient::globus_gram_client_job_signal(const char * job_contact,
	globus_gram_protocol_job_signal_t signal,
	const char * signal_arg,
	int * job_status,
	int * failure_code)
{
	static const char* command = "GRAM_JOB_SIGNAL";

		// Check if this command is supported
	if  (server->m_commands_supported->contains_anycase(command)==FALSE) {
		return GAHPCLIENT_COMMAND_NOT_SUPPORTED;
	}

		// Generate request line
	if (!job_contact) job_contact=NULLSTRING;
	if (!signal_arg) signal_arg=NULLSTRING;
	int size = strlen(job_contact) + strlen(signal_arg) + 150;
	Gahp_Buf reqline(size);
	char *buf = reqline.buffer;
	char *esc1 = strdup( escapeGahpString(job_contact) );
	char *esc2 = strdup( escapeGahpString(signal_arg) );
	int x = snprintf(buf,size,"%s %d %s",esc1,signal,esc2);
	free( esc1 );
	free( esc2 );
	ASSERT( x > 0 && x < size );

		// Check if this request is currently pending.  If not, make
		// it the pending request.
	if ( !is_pending(command,buf) ) {
		// Command is not pending, so go ahead and submit a new one
		// if our command mode permits.
		if ( m_mode == results_only ) {
			return GAHPCLIENT_COMMAND_NOT_SUBMITTED;
		}
		now_pending(command,buf,normal_proxy_cache_id);
	}

		// If we made it here, command is pending.
		
		// Check first if command completed.
	Gahp_Args* result = get_pending_result(command,buf);
	if ( result ) {
		// command completed.
		if (result->argc != 4) {
			EXCEPT("Bad %s Result",command);
		}
		int rc = atoi(result->argv[1]);
		*failure_code = atoi(result->argv[2]);
		if ( rc == 0 ) {
			*job_status = atoi(result->argv[3]);
		}
		delete result;
		return rc;
	}

		// Now check if pending command timed out.
	if ( check_pending_timeout(command,buf) ) {
		// pending command timed out.
		return GAHPCLIENT_COMMAND_TIMED_OUT;
	}

		// If we made it here, command is still pending...
	return GAHPCLIENT_COMMAND_PENDING;
}


int
GahpClient::globus_gram_client_job_callback_register(const char * job_contact,
	const int job_state_mask,
	const char * callback_contact,
	int * job_status,
	int * failure_code)
{
	static const char* command = "GRAM_JOB_CALLBACK_REGISTER";

		// Check if this command is supported
	if  (server->m_commands_supported->contains_anycase(command)==FALSE) {
		return GAHPCLIENT_COMMAND_NOT_SUPPORTED;
	}

		// Generate request line
	if (!job_contact) job_contact=NULLSTRING;
	if (!callback_contact) callback_contact=NULLSTRING;
	int size = strlen(job_contact) + strlen(callback_contact) + 150;
	Gahp_Buf reqline(size);
	char *buf = reqline.buffer;
	char *esc1 = strdup( escapeGahpString(job_contact) );
	char *esc2 = strdup( escapeGahpString(callback_contact) );
	int x = snprintf(buf,size,"%s %s",esc1,esc2);
	free( esc1 );
	free( esc2 );
	ASSERT( x > 0 && x < size );

		// Check if this request is currently pending.  If not, make
		// it the pending request.
	if ( !is_pending(command,buf) ) {
		// Command is not pending, so go ahead and submit a new one
		// if our command mode permits.
		if ( m_mode == results_only ) {
			return GAHPCLIENT_COMMAND_NOT_SUBMITTED;
		}
		now_pending(command,buf,normal_proxy_cache_id);
	}

		// If we made it here, command is pending.
		
		// Check first if command completed.
	Gahp_Args* result = get_pending_result(command,buf);
	if ( result ) {
		// command completed.
		if (result->argc != 4) {
			EXCEPT("Bad %s Result",command);
		}
		int rc = atoi(result->argv[1]);
		*failure_code = atoi(result->argv[2]);
		if ( rc == 0 ) {
			*job_status = atoi(result->argv[3]);
		}
		delete result;
		return rc;
	}

		// Now check if pending command timed out.
	if ( check_pending_timeout(command,buf) ) {
		// pending command timed out.
		return GAHPCLIENT_COMMAND_TIMED_OUT;
	}

		// If we made it here, command is still pending...
	return GAHPCLIENT_COMMAND_PENDING;
}


int 
GahpClient::globus_gram_client_ping(const char * resource_contact)
{
	static const char* command = "GRAM_PING";

		// Check if this command is supported
	if  (server->m_commands_supported->contains_anycase(command)==FALSE) {
		return GAHPCLIENT_COMMAND_NOT_SUPPORTED;
	}

		// Generate request line
	if (!resource_contact) resource_contact=NULLSTRING;
	int size = strlen(resource_contact) + 150;
	Gahp_Buf reqline(size);
	char *buf = reqline.buffer;
	int x = snprintf(buf,size,"%s",escapeGahpString(resource_contact));
	ASSERT( x > 0 && x < size );

		// Check if this request is currently pending.  If not, make
		// it the pending request.
	if ( !is_pending(command,buf) ) {
		// Command is not pending, so go ahead and submit a new one
		// if our command mode permits.
		if ( m_mode == results_only ) {
			return GAHPCLIENT_COMMAND_NOT_SUBMITTED;
		}
		now_pending(command,buf,normal_proxy_cache_id);
	}

		// If we made it here, command is pending.
		
		// Check first if command completed.
	Gahp_Args* result = get_pending_result(command,buf);
	if ( result ) {
		// command completed.
		if (result->argc != 2) {
			EXCEPT("Bad %s Result",command);
		}
		int rc = atoi(result->argv[1]);
		delete result;
		return rc;
	}

		// Now check if pending command timed out.
	if ( check_pending_timeout(command,buf) ) {
		// pending command timed out.
		return GAHPCLIENT_COMMAND_TIMED_OUT;
	}

		// If we made it here, command is still pending...
	return GAHPCLIENT_COMMAND_PENDING;
}

int
GahpClient::globus_gram_client_job_refresh_credentials(const char *job_contact)
{
	static const char* command = "GRAM_JOB_REFRESH_PROXY";

		// Check if this command is supported
	if  (server->m_commands_supported->contains_anycase(command)==FALSE) {
		return GAHPCLIENT_COMMAND_NOT_SUPPORTED;
	}

		// Generate request line
	if (!job_contact) job_contact=NULLSTRING;
	int size = strlen(job_contact) + 150;
	Gahp_Buf reqline(size);
	char *buf = reqline.buffer;
	int x = snprintf(buf,size,"%s",escapeGahpString(job_contact));
	ASSERT( x > 0 && x < size );

		// Check if this request is currently pending.  If not, make
		// it the pending request.
	if ( !is_pending(command,buf) ) {
		// Command is not pending, so go ahead and submit a new one
		// if our command mode permits.
		if ( m_mode == results_only ) {
			return GAHPCLIENT_COMMAND_NOT_SUBMITTED;
		}
		now_pending(command,buf,deleg_proxy_cache_id);
	}

		// If we made it here, command is pending.
		
		// Check first if command completed.
	Gahp_Args* result = get_pending_result(command,buf);
	if ( result ) {
		// command completed.
		if (result->argc != 2) {
			EXCEPT("Bad %s Result",command);
		}
		int rc = atoi(result->argv[1]);
		delete result;
		return rc;
	}

		// Now check if pending command timed out.
	if ( check_pending_timeout(command,buf) ) {
		// pending command timed out.
		return GAHPCLIENT_COMMAND_TIMED_OUT;
	}

		// If we made it here, command is still pending...
	return GAHPCLIENT_COMMAND_PENDING;
}


bool
GahpClient::is_pending(const char *command, const char *buf) 
{
		// note: do _NOT_ check pending reqid here.
	if ( strcmp(command,pending_command)==0 && 
		 ( (pending_args==NULL) || strcmp(buf,pending_args)==0) )
	{
		return true;
	} 

	return false;
}

void
GahpClient::clear_pending()
{
	if ( pending_reqid ) {
			// remove from hashtable
		if (server->requestTable->remove(pending_reqid) == 0) {
				// entry was still in the hashtable, which means
				// that this reqid is still with the gahp server or
				// still in our waitingToSubmit queue.
				// so re-insert an entry with this pending_reqid
				// with a NULL data field so we do not reuse this reqid.
			server->requestTable->insert(pending_reqid,NULL);
		}
	}
	pending_reqid = 0;
	if (pending_result) delete pending_result;
	pending_result = NULL;
	pending_command[0] = '\0';
	if (pending_args) free(pending_args);
	pending_args = NULL;
	pending_timeout = 0;
	if (pending_submitted_to_gahp) {
		server->num_pending_requests--;
	}
	pending_submitted_to_gahp = false;
	if ( pending_timeout_tid != -1 ) {
		daemonCore->Cancel_Timer(pending_timeout_tid);
		pending_timeout_tid = -1;
	}
}

int
GahpClient::reset_user_timer_alarm()
{
	return reset_user_timer(pending_timeout_tid);
}

int
GahpClient::reset_user_timer(int tid)
{
	int retval = TRUE;

	if ( user_timerid != -1 ) {
		retval =  daemonCore->Reset_Timer(user_timerid,0);
	}
	
	// clear out any timeout timer on this event.
	if ( pending_timeout_tid != -1 ) {
		if ( tid < 0 ) {
			// if tid < 0, we were not called from DaemonCore, so our timer
			// is still out there.  Cancel it.  Note that if tid >= 0, then
			// DaemonCore has already canceled the timer because it just
			// went off, and it is not periodic.
			daemonCore->Cancel_Timer(pending_timeout_tid);
		}
		pending_timeout_tid = -1;
	}

	return retval;
}

void
GahpClient::now_pending(const char *command,const char *buf,int cache_id)
{

		// First, if command is not NULL we have a new pending request.
		// If so, carefully clear out the previous pending request
		// and stash our new pending request.  If command is NULL,
		// we have a request which is pending, but not yet submitted
		// to the GAHP.
	if ( command ) {
		clear_pending();
		strcpy(pending_command,command);
		pending_reqid = new_reqid();
		if (buf) {
			pending_args = strdup(buf);
		}
		if (m_timeout) {
			pending_timeout = m_timeout;
		}
		pending_cache_id = cache_id;
			// add new reqid to hashtable
		server->requestTable->insert(pending_reqid,this);
	}

	if ( server->num_pending_requests >= server->max_pending_requests ) {
			// We have too many requests outstanding.  Queue up
			// this request for later.
		server->waitingToSubmit.enqueue(pending_reqid);
		return;
	}

		// Make sure the command is using the proxy it wants.
	if ( server->useCachedProxy( pending_cache_id ) != true ) {
		EXCEPT( "useCachedProxy() failed!" );
	}

		// Write the command out to the gahp server.
	server->write_line(pending_command,pending_reqid,pending_args);
	Gahp_Args return_line;
	char **argv = server->read_argv(return_line);
	if ( argv[0] == NULL || argv[0][0] != 'S' ) {
		// Badness !
		EXCEPT("Bad %s Request",command);
	}

	pending_submitted_to_gahp = true;
	server->num_pending_requests++;

	if (pending_timeout) {
		pending_timeout_tid = daemonCore->Register_Timer(pending_timeout + 1,
			(TimerHandlercpp)&GahpClient::reset_user_timer_alarm,
			"GahpClient::reset_user_timer_alarm",this);
		pending_timeout += time(NULL);
	}
}

Gahp_Args*
GahpClient::get_pending_result(const char *,const char *)
{
	Gahp_Args* r = NULL;

		// Handle blocking mode if enabled
	if ( (m_mode == blocking) && (!pending_result) ) {
		for (;;) {
			server->poll();
			if ( pending_result ) {
					// We got the result, stop blocking
				break;
			}
			if ( pending_timeout && (time(NULL) > pending_timeout) ) {
					// We timed out, stop blocking
				break;
			}
			sleep(1);	// block for one second and then poll again...
		}
	}

	if ( pending_result ) {
		ASSERT(pending_reqid == 0);
		r = pending_result;
			// set pending_result to NULL so clear_pending does not delete
			// the result we are passing back to our caller.
		pending_result = NULL;  // must do this before calling clear_pending!
		clear_pending();
	}

	return r;
}

int
GahpServer::poll()
{
	Gahp_Args* result = NULL;
	char **argv;
	int num_results = 0;
	int i, result_reqid;
	GahpClient* entry;
	ExtArray<Gahp_Args*> result_lines;

		// First, send the RESULTS comand to the gahp server
	write_line("RESULTS");

		// First line of RESULTS command contains how many subsequent
		// result lines should be read.
	result = new Gahp_Args;
	ASSERT(result);
	argv = read_argv(result);
	if ( argv[0] == NULL || argv[0][0] != 'S' || argv[1] == NULL ) {
			// Badness !
		dprintf(D_ALWAYS,"GAHP command 'RESULTS' failed\n");
		return 0;
	}
	poll_pending = false;
	num_results = atoi(argv[1]);

		// Now store each result line in an array.
	for (i=0; i < num_results; i++) {
			// Allocate a result buffer if we don't already have one
		if ( !result ) {
			result = new Gahp_Args;
			ASSERT(result);
		}
		read_argv(result);
		result_lines[i] = result;
		result = NULL;
	}

		// At this point, the Results command has compelted.  We needed
		// to store all the results in an array before operating on them,
		// because we need the Results command to complete before we
		// operate on the results.  Why?  Because some of the results
		// require us to make a callback, and the callback may want to 
		// initiate a new Gahp request...

		// Now for each stored request line,
		// lookup the request id in our hash table and stash the result.
	for (i=0; i < num_results; i++) {
		if ( result ) delete result;
		result = result_lines[i];
		argv = result->argv;

		result_reqid = 0;
		if ( argv[0] ) {
			result_reqid = atoi(argv[0]);
		}
		if ( result_reqid == 0 ) {
			// something is very weird; log it and move on...
			dprintf(D_ALWAYS,"GAHP - Bad RESULTS line\n");
			continue;
		}

			// Check and see if this is a gram_client_callback.  If so,
			// deal with it here and now.
		if ( result_reqid == globus_gt2_gram_callback_reqid ) {
			if ( argv[1] && argv[2] && argv[3] ) {
				(*globus_gt2_gram_callback_func)( globus_gt2_gram_user_callback_arg, argv[1], 
								atoi(argv[2]), atoi(argv[3]) );
			} else {
				dprintf(D_FULLDEBUG,
					"GAHP - Bad client_callback results line\n");
			}
			continue;
		}

			// Now lookup in our hashtable....
		entry = NULL;
		requestTable->lookup(result_reqid,entry);
		if ( entry ) {
				// found the entry!  stash the result
			entry->pending_result = result;
				// set result to NULL so we do not deallocate above
			result = NULL;
				// mark pending request completed by setting reqid to 0
			entry->pending_reqid = 0;
				// and reset the user's timer if requested
			entry->reset_user_timer(-1);				
				// and decrement our counter
			num_pending_requests--;
				// and reset our flag
			ASSERT(entry->pending_submitted_to_gahp);
			entry->pending_submitted_to_gahp = false;
		}
			// clear entry from our hashtable so we can reuse the reqid
		requestTable->remove(result_reqid);

	}	// end of looping through each result line

	if ( result ) delete result;


		// Ok, at this point we may have handled a bunch of results.  So
		// that means that some gahp requests languishing in the 
		// waitingToSubmit queue may be good to go.
	ASSERT(num_pending_requests >= 0);
	int waiting_reqid = -1;
	while ( (waitingToSubmit.Length() > 0) &&
			(num_pending_requests < max_pending_requests) ) 
	{
		waitingToSubmit.dequeue(waiting_reqid);
		entry = NULL;
		requestTable->lookup(waiting_reqid,entry);
		if ( entry ) {
			ASSERT(entry->pending_reqid == waiting_reqid);
				// Try to send this request to the gahp.
			entry->now_pending(NULL,NULL);
		} else {
				// this pending entry had been cleared long ago, and
				// has been just sitting around in the hash table
				// to make certain the reqid is not re-used until
				// it is dequeued from the waitingToSubmit queue.
				// So now remove the entry from the hash table
				// so the reqid can be reused.
			requestTable->remove(result_reqid);
		}
	}


	return num_results;
}

bool
GahpClient::check_pending_timeout(const char *,const char *)
{

		// if no command is pending, there is no timeout
	if ( pending_reqid == 0 ) {
		return false;
	}

		// if the command has not yet been given to the gahp server
		// (i.e. it is in the WaitingToSubmit queue), then there is
		// no timeout.
	if ( pending_submitted_to_gahp == false ) {
		return false;
	}

	if ( pending_timeout && (time(NULL) > pending_timeout) ) {
		clear_pending();	// we no longer want to hear about it...
		return true;
	}

	return false;
}


int 
GahpClient::globus_gram_client_callback_allow(
	globus_gram_client_callback_func_t callback_func,
	void * user_callback_arg,
	char ** callback_contact)
{
	char buf[150];
	static const char* command = "GRAM_CALLBACK_ALLOW";

		// Clear this now in case we exit out with an error...
	if (callback_contact) {
		*callback_contact = NULL;
	}
		// First check if we already enabled callbacks; if so,
		// just return our stashed contact.
	if ( server->globus_gt2_gram_callback_contact ) {
			// previously called... make certain nothing changed
		if ( callback_func != server->globus_gt2_gram_callback_func || 
						user_callback_arg != server->globus_gt2_gram_user_callback_arg )
		{
			EXCEPT("globus_gram_client_callback_allow called twice");
		}
		if (callback_contact) {
			*callback_contact = strdup(server->globus_gt2_gram_callback_contact);
			ASSERT(*callback_contact);
		}
		return 0;
	}

		// Check if this command is supported
	if  (server->m_commands_supported->contains_anycase(command)==FALSE) {
		return GAHPCLIENT_COMMAND_NOT_SUPPORTED;
	}

		// This command is always synchronous, so results_only mode
		// must always fail...
	if ( m_mode == results_only ) {
		return GAHPCLIENT_COMMAND_NOT_SUBMITTED;
	}

	int reqid = new_reqid();
	int x = snprintf(buf,sizeof(buf),"%s %d 0",command,reqid);
	ASSERT( x > 0 && x < (int)sizeof(buf) );
	server->write_line(buf);
	Gahp_Args result;
	char **argv = server->read_argv(result);
	if ( argv[0] == NULL || argv[0][0] != 'S' || argv[1] == NULL ) {
			// Badness !
		int ec = argv[1] ? atoi(argv[1]) : GAHPCLIENT_COMMAND_NOT_SUPPORTED;
		const char *es = argv[2] ? argv[2] : "???";
		dprintf(D_ALWAYS,"GAHP command '%s' failed: %s error_code=%d\n",
						es,ec);
		return ec;
	} 

		// Goodness !
	server->globus_gt2_gram_callback_reqid = reqid;
 	server->globus_gt2_gram_callback_func = callback_func;
	server->globus_gt2_gram_user_callback_arg = user_callback_arg;
	server->globus_gt2_gram_callback_contact = strdup(argv[1]);
	ASSERT(server->globus_gt2_gram_callback_contact);
	*callback_contact = strdup(server->globus_gt2_gram_callback_contact);
	ASSERT(*callback_contact);

	return 0;
}

