/*
  How to read this file:

  This file is used to generate 3 C++ language files -  "switches.C",
  "senders.C", and "receivers.C".  Not all of the information contained
  here is needed in every case.

  Switches are functions which are linked in with the user's code, and
  have the same names as the system call they are intended to invoke.
  The switch will determine whether the call should be done locally or
  remotely, and will invoke an appropriate mechanism to accomplish
  that.  In the case of local execution, that will most often be the
  syscall() routine.  In the case of remote calls, that will always be
  the REMOTE_syscall() routine.  The syscall() routine is generally
  provided in the C library, and REMOTE_syscall() is provided by
  Condor.

  Senders are the part of the code which packages up the arguments of a
  system call, sends them to the shadow for remote execution, and then
  package up the results so it looks to the calling routine as though
  the normal system call were done.  The REMOTE_syscall() routine is
  organized as a giant switch() statement, with one "case" for each
  system call.  Each case is called a "sender".

  Receivers are the part of the code which runs on the submitting
  machine that matches with the sender.  The receiver reads all the
  arguments to the system call, performs the call, then sends back the
  results.

  The general format of this file is a function prototype for every
  system call.  Those give the system call return type, the name, and
  the names and types of each of the system call arguments.  The system
  call prototypes have been augmented with other information needed to
  generate correct switches, senders, and receivers.  Each type of
  augmenting information is described here:

  : extract
	  Some system calls cannot be successfully executed by the syscall()
	  routine.  This is generally becuase syscall() expects that every
	  system call will pass its return value through register 0.  A few
	  system calls like getuid() will actually return 2 values, the
	  real uid in register 0, and the effective uid in register 1.  In
	  that case, there is no system call geteuid() - that information is
	  gotten as a side effect of the getuid() system call.  For this
	  reason geteuid() doesn't work with syscall().  In such a case
	  another means must be found to execute the offending system call.
	  We extract from the C library a copy of whatever the normal system
	  call stub is, and change the name by making it all upper case.
	  For example geteuid() becomes GETEUID().  The switch generator must
	  know that geteuid() has to be handled specially in the local case,
	  which is the meaning of "extract".

  : dl_extract
	  This is similar to extract above except it uses dlopen() and
	  dlsym() to find the appropriate versions of the calls in
	  /usr/lib/libc.so.

  : no_sys_chk
	  By default, a test for defined(SYS_name) is wrapped around
	  all non-pseudo calls in senders and receivers.  If a call is
	  marked with no_sys_chk, this test is omitted.  This is useful
	  for calls which are not system calls on a specific platform
	  but must still be supported by remote system calls for
	  cross platform interoperability.

  in code_bytes_bool( buf, len );
	  A statement like this appears with the prototype for the
	  write() system call.  Note that the parameter "buf" is a
	  pointer to void, and it is not immediately obvious whether
	  data should be sent to the remote system call receiver,
	  whether data should be sent back, or both.  Also, "buf" tells
	  us where the data starts, but it is not obvious (from the
	  syntax), how much data should be sent.  This statement tells
	  us that data should be sent to the remote system call
	  receiver by the keyword "in".  If you think of the system
	  call as simply a function, then "buf" is an "in" parameter to
	  the write() function.  "code_bytes( buf, len )" is the
	  routine and arguments which should be used to transfer
	  the data.  A similar statement appears with the prototype for
	  read(), but in this case the keyword "out" indicates that
	  (from the point of view of the read() system call), "buf" is
	  an out parameter, i.e. data must be sent from the system call
	  receiver to the sender.  In cases where data needs to travel
	  in both directions, both an "in" and an "out" statement would
	  appear.

	  NOTE: we need to use code_bytes_bool() here to get the
	  assert-safe functionality we want: 0 on failure, 1 on
	  success.  code_bytes() itself just returns the number of
	  bytes read or written, and -1 on failure. 

** NEW OPTIONS **

map( int fd )

	When MappingFileDescriptors() is in effect, convert this
	fd and check to see if the operation should be performed
	locally.  Not all access methods will support map(). In
	this case, the syscall will fail with EINVAL.

rdiscard( parameter )

	This will throw out the given parameter
	when performing a remote system call.

discard( parameter )

	This will throw out the given parameter
	for both local and remote system calls.

: file_table
	A special flag placed after a prototype to indicate that the
	call should be directed through file_state.C when
	MappingFileDescriptors() is in effect.  Both the checkpointing
	and remote syscall library use this feature.


Each system call prototype has several names associated with
it.  By default, each name is the same as the function name,
perhaps with a CONDOR_ or SYS_ appended as appropriate.
However, you can specify a different name to use in special
circumstances:

: file_table_name( id )

	The file table name specifies the method to call when
	MappingFileDescriptors is in effect, and the file table
	must be used.

	For example, open64() calls FileTab->open().

: local_name( id )

	The local name specifies the system call name to use
	when LocalSysCalls is in effect.

	For example, on some variations of linux, fstat
	needs to call SYS_prev_fstat.

: sender_name( id )

	The sender name indicates that an existing sender
	should be used to generate remote calls by this name.

	For example, fdatasync() uses the existing sender
	CONDOR_fsync.

: remote_name( id )

	Generate a sender for this system call, but use the
	given name when transmitting the arguments.

	For example, fstat64() uses the sender named 
	CONDOR_fstat64, because the conversion from
	structure to network is slightly different than
	that of fstat().  However, it must use the 
	number CONDOR_fstat, because we want to use
	one receiver to interpret both calls.

  Some system calls simply must be handled specially.  Examples
  are readv, and getlogin. This "specialness" dosen't necessarily
  span all three pieces of code we want to generate.
  We would therefore like to include a prototype for
  each special call, but we must somehow tell the switch generator that it
  should only generate a sender and receiver.  We solve the problem
  by running this file through the C preprocessor (cpp) before
  processing it.  The switch generator will ensure that the macro
  SWITCH is defined, the sender generator will instead define the
  macro SENDER, and similarly the reveiver generator will define
  the macro RECEIVER.  We then use cpp conditional statements to
  ensure that each generator sees only the prototypes for which it
  should generate code.

	In addition to senders, receivers, and switches, this file
	may be processed with different features in mind.
		FILE_TABLE - enable switches into the file table
		SAVE_SIGSTATE - enable support for signal handling
		REMOTE_SYSCALLS - enable support for misc syscalls
*/

#define SEND_PATH(name) in code(name)
#define GET_PATH(name) out code(name)
#define ALLOC_PATH(name) alloc(name,_POSIX_PATH_MAX)

/* Decide if we want to use dlopen for extracting or not. */
#if defined( DL_EXTRACT )
#   define EXTRACT dl_extract
#else
#   define EXTRACT extract
#endif

/* This group of calls is needed in the syscall lib and
the standalone ckpt lib, but not in the clipped version.
All of these calls manipulate the open file table.
Notice that adding a function here should also require
an underscore remap in the appropriate switches.REMAP.
*/ 

#if !defined(CLIP)

#if defined(FILE_TABLE)

	int open( const char *path, int flags, ... )
		: file_table
	{
		SEND_PATH( path );
		ALLOC_PATH( path );
	}

	int open64( const char *path, int flags, ... )
		: sender_name(open), file_table_name(open);

	int close( int fd ) : file_table;

	ssize_t read( int fd, void *buf, size_t len )
		: file_table
	{
		out code_bytes_bool( buf, len );
		alloc( buf, len );
	}
	
        ssize_t write( int fd, const void *buf, size_t len )
		: file_table
	{
		in code_bytes_bool( buf, len );
		alloc( buf, len );
	}

	off_t lseek( int fd, off_t offset, int whence )
		: file_table; 
	offset_t llseek( int fd, offset_t offset, int whence )
		: file_table_name(lseek), remote_name(lseek);
	off64_t lseek64( int fd, off64_t offset, int whence )
		: file_table_name(lseek), remote_name(lseek),
		  local_name(llseek);

	int dup( int old_fd ) : file_table;
	int dup2( int old_fd, int new_fd ) : file_table;

	int fcntl( int fd, int cmd, ... ) : file_table;

	#if defined(LINUX) && defined(GLIBC)
		int ioctl( int fd, unsigned long cmd, ... ) : file_table;
	#else
		int ioctl( int fd, int cmd, ... ) : file_table;
	#endif

	int pipe( int fd[] ) : EXTRACT, file_table;

	/* Sync must go through the table to flush the buffer cache.
	Systems that don't have SYS_fsync still need the sender, so we provide
	no_sys_chk for the sender only. */

	int fdsync( int fd )
		: file_table_name(fsync), sender_name(fsync);
	int fdatasync( int fd )
		: file_table_name(fsync), sender_name(fsync);
	int fsync( int fd )
		#if defined(SENDER)
			: file_table, no_sys_chk;
		#else
			: file_table;
		#endif

	/* Truncate must go through the table to update the file size. */

	#if defined( LINUX )
		int ftruncate( int fd, size_t length ) : file_table;
	#else 
		int ftruncate( int fd, off_t length ) : file_table ;
	#endif

	int ftruncate64( int fd, off64_t length )
		: file_table_name(ftruncate), remote_name(ftruncate);
	
	int fchdir( int fd ) : file_table;

#endif /* FILE_TABLE */
#endif /* CLIP */

/* None of the remaining functions go through the file table,
   so they are not needed in the standalone ckpt library.
*/

#if defined(REMOTE_SYSCALLS)
#if !defined(CLIP)

	int fchown( map(int fd), uid_t owner, gid_t group );
	int fchmod( map(int fd), mode_t mode );

	int fstat( map(int fd), struct stat *buf )
	{
		out code( buf );
		alloc( buf, STAT_SIZE );
	}

	int fstat64( map(int fd), struct stat64 *buf )
		: remote_name(fstat)
	{
		out code( buf );
		alloc( buf, STAT64_SIZE );
	}

	int lstat( const char *path, struct stat *buf )
	{
		SEND_PATH( path );
		ALLOC_PATH( path );
		out code( buf );
		alloc( buf, STAT_SIZE );
	}

	int lstat64( const char *path, struct stat64 *buf )
		: remote_name(lstat)
	{
		out code( buf );
		alloc( buf, STAT64_SIZE );
	}

	int stat( const char *path, struct stat *buf )
	{
		SEND_PATH( path );
		ALLOC_PATH( path );
		out code( buf );
		alloc( buf, STAT_SIZE );
	}

	int stat64( const char *path, struct stat64 *buf )
		: remote_name(stat)
	{
		SEND_PATH( path );
		ALLOC_PATH( path );
		out code( buf );
		alloc( buf, STAT64_SIZE );
	}

	int mknod( const char *path, mode_t mode, dev_t device )
	{
		SEND_PATH( path );
		ALLOC_PATH( path );
	}

	/* Linux, Irix, and Solaris need these switches to redirect
	   these calls to fxstat, lxstat, and xstat.  On Linux,
	   fxstat calls CONDOR_fstat or SYS_oldfstat.  On Irix and
	   Solaris, fxstat calls CONDOR_fstat or SYS_fxstat.
	*/

	#if defined(Solaris) || defined(IRIX)

	int fxstat( rdiscard(const int version), map(int fd), struct stat *buf )
		: sender_name(fstat), local_name(fxstat);
	int lxstat( rdiscard(const int version), const char *path, struct stat *buf )
		: sender_name(lstat), local_name(lxstat);
	int xstat( rdiscard(const int version), const char *path, struct stat *buf )
		: sender_name(stat), local_name(xstat);
	int xmknod( rdiscard(int version), const char *path, mode_t mode, dev_t device )
		: sender_name(mknod), local_name(xmknod);

	#endif /* Solaris or IRIX */

	#if defined(LINUX)

	int fxstat( discard(int version), map(int fd), struct stat *buf )
		: sender_name(fstat), local_name(oldfstat);
	int lxstat( discard(int version), const char *path, struct stat *buf )
		: sender_name(lstat), local_name(oldlstat);
	int xstat( discard(int version), const char *path, struct stat *buf )
		: sender_name(stat), local_name(oldstat);
	int xmknod(discard(int version), const char *path,mode_t mode,dev_t device)
		: sender_name(mknod), local_name(prev_mknod);

	/* Linux needs these relatives of stat to cover the
	   old entry points to libc.  */

	int prev_fstat( map(int fd), struct stat *buf )
		: sender_name(fstat);
	int prev_lstat( const char *name, struct stat *buf )
		: sender_name(lstat);
	int prev_stat( const char *name, struct stat *buf )
		: sender_name(stat);
	int prev_mknod( const char *name, mode_t mode, dev_t dev )
		: sender_name(mknod);
	int oldfstat( map(int fd), struct stat *buf )
		: sender_name(fstat);
	int oldlstat( const char *name, struct stat *buf )
		: sender_name(lstat);
	int oldstat( const char *name, struct stat *buf )
		: sender_name(stat);

	#endif /* LINUX */

	#if defined(LINUX) || defined(HPUX)
		int statfs( const char *path, struct statfs *buf )
	#elif defined(Solaris) || defined(IRIX)
		int statfs( const char *path, struct statfs *buf, int len, int fstyp )
	#else
		int statfs( char *path, struct statfs *buf, int len )
	#endif
	{
		SEND_PATH( path );
		ALLOC_PATH( path );
		out code( buf );
		alloc( buf, STATFS_SIZE );
	}

	#if defined(IRIX) || defined(Solaris)
		int fstatfs( map(int fd), struct statfs *buf, int len, int fstyp )
	#else
		int fstatfs( map(int fd), struct statfs *buf )
	#endif
	{
		out code( buf );
		alloc( buf, STATFS_SIZE );
	}

	int flock( map(int fd), int op );
	int lockf( map(int fd), int op, off_t where );
	int lockf64( map(int fd), int op, off64_t where )
		: remote_name(lockf);

	#if defined(HPUX) || defined(OSF1)
		int getdirentries( map(int fd), struct dirent *buf, size_t nbytes, off_t *basep )
		{
			out code_bytes_bool( buf, rval );
			in code_bytes_bool( basep, EIGHT );
			out code_bytes_bool( basep, EIGHT );
			alloc( buf, nbytes );
			alloc( basep, LONG_SIZE );
		}
	#elif defined(Solaris) || defined(IRIX)
		int getdents( map(int fd), struct dirent *buf, size_t nbytes )
		{
			out code_bytes_bool( buf, nbytes );
			alloc( buf, nbytes );
		}

	#endif

	int getdents64( map(int fd), struct dirent64 *buf, size_t nbytes )
		: remote_name(getdents)
	{
		out code_bytes_bool( buf, nbytes );
		alloc( buf, nbytes );
	}

#endif /* !defined(CLIP) */

/*
These calls do not need switches because they are pseudo calls,
only invoked by supervisory code in the syscall lib.  They
are also not needed by the starter, so they are not included
in the clipped version.
*/

#if !defined(SWITCH) && !defined(CLIP)

	/* Do not generate switches for these pseudo calls */

	int lseekread( int fd, off_t offset, int whence, void *buf, size_t len )
		: pseudo
	{
		out code_bytes_bool( buf, len );
		alloc( buf, len );
	}

        int lseekwrite( int fd, off_t offset, int whence, const void *buf, size_t len )
		: pseudo
	{
		in code_bytes_bool( buf, len );
		alloc( buf, len );
        }

#ifdef CARMI_OPS

#define RequestId int
#define ResponseTag int
#define HostId int
#define ProcessId int
#define ResourceClass char* /* for the time being */

	int carmi_cancel_request(RequestId id, ResponseTag resp_tag) : pseudo; 

	int carmi_config( ResponseTag resp_tag)	: pseudo; 

	int carmi_get_class_ad(HostId id, ResponseTag resp_tag) : pseudo; 

	int carmi_addhosts(char *class_name, int count, ResponseTag resp_tag) 
		: pseudo {
		SEND_PATH( class_name );
		ALLOC_PATH( class_name );
	}

	int carmi_delhosts(int count, HostId* hosts, ResponseTag resp_tag) 
		:pseudo {
		in code_bytes_bool( hosts, count*sizeof(HostId) );
		alloc( hosts, count*sizeof(HostId) );
	}	

	int carmi_add_notify(char *class_name, ResponseTag resp_tag) :pseudo{
		SEND_PATH( class_name );
		ALLOC_PATH( class_name );
	}

	int carmi_delete_notify(int count, HostId *host_ids, 
                                ResponseTag resp_tag): pseudo {
		in code_bytes_bool( host_ids, count*sizeof(HostId) );
		alloc( host_ids, count*sizeof(HostId) );
	}

	int carmi_suspend_notify(int count, HostId *host_ids,
                                 ResponseTag resp_tag) : pseudo {
		in code_bytes_bool( host_ids, count*sizeof(HostId) );
		alloc( host_ids, count*sizeof(HostId) );
	}

	int carmi_resume_notify(int count, HostId *host_ids,
			ResponseTag resp_tag)  : pseudo{
		in code_bytes_bool( host_ids, count*sizeof(HostId) );
		alloc( host_ids, count*sizeof(HostId) );
	}

	int carmi_class_spawn(char *executable, char* argv[], char *class_name,
		  ResponseTag resp_tag) : pseudo {
		SEND_PATH( executable );
		ALLOC_PATH( executable );
		SEND_PATH( class_name );
		ALLOC_PATH( class_name );
	}

	int carmi_process_info( ResponseTag resp_tag) : pseudo; 

	int carmi_class_definitions( ResponseTag resp_tag) : pseudo; 

	int carmi_define_class( rcclass resc_class, 
				ResponseTag resp_tag) : pseudo {
	}

	int carmi_remove_class( char *class_name, 
                                ResponseTag resp_tag) : pseudo{
		SEND_PATH( class_name );
		ALLOC_PATH( class_name );
	}

	int carmi_ckpt(int ckpt_cnt, ProcessId *ckpt_list, 
	   int consistent_cnt, ProcessId *consistent_list, int flush_cnt, 
	   ProcessId *flush_list, HostId id) : pseudo{

		in code_bytes_bool( ckpt_list, ckpt_cnt*sizeof(ProcessId) );
		alloc( ckpt_list, ckpt_cnt*sizeof(ProcessId) );

		in code_bytes_bool( consistent_list, consistent_cnt*sizeof(ProcessId) );
		alloc( consistent_list, consistent_cnt*sizeof(ProcessId) );

		in code_bytes_bool( flush_list, flush_cnt*sizeof(ProcessId) );
		alloc( flush_list, flush_cnt*sizeof(ProcessId) );

	}

	int carmi_restart(int restart_cnt, ProcessId *restart_list, 
	  int consistent_cnt, ProcessId *consistent_list): pseudo {

		in code_bytes_bool( restart_list, restart_cnt*sizeof(ProcessId) );
		alloc( restart_list, restart_cnt*sizeof(ProcessId) );

		in code_bytes_bool( consistent_list, consistent_cnt*sizeof(ProcessId) );
		alloc( consistent_list, consistent_cnt*sizeof(ProcessId) );

	}

	int carmi_migrate(ProcessId target, HostId host, int
	  consistent_cnt, ProcessId *consistent_list): pseudo {

		in code_bytes_bool( consistent_list, consistent_cnt*sizeof(ProcessId) );
		alloc( consistent_list, consistent_cnt*sizeof(ProcessId) );

	}
#endif /* CARMI_OPS */

#endif	/* not SWITCH and not CLIP */

#if !defined(SWITCH)
	int register_fs_domain( const char *domain ) : pseudo {
		SEND_PATH( domain );
		ALLOC_PATH( domain );
	}
	int register_uid_domain( const char *domain ) : pseudo {
		SEND_PATH( domain );
		ALLOC_PATH( domain );
	}
#endif /* !defined(SWITCH) */

#if !defined( CLIP )
	int link( const char *p1, const char *p2 ) {
		SEND_PATH( p1 );
		SEND_PATH( p2 );
		ALLOC_PATH( p1 );
		ALLOC_PATH( p2 );
	}

	int access( const char *path, int access_mode ) {
		SEND_PATH( path );
		ALLOC_PATH( path );
	}

		/*
		These get special treatment by the shadow, but should work normally
		in local mode.
		*/
	pid_t getppid() : EXTRACT, pseudo;
	uid_t getuid()  : pseudo;
	gid_t getgid()  : pseudo;
	pid_t getpid()  : pseudo;
	
	/*
	getlogin() returns a pointer to a static buffer - our generator is not
	quite yet sophisticated enough to generate correct stubs for this.
	So we have a special switch for it in switches.special.c that
	allocates the static space for it.
	Furthermore, we make it pseudo cuz we want the shadow to return the
	job's Owner as the value.  -Todd , 4/97
	*/
#if !defined(SWITCH)
	int getlogin( char *loginbuf ) : pseudo {
		out code( loginbuf );
		alloc ( loginbuf, _POSIX_PATH_MAX );
	}  
#endif  /* not SWITCH for getlogin() */

#endif /* not CLIP */

	/*
	  These are used by the condor_starter, and thus get generated even in
	  the "clipped" version.
	*/

	uid_t geteuid() : EXTRACT, pseudo;
	gid_t getegid() : EXTRACT, pseudo;

#if !defined(SWITCH)
	char * getwd( char *path_name ) : pseudo {
		GET_PATH( path_name );
		ALLOC_PATH( path_name );
	}
#endif

/*
File system calls which involve names but not fds are
not interpreted by the open file table.
*/

int chdir( const char *path ) : pseudo {
	SEND_PATH( path );
	ALLOC_PATH( path );
}

int unlink( const char *path ) {
	SEND_PATH( path );
	ALLOC_PATH( path );
}
int rename( const char *from, const char *to ) : pseudo {
	SEND_PATH( from );
	SEND_PATH( to );
	ALLOC_PATH( from );
	ALLOC_PATH( to );
}

#if !defined( SWITCH )
		/*
		These are speical operations performed by the shadow, but have
		no meaning in local mode.  Since they are special Condor operations,
		they are generally used by Condor daemons, not user programs.  Thus,
		they should be built in the special "clipped" version.
		*/
	int get_universe( int *univ_id ) : pseudo {
	    out code( univ_id );
	    alloc( univ_id, INT_SIZE );
	}

	int get_username( char *uname ) : pseudo {
	    GET_PATH( uname );
	    ALLOC_PATH( uname );
	}
	
	int extern_name( const char *path, char *buf, int bufsize ) : pseudo {
		SEND_PATH( path );
		ALLOC_PATH( path );
		out code_bytes_bool( buf, bufsize );
		alloc( buf, bufsize );
	}
	int free_fs_blocks( const char *pathname ) : pseudo {
		SEND_PATH( pathname );
		ALLOC_PATH( pathname );
	}
	int reallyexit( int *status, struct rusage *use_p ) : pseudo {
		in code( status );
		alloc( status, INT_SIZE );
		in code( use_p );
		alloc( use_p, RUSAGE_SIZE );
		return( NEG_ONE );
	}
	int subproc_status(int id,int *status,struct rusage *use_p) : pseudo {
		in code( status );
		alloc( status, INT_SIZE );
		in code( use_p );
		alloc( use_p, RUSAGE_SIZE );
		return( NEG_ONE );
	}
	int image_size( int kbytes ) : pseudo;
	int send_rusage( struct rusage *use_p ) : pseudo {
		in code( use_p );
		alloc( use_p, RUSAGE_SIZE );
	}
	int getrusage( int who, struct rusage *use_p ) : pseudo {
		out code( use_p );
		alloc( use_p, RUSAGE_SIZE );
	}
	int report_error( char *msg ) : pseudo {
		in code( msg );
		alloc( msg, MAX_STRING );
	}
	int report_file_info(
		char *name,
		int read_count, int read_bytes,
		int write_count, int write_bytes,
		int seek_count, int size ) : pseudo {

		in code( name );
		alloc( name, MAX_STRING );
	}
#ifndef RECEIVER  /* We need a special receiver so that we don't leak memory */
	int startup_info_request( STARTUP_INFO *s ): pseudo {
		out code( s );
		alloc( s, STARTUP_INFO_SIZE );
	}
#endif
	int std_file_info( int which, char *name, int *pipe_fd ) : pseudo {
		GET_PATH( name );
		ALLOC_PATH( name );
		out code( pipe_fd );
		alloc( pipe_fd, INT_SIZE );
	}
	int file_info( const char *name, int *pipe_fd, char *extern_path ): pseudo {
		SEND_PATH( name );
		ALLOC_PATH( name );
		GET_PATH( extern_path );
		ALLOC_PATH( extern_path );
		out code( pipe_fd );
		alloc( pipe_fd, INT_SIZE );
	}

	int get_buffer_info( int *blocks, int *block_size, int *prefetch_bytes ) : pseudo {
		out code( blocks );
		alloc( blocks, INT_SIZE );
		out code( block_size );
		alloc( block_size, INT_SIZE );
		out code( prefetch_bytes );
		alloc( prefetch_bytes, INT_SIZE );
	}

	int get_iwd( char *path ) : pseudo {
		GET_PATH( path );
		ALLOC_PATH( path );
	}

	int get_ckpt_name( char *path ) : pseudo {
		GET_PATH( path );
		ALLOC_PATH( path );
	}

	int get_ckpt_mode( signal_t sig ) : pseudo;

	int get_ckpt_speed( ) : pseudo;

	int get_a_out_name( char *path ) : pseudo {
		GET_PATH( path );
		ALLOC_PATH( path );
	}

	int pvm_info( const char *response, int mytid ) : pseudo {
		SEND_PATH( response );
		ALLOC_PATH( response );
	}

	int pvm_task_info( int v_pid, int pvm_tid) : pseudo;

	int suspended( int susp ) : pseudo;
		/*
		This function is intended for setting up the transfer
		of a whole file via a TCP stream.  This allows more
		flexibility than the similar get_file() protocol, and may
		be more efficient as well, since we bypass XDR.  The name
		of the file is the single parameter sent to the shadow, and
		the result is the length of the file, a hostname, and a port
		number from which the actual bytes can be read.
		*/
	int get_file_stream( const char *file, size_t *len, unsigned int *ip_addr,
		u_short *port_num ): pseudo {

		SEND_PATH( file );
		ALLOC_PATH( file );

		out code( len );
		alloc( len, SIZE_T_SIZE );

		out code( ip_addr );
		alloc( ip_addr, U_INT_SIZE );

		out code( port_num );
		alloc( port_num, U_SHORT_SIZE );
	}

		/*
		This function is intended for setting up the transfer
		of a whole file via a TCP stream.  This allows more
		flexibility than the similar put_file() protocol, and may
		be more efficient as well, since we bypass XDR.  The name
		of the file is the single parameter sent to the shadow, and
		the result is a hostname and a port number to which the
		actual bytes can be written.
		*/
	int put_file_stream( const char *file, size_t len,
						unsigned int *ip_addr, u_short *port_num ): pseudo {

		SEND_PATH( file );
		ALLOC_PATH( file );

		out code( ip_addr );
		alloc( ip_addr, U_INT_SIZE );

		out code( port_num );
		alloc( port_num, U_SHORT_SIZE );
	}

	int choose_ckpt_server( const char *host ): pseudo {
		SEND_PATH( host );
		ALLOC_PATH( host );
	}

	int register_arch( const char *arch ): pseudo {
		SEND_PATH( arch );
		ALLOC_PATH( arch );
	}

	int register_opsys( const char *opsys ): pseudo {
		SEND_PATH( opsys );
		ALLOC_PATH( opsys );
	}

#	if !defined( SENDER )
		/*
		These two functions implement protocols for sending and fetching
		whole files at a time.  Since there is a more complex protocol
		involved, it's easier to just code the senders by hand.
		They are implemented in "senders.epilogue".
		*/
	int send_file( const char *name, mode_t mode ) : pseudo {
		SEND_PATH( name );
		ALLOC_PATH( name );
	}
	int get_file( const char *name ) : pseudo {
		SEND_PATH( name );
		ALLOC_PATH( name );
	}

#	endif	/* not SENDER */
#endif	/* not SWITCH */


#if !defined( CLIP )

	int chmod( const char *path, mode_t mode ) {
		SEND_PATH( path );
		ALLOC_PATH( path );
	}
#if !defined(Solaris) && !defined(LINUX) && !defined(IRIX62) && !defined(HPUX)
		int getfsstat( struct statfs buf[], long bufsize, int flags ) {
			out code_bytes_bool( buf, STATFS_ARRAY_SIZE );
			alloc( buf, bufsize );
		}
#endif

#if !defined( SWITCH )
	#if defined(LINUX)
		int sync();
	#else
		void sync();
	#endif
#endif /* ! SWITCH */

	int symlink( const char *path1, const char *path2 ) {
		SEND_PATH( path1 );
		SEND_PATH( path2 );
		ALLOC_PATH( path1 );
		ALLOC_PATH( path2 );
	}

#if defined(LINUX) || defined(Solaris26) || defined(OSF1) || defined(HPUX)
	int readlink( const char *path, char *buf, size_t buf_size ) {
#elif defined(IRIX62)
	int readlink( const char *path, char *buf, int buf_size ) {
#else
	int readlink( const char *path, void *buf, int buf_size ) {
#endif
		SEND_PATH( path );
		ALLOC_PATH( path );
		out code_bytes_bool( buf, buf_size );
		alloc( buf, buf_size );
	}

	pid_t getpgrp();
	mode_t umask( mode_t cmask );
	int getpagesize();

	int getgroups( int gidsetsize, gid_t grouplist[] ) {
		out code_bytes_bool( grouplist, gidsetsize * GID_T_SIZE );
		alloc( grouplist, gidsetsize * GID_T_SIZE );
	}


#if defined(OSF1)
	int table( int id, int index, char *addr, int nel, unsigned int lel ) {
		out code_bytes_bool( addr, nel * lel );
		alloc( addr, nel * lel );
	}
#endif

#if defined(LINUX) || defined(OSF1)
	int gethostname( char *address, size_t address_len ) {
#else 
	int gethostname( char *address, int address_len ) {
#endif
		out code_bytes_bool( address, address_len );
		alloc( address, address_len );
	}

	int uname ( struct utsname *info ) {
		out code( info );
		alloc( info, UTSNAME_SIZE );
	}

	int nuname ( struct utsname *info )
		: sender_name(uname), local_name(uname);

	int getdtablesize();

	not_supported {
		int select(int numfds, fd_set *readfds, fd_set *writefds,
			fd_set *exceptfds, struct timeval *timeout);
		int poll(struct pollfd *p, unsigned long l , int i );
	}

	int setpriority( int which, int who, int priority );
	int getpriority( int which, int who );

#if defined(LINUX)
	int gettimeofday( struct timeval *tp, struct timezone *tzp ) {
		out code( tp );
#else
	int gettimeofday( struct timeval *tp, void *tzp ) {
		out code( tp );
#endif
		/* don't code( tzp ) since it is often a NULL pointer */
		alloc( tp, TIMEVAL_SIZE );
		alloc( tzp, TIMEZONE_SIZE );
	}

#if !defined(LINUX)
		int lchown( const char *path, uid_t owner, gid_t group ) {
			SEND_PATH( path );
			ALLOC_PATH( path );
		}
#endif
	int chown( const char *path, uid_t owner, gid_t group ) {
		SEND_PATH( path );
		ALLOC_PATH( path );
	}

#if defined(LINUX)
	int truncate( const char *path, size_t length ) {
		SEND_PATH( path );
		ALLOC_PATH( path );
	}
#elif defined(Solaris) 
	int truncate( const char *path, off_t length ) : extract {
		SEND_PATH( path );
		ALLOC_PATH( path );
	}
#else
	int truncate( const char *path, off_t length ) {
		SEND_PATH( path );
		ALLOC_PATH( path );
	}
#endif /* ! LINUX */

	int truncate64( const char *path, off64_t length )
		: remote_name(truncate)
	{
		SEND_PATH( path );
		ALLOC_PATH( path );
	}

	int mkdir( const char *path, mode_t mode ) {
		SEND_PATH( path );
		ALLOC_PATH( path );
	}
	int rmdir( const char *path ) {
		SEND_PATH( path );
		ALLOC_PATH( path );
	}
	#if defined(OSF1)
	int utimes( const char *path, const struct timeval *times ) {
	#else
	int utimes( const char *path, struct timeval *times ) {
	#endif
		SEND_PATH( path );
		ALLOC_PATH( path );
		in code_bytes_bool( times, TIMEVAL_ARRAY_SIZE );
		alloc( times, TIMEVAL_ARRAY_SIZE );
	}
#if defined(HPUX10) || defined(OSF1)
	long gethostid();
#else
	int gethostid();
#endif

#if defined(HPUX) || defined(LINUX) || defined(Solaris) || defined(IRIX)
	int setrlimit( int resource, const  struct rlimit *rlp ) {
#else
	int setrlimit( int resource, struct rlimit *rlp ) {
#endif
		in code( rlp );
		alloc( rlp, RLIMIT_SIZE );
	}

#if defined(HPUX) || defined(LINUX) || defined(Solaris) || defined(IRIX)
	int setrlimit64( int resource, const struct rlimit64 *rlp )
#else
	int setrlimit64( int resource, struct rlimit64 *rlp )
#endif
		: remote_name(setrlimit)
	{
		in code( rlp );
		alloc( rlp, RLIMIT64_SIZE );
	}

	int getrlimit( int resource, struct rlimit *rlp ) {
		out code( rlp );
		alloc( rlp, RLIMIT_SIZE );
	}

	int getrlimit64( int resource, struct rlimit64 *rlp )
		: remote_name(getrlimit)
	{
		out code( rlp );
		alloc( rlp, RLIMIT64_SIZE );
	}

	int getdomainname( char *name, int namelen ) {
		out code( name, namelen );
		alloc( name, namelen );
	}

#if defined(OSF1)

	int getaddressconf( struct addressconf *buf, size_t length ) {
		out code_bytes_bool( buf, length );
		alloc( buf, length );
	}
#endif

	pid_t getpgid( pid_t pid );

#if defined(Solaris) || defined(LINUX) || defined(IRIX62) || defined(HPUX)
	not_supported { 
		int mvalid( char * addr, size_t len, int prot ) {
			out code_bytes_bool( addr, len );
			alloc( addr, len );
		}

		int uswitch( int cmd, int value );
	}
#else
	int mvalid( char * addr, size_t len, int prot ) {
		out code_bytes_bool( addr, len );
		alloc( addr, len );
	}

	int uswitch( int cmd, int value );
#endif /* Solaris || Linux || IRIX62 */

/*
Things having to do with signals - we may support these
one day soon.  ...and now we do on some platforms -Todd 1/95 
*/

not_supported {

#if !defined(SAVE_SIGSTATE)

	int sigprocmask( int how, SIGSET_CONST sigset_t *set, sigset_t *o_set);
	int sigsuspend( SIGSET_CONST sigset_t *mask );
	int sigpending( sigset_t *set );
	int sigstack( struct sigstack *instack, struct sigstack *outstack );

	#if !defined(LINUX)
		int sigreturn( struct sigcontext *scp );
	#endif

#endif  /* of !defined(SAVE_SIGSTATE) */

#if defined(LINUX) || defined(Solaris251) || defined(HPUX) || defined(OSF1)
	int setitimer( int which, const struct itimerval *value,	
	               struct itimerval *oval );
#else
	int setitimer( int which, struct itimerval *value,
	               struct itimerval *oval );
#endif
	int getitimer( int which, struct itimerval *value );

	}

	/*
	We don't support these everywhere, but we ignore attempts	
	to do them remotely for the benefit of Fortran compilers...
	*/
	ignored {
#if !defined (SAVE_SIGSTATE)
	#if defined(LINUX)
		int sigaction( int sig, struct sigaction *act,
		               struct sigaction *o_act ) : extract;
	#else
		int sigaction( int sig, const struct sigaction *act,
		               struct sigaction *o_act ) : EXTRACT;
	#endif
#endif
		int setsysinfo( unsigned long op, char *buffer,
		                unsigned long nbytes, char * arg,
		                unsigned long flag );
	}

#endif /* not CLIP */

/*
The memory mappnig calls have switches in order to
provide a "not supported" error message for the user, but we
won't generate senders and receivers because there is no
mechanism for transmitting (or using) a void*, which is
MMAP_T on some platforms.
*/

not_supported {
#if defined(SWITCH)

	#if defined(LINUX) && defined(SWITCH)
		/* mmap is a special switch on Linux */
	#else
		MMAP_T mmap( MMAP_T a, size_t l, int p, int f, map(int fd), off_t o ) : EXTRACT;
	#endif
	MMAP_T mmap64( MMAP_T a, size_t l, int p, int f, map(int fd), off64_t o ) : remote_name(mmap);
	int mprotect( MMAP_T addr, size_t len, int prot );
	int madvise( MMAP_T addr, size_t len, int behav );
	int msync( MMAP_T addr, size_t len, int flags );
	/* munmap should not be trapped -- it should always unmap locally. */
#endif /* SWITCH */
}

#if !defined( CLIP )

	/* kill is always handled locally, as a special switch. */

	/* Calls intended only for the super user or system managers */
not_supported {
	int setuid( uid_t uid );
	int setgid( gid_t gid );
	int setreuid( uid_t ruid, uid_t euid );
	int setregid( gid_t rgid, gid_t egid );
	int setlogin( char *name );
	int revoke( char *path );
	int chroot( const char *path );
#if defined(Solaris)
	int setgroups( int gidsetsize, const gid_t grouplist[] );
#else
	int setgroups( int gidsetsize, gid_t grouplist[] );
#endif
	int plock( int op );
#if defined(HPUX10)
	int adjtime( const struct timeval *delta, struct timeval *old_delta );
#else
	int adjtime( struct timeval *delta, struct timeval *old_delta );
#endif
	int sethostid( int host_id );

#if defined(HPUX)
	void async_daemon();
	int nfssvc(int sock);
#else
	int async_daemon();
	int nfssvc(int a, int b, int c );
#endif

#if defined(IRIX)
	/* nothing */
#elif defined(HPUX)
	int getfh( map(int fd), const fhandle_t *fhp );
#else
	int getfh( map(int fd), fhandle_t *fhp, int exp_fd );
#endif

#if !defined(HPUX)
	int exportfs( int access, int *record, struct exportfsdata *exdata );
#endif

#if defined(LINUX)
	int mount( const char *spec, const char *dir, const char *fstyp,
		unsigned long rwflag, const void *data );
	int umount( const char* dir );
	int acct( const char *path );
	int reboot( int magic, int magic_too, int flag );
	int sethostname( const char *address, size_t address_len );
	int settimeofday( const struct timeval *tp, const struct timezone *tzp );
	int setdomainname( const char *name, size_t namelen );
	int swapon( const char *path, int swapflags );
	int swapoff( const char *path );
	int bdflush( int func, long data );
	caddr_t create_module( const char* name, size_t size );
	caddr_t delete_module( const char* name ); 
	int init_module( const char* name, struct module* image ); 
	int iopl( int level );
	void idle();
	int ioperm( unsigned long from, unsigned long num, int turn_on );
#else
	#if defined(Solaris)
		int mount( const char *spec, const char *dir, int mflag, int fstyp, char *pt, int len );
		int acct( const char *path );
	#elif defined(OSF1)
		int mount( int type, char *mnt_path, int mnt_flag, char *data );
		int acct( char *path );
	#elif defined(HPUX)
		/* mount wants varargs */
		int acct( char *path );
	#else
		int mount( char *spec, char *dir, int mflag, int fstyp, char *pt, int len );
		int acct( char *path );
	#endif

	void reboot( int howto );
	int sethostname( char *address, int address_len );
	#if defined(HPUX)
		int settimeofday( const struct timeval *tp, const struct timezone *tzp );
		int setdomainname( const char *name, int namelen );
	#else
		int settimeofday( struct timeval *tp, struct timezone *tzp );
		int setdomainname( char *name, int namelen );
	#endif

#endif  /* of not LINUX */

} /* of not_supported { (Must be after the #endif Linux - Derek) */


	/* Calls having to do with multiple process jobs */
not_supported {
	pid_t fork() : EXTRACT;
	/* Other fork()-like calls */
#if defined(LINUX)
	pid_t clone(void *sp, unsigned long flags);
#elif defined(Solaris)
	pid_t fork1();
#endif
	pid_t vfork();

	int execve( const char *path, char * const argv[], char * const envp [] );
	int execv( const char *path, char * const argv[] );
	int exec_with_loader( int flags, const char *loader, const char *file,
					  char * const argv[], char * const envp[] );
	int execvp( const char *file, char *const argv[] );

	pid_t wait4( pid_t pid, void *status, int options, struct rusage *ru );
	pid_t wait(int *status);
#if defined(LINUX)
	pid_t waitpid(pid_t pid, int *status, int options);
#endif

#if defined(Solaris)
	int ptrace( int req, long process, int address, int data);
#else
	int ptrace( long req, long int process, unsigned long *address,
						unsigned long data );
#endif
	int setpgid( pid_t process_id, pid_t gid );
	pid_t setsid();
#if defined(OSF1)
	int setpgrp( pid_t process_id , pid_t process_group_id );
#else 
	pid_t setpgrp( );
#endif
}

/*
The socket-related calls have lots of tiny per-platform differences.
This is an attempt to do autoconf-style configuration of the little
details.  Ideally, we would collect all these little details about
_all_ the calls and put them in one standard place.  For the moment,
this will stay here next to the socket prototypes.
*/

#if defined(Solaris)
	#define SOCKET_DATA_TYPE char*
	#define SOCKET_DATA_LENGTH int
	#define SOCKET_DATA_CONST const
	#define SOCKET_MSG_CONST const
	#define SOCKET_ADDR_TYPE struct sockaddr*
	#define SOCKET_ADDR_LENGTH int
	#define SOCKET_ADDR_CONST_CONNECT
	#define SOCKET_ADDR_CONST_BIND const
	#define SOCKET_SENDRECV_TYPE int
	#define SOCKET_FLAGS_TYPE int
#elif defined(OSF1)
	#define SOCKET_DATA_TYPE void*
	#define SOCKET_DATA_LENGTH int
	#define SOCKET_DATA_CONST const
	#define SOCKET_MSG_CONST
	#define SOCKET_ADDR_TYPE struct sockaddr*
	#define SOCKET_ADDR_LENGTH int
	#define SOCKET_ADDR_CONST_CONNECT const
	#define SOCKET_ADDR_CONST_BIND const
	#define SOCKET_SENDRECV_TYPE int
	#define SOCKET_FLAGS_TYPE int
#elif defined(HPUX)
	#define SOCKET_DATA_TYPE void*
	#define SOCKET_DATA_LENGTH size_t
	#define SOCKET_DATA_CONST const
	#define SOCKET_MSG_CONST const
	#define SOCKET_ADDR_TYPE struct sockaddr*
	#define SOCKET_ADDR_LENGTH size_t
	#define SOCKET_ADDR_CONST_CONNECT const
	#define SOCKET_ADDR_CONST_BIND const
	#define SOCKET_SENDRECV_TYPE ssize_t
	#define SOCKET_FLAGS_TYPE int
#else
	#define SOCKET_DATA_TYPE void*
	#define SOCKET_DATA_LENGTH int
	#define SOCKET_DATA_CONST const
	#define SOCKET_MSG_CONST const
	#define SOCKET_ADDR_TYPE void*
	#define SOCKET_ADDR_LENGTH int
	#define SOCKET_ADDR_CONST_CONNECT
	#define SOCKET_ADDR_CONST_BIND
	#define SOCKET_SENDRECV_TYPE int
	#define SOCKET_FLAGS_TYPE unsigned int
#endif

int accept(
		map(int fd),
		SOCKET_ADDR_TYPE addr,
		SOCKET_ADDR_LENGTH * length);
int bind(
		map(int fd),
		SOCKET_ADDR_CONST_BIND SOCKET_ADDR_TYPE addr,
		SOCKET_ADDR_LENGTH length );
int connect(
		map(int fd),
		SOCKET_ADDR_CONST_CONNECT SOCKET_ADDR_TYPE addr,
		SOCKET_ADDR_LENGTH length);
int getpeername(
		map(int fd),
		SOCKET_ADDR_TYPE addr,
		SOCKET_ADDR_LENGTH * length);
int getsockname(
		map(int fd),
		SOCKET_ADDR_TYPE addr,
		SOCKET_ADDR_LENGTH * length);
int getsockopt(
		map(int fd),
		int level,
		int option,
		SOCKET_DATA_TYPE value,
		SOCKET_DATA_LENGTH * length);
int listen(
		map(int fd),
		int count);
SOCKET_SENDRECV_TYPE recv(
		map(int fd),
		SOCKET_DATA_TYPE data,
		SOCKET_DATA_LENGTH length,
		SOCKET_FLAGS_TYPE flags);
SOCKET_SENDRECV_TYPE recvfrom(
		map(int fd),
		SOCKET_DATA_TYPE data,
		SOCKET_DATA_LENGTH length,
		SOCKET_FLAGS_TYPE flags,
		SOCKET_ADDR_TYPE addr,
		SOCKET_ADDR_LENGTH *addrlength);
SOCKET_SENDRECV_TYPE recvmsg(
		map(int fd),
		struct msghdr *msg,
		SOCKET_FLAGS_TYPE flags);
SOCKET_SENDRECV_TYPE send(
		map(int fd),
		SOCKET_DATA_CONST SOCKET_DATA_TYPE data,
		SOCKET_DATA_LENGTH length,
		SOCKET_FLAGS_TYPE flags );
SOCKET_SENDRECV_TYPE sendmsg(
		map(int fd),
		SOCKET_MSG_CONST struct msghdr * msg,
		SOCKET_FLAGS_TYPE flags);
SOCKET_SENDRECV_TYPE sendto(
		map(int fd),
		SOCKET_DATA_CONST SOCKET_DATA_TYPE data,
		SOCKET_DATA_LENGTH length,
		SOCKET_FLAGS_TYPE flags,
		const SOCKET_ADDR_TYPE addr,
		SOCKET_ADDR_LENGTH addrlength );
int setsockopt(
		map(int fd),
		int level,
		int option,
		SOCKET_DATA_CONST SOCKET_DATA_TYPE value,
		SOCKET_DATA_LENGTH length);
int shutdown (
		map(int fd),
		int how);
int socket(
		int domain,
		int type,
		int protocol) : file_table;

not_supported {
	int socketpair (
			int domain,
			int type,
			int protocol,
			int *pair);
}


	/*
	Things we perhaps ought to support, but aren't in the
	current implementation
	*/
not_supported {
	#if defined(LINUX)
		int profil( char *buf, int buf_size, int offset, int scale );
	#elif defined(Solaris)
		void profil( unsigned short *buf, unsigned int buf_size, int offset, unsigned int scale);
	#elif defined(HPUX)
		void profil( const void *buf, unsigned int buf_size, unsigned int offset, int scale );
	#else
		void profil( short *buf, unsigned int buf_size, unsigned int offset, unsigned int scale );
	#endif

	int quotactl( char *path, int cmd, int id, char *addr );
	int getsysinfo( unsigned long op, char * buf, unsigned long nbytes, int *start, char *arg );
}

	/*
	Stuff having to do with message queues.  Probably won't support
	these unless they become a standard across all the platforms.
	*/
not_supported {
	int msgctl( int msgid, int cmd, struct msqid_ds *buf );
	int msgget( key_t key, int msgflg );
	int msgrcv(int qid, void *msgp, size_t msgsz, long msgtyp, int msgflg );
	int msgsnd( int msqid, void *msgp, size_t msgsz, int msgflg );
}

	/*
	Stuff having to do with semaphores.  Probably won't support
	these unless they become a standard across all the platforms.
	*/
not_supported {
	int semctl( int semid, int semnum, int cmd, void *arg );
	int semget( key_t key, int nsems, int semflag );
	int semop( int semid, struct sembuf *sops, unsigned int nsops );
}

	/* Stuff having to do with shared memory. */
not_supported {
	int shmctl( int shmid, int cmd, struct shmid_ds *buf );
	int shmdt( char * addr );
	int shmget( key_t key, size_t size, int flags );
	char * shmat( int shmid, char * shmaddr, int shmflg );
}

#endif /* not CLIP */
#endif /* REMOTE_SYSCALLS */

