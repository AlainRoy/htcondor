CMNT
CMNT Define the features used from syscall.tmpl.
CMNT Unlike libckpt, the syscall library uses
CMNT all of the features.
CMNT

#if DOES_REMOTE_SYSCALLS
	REMOTE_SYSCALLS = -DREMOTE_SYSCALLS
#else
	CLIP = -DCLIP
	REMOTE_SYSCALLS = -DREMOTE_SYSCALLS
#endif

#if DOES_SAVE_SIGSTATE
	SAVE_SIGSTATE = -DSAVE_SIGSTATE
	#if IS_DUX
		SIG_CKPT_OBJS = signals_support.o SIGPROCMASK.o SIGSUSPEND.o SIGACTION.o SIGNAL.o
	#else
		SIG_CKPT_OBJS = signals_support.o
	#endif
#endif

FILE_TABLE = -DFILE_TABLE
FILE_TABLE_OBJ = file_state.o file_types.o file_table_interf.o buffer_cache.o


#if IS_IRIX
/* This silliness is because gcc 2.7.2 on IRIX cannot
 * handle really large switches and/or functions, like 
 * stub_gen wants to make for senders.C and receivers.C.
 * So these options will cluster the stubs so there are
 * only STUB_CLUMP_SIZE stubs per function/switch statement.
**/
STUB_CLUMPS_FLAG = -DUSE_STUB_CLUMPS
STUB_CLUMP_SIZE = -s 33
#endif

/* We need to use dlopen() and dlsym() to extract on IRIX */
#if IS_IRIX
DL_EXTRACT = -DDL_EXTRACT
#endif

OS = OperatingSystem
CFLAGS = $(STD_C_FLAGS) $(DL_EXTRACT) $(FILE_TABLE) $(REMOTE_SYSCALLS)
C_PLUS_FLAGS = $(STD_C_PLUS_FLAGS) $(STUB_CLUMPS_FLAG) $(DL_EXTRACT) $(FILE_TABLE) $(REMOTE_SYSCALLS) $(SAVE_SIGSTATE)

#if DOES_CHECKPOINTING  /* ========= DOES CHECKPOINTING ============ */

#	if IS_HPUX
EXTRACT = FORK.o GETEUID.o GETPPID.o GETEGID.o SYSCALL.o __SYSCALL.o \
		  MMAP.o PIPE.o GETCWD.o GETLOGIN.o
#	elif IS_GLIBC_LINUX
EXTRACT = GETCWD.o MMAP.o SYSCALL.o GETEUID.o GETEGID.o GETPPID.o \
		FORK.o PIPE.o SIGACTION.o GETLOGIN.o SYSDEP.o
#	elif IS_I386_LINUX
EXTRACT = GETCWD.o MMAP.o SYSCALL.o __GETEUID.o __GETEGID.o __GETPPID.o \
		__FORK.o __PIPE.o __SIGACT.o ____SIG.o GETLOGIN.o \
		__PREV_FSTAT.o __PREV_LSTAT.o __PREV_STAT.o
#	elif IS_DUX
EXTRACT = FORK.o GETEUID.o GETPPID.o GETEGID.o GETCWD.o \
		  MMAP.o PIPE.o SYSCALL.o
#	elif IS_X86_SOLARIS251
EXTRACT = FORK.o SIGACTION.o GETEUID.o GETPPID.o GETEGID.o \
		  MMAP.o SYSCALL.o PIPE.o _SIGACTION.o TRUNCATE.o GETCWD.o \
		  i386_data.o SYSCONF.o GETLOGIN.o GETRUSAGE.o FSYNC.o
#	elif IS_X86_SOLARIS26
EXTRACT = FORK.o SIGACTION.o GETEUID.o GETPPID.o GETEGID.o \
		  MMAP.o SYSCALL.o PIPE.o _SIGACTION.o TRUNCATE.o \
		  GETCWD.o GETRUSAGE.o \
		  i386_data.o SYSCONF.o GETLOGIN.o LSEEK64.o FSYNC.o
#	elif IS_SUN4X_SOLARIS251
EXTRACT = FORK.o SIGACTION.o GETEUID.o GETPPID.o GETEGID.o \
		  MMAP.o SYSCALL.o PIPE.o _SIGACTION.o TRUNCATE.o GETCWD.o \
		  SYSCONF.o GETLOGIN.o GETRUSAGE.o FSYNC.o
#	elif IS_SUN4X_SOLARIS26
EXTRACT = FORK.o SIGACTION.o GETEUID.o GETPPID.o GETEGID.o \
		  MMAP.o SYSCALL.o PIPE.o _SIGACTION.o TRUNCATE.o \
		  GETCWD.o GETRUSAGE.o \
		  SYSCONF.o GETLOGIN.o LSEEK64.o FSYNC.o
#	elif IS_IRIX
EXTRACT = /* don't extract anything */
#	else
EXTRACT = FORK.o SIGACTION.o GETEUID.o GETPPID.o GETEGID.o GETWD.o \
		  MMAP.o PIPE.o GETLOGIN.o SYSCALL.o
#	endif

#else	/* =============  DOES NOT DO CHECKPOINTING ============*/

#	if IS_HPUX || IS_SOLARIS
EXTRACT = GETEUID.o GETEGID.o
#	else 
EXTRACT = GETEUID.o GETEGID.o GETWD.o
#	endif

#endif	/* ===============  CHECKPOINTING CONDITIONAL ============*/

#if IS_HPUX
PLATFORM_UTIL_OBJ = seteuid.o setegid.o
#endif

#if IS_IRIX62
DEP_OS = IRIX62
#elif IS_HPUX10
DEP_OS = HPUX10
#else
DEP_OS = OperatingSystem
#endif

#if IS_IRIX
SGI_CKPT = MMAP.MIPS.$(DEP_OS).o SYSCALL.MIPS.$(DEP_OS).o
#endif

#if !HAS_FLOCK
FLOCK_OBJ = flock.o
#endif

STUBS = switches.o switches.special.o getcwd.o

UTIL = \
	extern_path.o \
	remote_syscall.o \
	syscall_connect.o \
	senders.o \
	remote_startup.o \
	file_stream.o

NAME_TAB = syscall_numbers.o

SRC = \
	extern_path.c \
	receivers.epilogue \
	receivers.prologue \
	remote_startup.c \
	remote_syscall.C \
	senders.epilogue \
	senders.prologue \
	switches.prologue \
	switches.epilogue \
	switches.special.C \
	syscall.tmpl \
	syscall_connect.C \
	syscall_numbers.c \
	xfer_file.c \
	file_stream.c
	 
URL_OBJ = url_condor.o include_urls.o cbstp_url.o file_url.o http_url.o \
	cfilter_url.o filter_url.o mailto_url.o ftp_url.o

#if DOES_CHECKPOINTING
CKPT_OBJ = $(FILE_TABLE_OBJ)\
	image.o tmp_stack.o machdep.$(DEP_OS).o \
	syscall_mode.o fake_hooks.o $(LONGJMP) $(HP_CKPT) \
	$(SGI_CKPT) $(SIG_CKPT_OBJS) eprintf.o
#else
CKPT_OBJ = $(FILE_TABLE_OBJ) syscall_mode.o eprintf.o
#endif

#if DOES_COMPRESS_CKPT
#if IS_SUN4X_SOLARIS
COMPRESS_OBJ = malloc.o zimage.o _rem.o
#else
COMPRESS_OBJ = malloc.o zimage.o
#endif
STANDALONE_COMPRESS_LIB = libzckpt.a
COMPRESS_LIB = condor_syscall_zlib.a
#endif

SYSCALL_SUPPORT_OBJ=senders.o receivers.o syscall_mode.o syscall_connect.o remote_syscall.o syscall_numbers.o xfer_file.o

UTIL_OBJ =  $(FLOCK_OBJ) dprintf.o dprintf_config.o except.o update_rusage.o \
	condor_errlst.o internet.o $(PLATFORM_UTIL_OBJ) uids.o

CONDOR_TYPE_OBJ = sig_num.o proc.o open_flags.o fcntl_cmd.o

IO_OBJ = stream.o sock.o safe_sock.o buffers.o $(CONDOR_TYPE_OBJ) condor_rw.o reli_sock.o

SPECIAL_IO_OBJ = authentication.o
SPECIAL_IO_SRC = authentication.C

LIB_OBJ = $(EXTRACT) $(STUBS) $(UTIL) $(NAME_TAB) $(XDR_OBJ) $(UTIL_OBJ) \
	$(CKPT_OBJ) $(UTIL_EXTRACT) $(IO_OBJ) $(SPECIAL_IO_OBJ)

SIMPLE_OBJ = condor_rt0.o xfer_file.o c_plus_alloc.o \
	libckpt.a $(STANDALONE_COMPRESS_LIB)
SYSCALL_LIB = condor_syscall_lib.a

#if DOES_REMOTE_SYSCALLS
all_target($(SYSCALL_LIB) $(COMPRESS_LIB) receivers.o $(SIMPLE_OBJ) $(AIX_OBJ) syscall-list)
#else 
all_target($(SYSCALL_SUPPORT_OBJ))
#endif

stubs: switches.C senders.C receivers.C

ToUpper:
	ln -s ../condor_ckpt/ToUpper ToUpper

clean::
	rm -f ToUpper

uppercase_target($(SIMPLE_LIBC),geteuid.o,GETEUID.o,geteuid,GETEUID)
uppercase_target($(SIMPLE_LIBC),getppid.o,GETPPID.o,getppid,GETPPID)
uppercase_target($(SIMPLE_LIBC),getegid.o,GETEGID.o,getegid,GETEGID)
uppercase_target($(SIMPLE_LIBC),getlogin.o,GETLOGIN.o,getlogin,GETLOGIN)
uppercase_target($(SIMPLE_LIBC),fork.o,FORK.o,fork,FORK)
uppercase_target($(SIMPLE_LIBC),fsync.o,FSYNC.o,fsync,FSYNC)

#if IS_X86_SOLARIS
SIGACTION.o : ToUpper $(SIMPLE_LIBC)
	ar x $(SIMPLE_LIBC) sigaction.o
	./ToUpper sigaction.o sigaction.tmp.o sigaction SIGACTION
	./ToUpper sigaction.tmp.o SIGACTION.o _siguhandler _SIGUHANDLER
	rm -f sigaction.tmp.o sigaction.o

clean::
	rm -f SIGACTION.o

#elif !IS_ALPHA_OSF1
uppercase_target($(SIMPLE_LIBC),sigaction.o,SIGACTION.o,sigaction,SIGACTION)
#endif

#if IS_SOLARIS
uppercase_target($(SIMPLE_LIBC),_sigaction.o,_SIGACTION.o,sigaction,SIGACTION)

TRUNCATE.o : ToUpper $(SIMPLE_LIBC)
	ar x $(SIMPLE_LIBC) truncate.o
	./ToUpper truncate.o truncate.tmp.o ftruncate FTRUNCATE
	./ToUpper truncate.tmp.o TRUNCATE.o truncate TRUNCATE
	rm -f truncate.tmp.o truncate.o

clean::
	rm -f TRUNCATE.o

#endif

uppercase_target($(SIMPLE_LIBC),mmap.o,MMAP.o,mmap,MMAP)
uppercase_target($(SIMPLE_LIBC),pipe.o,PIPE.o,pipe,PIPE)

uppercase_target($(SIMPLE_LIBC),__geteuid.o,__GETEUID.o,__geteuid,__GETEUID)
uppercase_target($(SIMPLE_LIBC),__getegid.o,__GETEGID.o,__getegid,__GETEGID)
uppercase_target($(SIMPLE_LIBC),__getppid.o,__GETPPID.o,__getppid,__GETPPID)
uppercase_target($(SIMPLE_LIBC),__sigact.o,__SIGACT.o,__sigaction,__SIGACTION)
uppercase_target($(SIMPLE_LIBC),__fork.o,__FORK.o,__fork,__FORK)
uppercase_target($(SIMPLE_LIBC),__pipe.o,__PIPE.o,__pipe,__PIPE)
uppercase_target($(SIMPLE_LIBC),getcwd.o,GETCWD.o,getcwd,GETCWD)
uppercase_target($(SIMPLE_LIBC),getrusage.o,GETRUSAGE.o,getrusage,GETRUSAGE)

#if IS_SOLARIS26
uppercase_target($(SIMPLE_LIBC),lseek64.o,LSEEK64.o,lseek64,LSEEK64)
#endif


#if IS_I386_LINUX
____SIG.o : ToUpper $(SIMPLE_LIBC)
	ar x $(SIMPLE_LIBC) ____sig.o
	./ToUpper ____sig.o ____SIG_TMP.o ___sig_restore ___SIG_RESTORE
	./ToUpper ____SIG_TMP.o ____SIG.o ___masksig_restore ___MASKSIG_RESTORE
	rm -f ____sig.o ____SIG_TMP.o

uppercase_target($(SIMPLE_LIBC),__prev_stat.o,__PREV_STAT.o,stat,STAT)
uppercase_target($(SIMPLE_LIBC),__prev_lstat.o,__PREV_LSTAT.o,lstat,LSTAT)
uppercase_target($(SIMPLE_LIBC),__prev_fstat.o,__PREV_FSTAT.o,fstat,FSTAT)
#endif


#if IS_GLIBC_LINUX
uppercase_target($(SIMPLE_LIBC),syscall.o,SYSCALL_TMP.o,syscall,SYSCALL)
uppercase_target($(SIMPLE_LIBC),sysdep.o,SYSDEP.o,__syscall_error,__SYSCALL_ERROR)

SYSCALL.o: SYSCALL_TMP.o ToUpper
	./ToUpper SYSCALL_TMP.o SYSCALL.o __SYSCALL_error __syscall_error

clean::
	rm -f SYSCALL_TMP.o
#else
uppercase_target($(SIMPLE_LIBC),syscall.o,SYSCALL.o,syscall,SYSCALL)
uppercase_target($(SIMPLE_LIBC),__syscall.o,__SYSCALL.o,__syscall,__SYSCALL)
#endif


#if IS_X86_SOLARIS
i386_data.o : $(SIMPLE_LIBC)
	ar x $(SIMPLE_LIBC) i386_data.o
#endif

#if IS_SOLARIS
SYSCONF.o :  $(SIMPLE_LIBC)  ToUpper
	ar x    $(SIMPLE_LIBC)      sysconf.o 	  ; mv  sysconf.o  $(TMP_DIR)
	./ToUpper $(TMP_DIR)/sysconf.o   $(TMP_DIR)/SYSCONF.o   sysconf   SYSCONF
	./ToUpper $(TMP_DIR)/SYSCONF.o   SYSCONF.o SYSCONFig sysconfig
	rm -f $(TMP_DIR)/sysconf.o $(TMP_DIR)/SYSCONF.o
#endif

#if DOES_CHECKPOINTING || DOES_REMOTE_SYSCALLS
release_target( condor_rt0.o, $(RELEASE_DIR)/lib, OBJECT_MODE )
strip_copy_target( condor_rt0.o, $(STRIP_DIR)/lib, condor_rt0.o, OBJECT_MODE )
static_copy_target( condor_rt0.o, $(STATIC_DIR)/lib, condor_rt0.o, OBJECT_MODE )
#endif

#if IS_X86_SOLARIS || IS_GLIBC_LINUX
	library_target(libtmp.a,$(LIB_OBJ))

clean::
	rm -f condor_syscall_lib.a

condor_syscall_lib.a: libtmp.a ToUpper
#   if (IS_X86_SOLARIS)
	./ToUpper libtmp.a condor_syscall_lib.a __cerror __CERROR
#   else /* GLIBC Linux */
	./ToUpper libtmp.a condor_syscall_lib.a __syscall_error __SYSCALL_ERROR
#   endif /* Solaris */
#else /* Not GLIBC Linux or Intel Solaris */
	library_target(condor_syscall_lib.a,$(LIB_OBJ))
#endif

#if DOES_CHECKPOINTING || DOES_REMOTE_SYSCALLS
release_library(condor_syscall_lib.a,$(RELEASE_DIR)/lib)
strip_library(condor_syscall_lib.a,$(STRIP_DIR)/lib)
static_library(condor_syscall_lib.a,$(STATIC_DIR)/lib)
#endif

#if DOES_COMPRESS_CKPT
release_library($(COMPRESS_LIB),$(RELEASE_DIR)/lib)
strip_library($(COMPRESS_LIB),$(STRIP_DIR)/lib)
static_library($(COMPRESS_LIB),$(STATIC_DIR)/lib)
#endif

CMNT If no remote syscalls & no checkpointing support, then no need
CMNT to release anything into RELEASEDIR/lib, since we only do VANILLA jobs
#if (!DOES_CHECKPOINTING) && (!DOES_REMOTE_SYSCALLS)
release:
stripped:
static:
#endif

CPP = PreProcessCmd

#if IS_I386_LINUX
STUB_GEN_PLATFORM = GlibCFlag
#elif IS_SOLARIS251
STUB_GEN_PLATFORM = -DSolaris251
#elif IS_SOLARIS26
STUB_GEN_PLATFORM = -DSolaris26
#elif IS_HPUX10
STUB_GEN_PLATFORM = -DHPUX10
#elif IS_IRIX62
STUB_GEN_PLATFORM = -DIRIX62
#endif

STUB_GEN_FLAGS = $(STUB_GEN_PLATFORM) $(DL_EXTRACT) -D$(OS) \
	$(SAVE_SIGSTATE) $(FILE_TABLE) $(REMOTE_SYSCALLS) $(CLIP) -Wall

switches.C: syscall.tmpl switches.prologue stub_gen switches.epilogue
	$(CPP) -DSWITCH $(STUB_GEN_FLAGS) syscall.tmpl | \
	./stub_gen -mode switches  -p switches.prologue -e switches.epilogue \
	> switches.C

senders.C: syscall.tmpl stub_gen senders.prologue senders.epilogue
	$(CPP) -DSENDER $(STUB_GEN_FLAGS) syscall.tmpl | \
	./stub_gen -mode senders -p senders.prologue -e senders.epilogue \
	$(STUB_CLUMP_SIZE) > senders.C

receivers.C: syscall.tmpl stub_gen receivers.prologue receivers.epilogue pseudo_ops.h
	$(CPP) -DRECEIVER $(STUB_GEN_FLAGS) syscall.tmpl | \
	./stub_gen -mode receivers -p receivers.prologue \
	-e receivers.epilogue -n syscheck $(STUB_CLUMP_SIZE) > receivers.C

syscall-list: syscall.tmpl stub_gen 
	$(CPP) -DSWITCH $(CLIP) $(SAVE_SIGSTATE) $(FILE_TABLE) $(REMOTE_SYSCALLS) -D$(OS) syscall.tmpl | \
	./stub_gen -mode listcalls > syscall-list

clean::
	rm -f syscall-list

clean::
	rm -f lex.yy.c y.tab.c y.tab.h switches.C senders.C receivers.C *.o

depend_target($(SRC))

IMPORT_LINKS = ../../config/import_links
import(../condor_io,$(IO_OBJ))
import(../condor_io,$(SPECIAL_IO_SRC))
import(../condor_util_lib,$(UTIL_OBJ))
import(../condor_ckpt,condor_rt0.o)
import(../condor_ckpt,$(CKPT_OBJ))
import(../condor_ckpt,$(COMPRESS_OBJ))
import(../h,syscall_numbers.c)
import(../condor_util_lib, stub_gen)
import(../condor_shadow.V6, pseudo_ops.h)
import(../condor_ckpt,libckpt.a)
import(../condor_ckpt,c_plus_alloc.o)

authentication.o: authentication.C
	$(CPlusPlus) $(C_PLUS_FLAGS) -I../condor_io \
		-DSKIP_AUTHENTICATION -c authentication.C

#if DOES_COMPRESS_CKPT
$(COMPRESS_LIB) : $(SYSCALL_LIB) $(COMPRESS_OBJ)
	cp $(SYSCALL_LIB) $(COMPRESS_LIB)
	ar -d $(COMPRESS_LIB) image.o
	ar -r $(COMPRESS_LIB) $(COMPRESS_OBJ)
clean::
	rm -f $(COMPRESS_LIB) $(COMPRESS_OBJ)
import(../condor_ckpt,$(STANDALONE_COMPRESS_LIB))
#endif

html:
