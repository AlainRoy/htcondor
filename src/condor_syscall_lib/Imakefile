#if !DOES_REMOTE_SYSCALLS
CLIP = -DCLIP
#endif

OS = OperatingSystem
CFLAGS = $(STD_C_FLAGS) -DNEW_PROC
C_PLUS_FLAGS = $(STD_C_PLUS_FLAGS)

#if DOES_CHECKPOINTING  /* ========= DOES CHECKPOINTING ============ */

#	if IS_SPARC_SUNOS41
EXTRACT = FORK.o KILL.o GETEUID.o GETPPID.o GETEGID.o GETWD.o \
		  MMAP.o PIPE.o
#	elif IS_R6000_AIX32
/* Don't extract anything */
#	else
EXTRACT = FORK.o KILL.o SIGACTION.o GETEUID.o GETPPID.o GETEGID.o GETWD.o \
		  MMAP.o PIPE.o
#	endif

#else	/* =============  DOES NOT DO CHECKPOINTING ============*/

#	if IS_HPPAR_HPUX9
EXTRACT = GETEUID.o GETEGID.o
#	elif IS_R6000_AIX32
/* Don't extract anything */
#	else 
EXTRACT = GETEUID.o GETEGID.o GETWD.o
#	endif

#endif	/* ===============  CHECKPOINTING CONDITIONAL ============*/

STUBS = switches.o switches.special.o
UTIL =	remote_syscall.o syscall_connect.o senders.o remote_startup.o
NAME_TAB = syscall_numbers.o

SRC = \
	ToUpper.c \
	extern_path.c \
	receivers.epilogue \
	receivers.prologue \
	remote_startup.c \
	remote_syscall.c \
	senders.epilogue \
	senders.prologue \
	stub_gen_lex.l \
	stub_gen_yacc.y \
	switches.prologue \
	switches.special.c \
	syscall.tmpl \
	syscall_connect.c \
	syscall_numbers.c \
	xfer_file.c

#if IS_ALPHA_OSF1
XDR_STATFS_OBJ = xdr_statfs.OSF1.o
#else
XDR_STATFS_OBJ = xdr_statfs.GEN.o
#endif

XDR_OBJ = \
 	xdr_rusage.o \
 	xdr_proc.o \
	xdr_stat.o \
 	$(XDR_STATFS_OBJ) \
 	xdr_timeval.o \
 	xdr_timezone.o \
 	xdr_rlimit.o

#if 0
 	xdr_utsname.o
#endif

#if IS_R6000_AIX32
LONGJMP = _longjmp.AIX32.o
#endif

#if DOES_CHECKPOINTING
CKPT_OBJ =	file_state.o image.o tmp_stack.o machdep.$(OS).o \
			syscall_mode.o $(LONGJMP)
#else
CKPT_OBJ = syscall_mode.o
#endif

#if IS_R6000_AIX32
AIX_OBJ = $(LIB_DIR)/syscall.shr.o $(LIB_DIR)/syscall.exp $(LIB_DIR)/libfort.a
#endif

UTIL_OBJ =  dprintf.o dprintf_config.o except.o update_rusage.o \
			condor_errlst.o

LIB_OBJ = $(EXTRACT) $(STUBS) $(UTIL) $(NAME_TAB) $(XDR_OBJ) $(UTIL_OBJ) \
		$(CKPT_OBJ)

SIMPLE_OBJ = $(LIB_DIR)/condor_rt0.o extern_path.o xfer_file.o
SYSCALL_LIB = $(LIB_DIR)/condor_syscall_lib.a

all_target($(SYSCALL_LIB) receivers.c $(SIMPLE_OBJ) $(AIX_OBJ))
stubs: switches.c senders.c receivers.c

uppercase_target($(SIMPLE_LIBC),geteuid.o,GETEUID.o,geteuid,GETEUID)
uppercase_target($(SIMPLE_LIBC),getppid.o,GETPPID.o,getppid,GETPPID)
uppercase_target($(SIMPLE_LIBC),getegid.o,GETEGID.o,getegid,GETEGID)
uppercase_target($(SIMPLE_LIBC),getwd.o,GETWD.o,getwd,GETWD)
uppercase_target($(SIMPLE_LIBC),fork.o,FORK.o,fork,FORK)
uppercase_target($(SIMPLE_LIBC),kill.o,KILL.o,kill,KILL)
uppercase_target($(SIMPLE_LIBC),sigaction.o,SIGACTION.o,sigaction,SIGACTION)
uppercase_target($(SIMPLE_LIBC),mmap.o,MMAP.o,mmap,MMAP)
uppercase_target($(SIMPLE_LIBC),pipe.o,PIPE.o,pipe,PIPE)

CMNT
CMNT Create a replacement for crt0.o to be linked with condor programs.
CMNT N.B. This is done differently than other objects in that we start out
CMNT with a copy of crt0.o, and change the name of "main" to "MAIN".
CMNT
#if IS_HPPAR_HPUX9
condor_rt0.o: Crt0 ToUpper
	ToUpper Crt0 tmp1 _start  _START
	ToUpper tmp1 tmp2 __text_START __text_start 
	ToUpper tmp2 condor_rt0.o __data_START __data_start
	rm -f tmp1 tmp2
clean::
	rm -f condor_rt0.o
#else
condor_rt0.o: Crt0 ToUpper
	ToUpper Crt0 condor_rt0.o main  MAIN
clean::
	rm -f condor_rt0.o
#endif

release_target( condor_rt0.o, $(RELEASE_DIR)/lib, OBJECT_MODE )


library_target(condor_syscall_lib.a,$(LIB_OBJ))
release_library(condor_syscall_lib.a,$(RELEASE_DIR)/lib)

program_target(ToUpper,ToUpper.o,$(NULL))
release_target(ToUpper,$(RELEASE_DIR)/bin,EXECUTABLE_MODE)

#if IS_ALPHA_OSF1
CPP = /usr/ucb/cpp
#else
CPP = ansi_cpp
#endif

switches.c: syscall.tmpl switches.prologue stub_gen
	$(CPP) -DSWITCH $(CLIP) -D$(OS) < syscall.tmpl | \
	stub_gen -mode switches  -p switches.prologue \
	> switches.c

senders.c: syscall.tmpl stub_gen senders.prologue senders.epilogue
	$(CPP) -DSENDER $(CLIP) -D$(OS) < syscall.tmpl | \
	stub_gen -mode senders -p senders.prologue -e senders.epilogue \
	> senders.c

receivers.c: syscall.tmpl stub_gen receivers.prologue receivers.epilogue
	$(CPP) -DRECEIVER $(CLIP) -D$(OS) < syscall.tmpl | \
	stub_gen -mode receivers -p receivers.prologue -e receivers.epilogue \
	> receivers.c

lex.yy.c: stub_gen_lex.l scanner.h y.tab.h
	lex stub_gen_lex.l

y.tab.c: stub_gen_yacc.y scanner.h
	yacc -d stub_gen_yacc.y


#if IS_R6000_AIX32
CMNT
CMNT Provide the syscall() routine.
CMNT Imports: all system calls from /unix
CMNT Exports: syscall() and CondorErrno
CMNT
syscall.shr.o: syscall.o syscall.exp
	ld -o syscall.shr.o \
		-bM:SRE -T512 \
		-bE:syscall.exp \
		-bI:$(SYSCALLS_EXP) \
		-H8 \
		syscall.o
clean::
	rm -f syscall.shr.o syscall.o

release_target( syscall.shr.o, $(LIB_DIR), OBJECT_MODE)
release_target( syscall.exp, $(LIB_DIR), OBJECT_MODE)

#
# The aix fortran library libxlf.a defines a getenv() routine which takes 2
# arguments, the name of the environment variable, and buffer in which to
# put the associated value.
#
# The aix C library libc.a defines a getenv routine which takes 1 argument,
# the name of the environment variable, and it returns a pointer to the
# associated value.
#
# Condor programs need to be linked with the condor libraries, which will
# end up calling getenv(), and expecting the C version.  We therefore
# supply our own C version, so that we can get it linked in before the
# fortran version gets linked.
#
# Of course this will break any fortran programs which call getenv and expect
# the fortran version!  If some AIXpert knows how to fix this, I would be
# very happy to learn about it. -- mike
#
library_target(libfort.a,C_getenv.o)
release_library(libfort.a,$(RELEASE_DIR)/lib)
#endif /* AIX */


clean::
	rm -f lex.yy.c y.tab.c y.tab.h switches.c senders.c receivers.c *.o

depend_target($(SRC))
program_target(stub_gen,y.tab.o lex.yy.o,$(NULL))


IMPORT_LINKS = ../../config/import_links
import(../condor_xdr_lib,$(XDR_OBJ))
import(../condor_util_lib,$(UTIL_OBJ))
import(../condor_ckpt,$(CKPT_OBJ))
import(../h,syscall_numbers.c)
