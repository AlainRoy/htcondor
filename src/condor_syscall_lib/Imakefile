#if DOES_REMOTE_SYSCALLS
SEND_OBJ = send.o
SETPRIORITY_OBJ = setpriority.o
#else
CLIP = -DCLIP
#endif

OS = OperatingSystem
CFLAGS = $(STD_C_FLAGS) -DNEW_PROC
C_PLUS_FLAGS = $(STD_C_PLUS_FLAGS)

#if DOES_SAVE_SIGSTATE
SAVE_SIGSTATE = -DSAVE_SIGSTATE
#if IS_SPARC_SUNOS41
SIG_CKPT_OBJS = signals_support.o SIGVEC.o _SIGVEC.o
#elif IS_ALPHA_OSF1
SIG_CKPT_OBJS = signals_support.o SIGPROCMASK.o SIGSUSPEND.o \
	SIGACTION.o SIGNAL.o
#elif IS_MIPS_ULTRIX43
SIG_CKPT_OBJS = signals_support.o SIGVEC.o SIGPROCMASK.o SIGSUSPEND.o SIGNAL.o
#else
SIG_CKPT_OBJS = signals_support.o
#endif
#endif

#if DOES_CHECKPOINTING  /* ========= DOES CHECKPOINTING ============ */

#	if IS_SPARC_SUNOS41
EXTRACT = FORK.o KILL.o GETEUID.o GETPPID.o GETEGID.o GETWD.o \
		  MMAP.o PIPE.o GETLOGIN.o
#	elif IS_R6000_AIX32
/* Don't extract anything */
#	elif IS_HPPAR_HPUX9
EXTRACT = FORK.o KILL.o GETEUID.o GETPPID.o GETEGID.o  \
		  MMAP.o PIPE.o GETWD.o GETLOGIN.o
#	elif IS_I386_LINUX
EXTRACT = GETWD.o MMAP.o SYSCALL.o __GETEUID.o __GETEGID.o __GETPPID.o \
		__FORK.o __PIPE.o __SIGACT.o ____SIG.o ____SIG2.o GETLOGIN.o \
		__PREV_FSTAT.o __PREV_LSTAT.o __PREV_STAT.o
#	elif IS_ALPHA_OSF1
EXTRACT = FORK.o KILL.o GETEUID.o GETPPID.o GETEGID.o GETWD.o \
		  MMAP.o PIPE.o 
#	elif (IS_SUN4M_SOLARIS) || (IS_SUN4M_SOLARIS251) || (IS_X86_SOLARIS)
EXTRACT = FORK.o KILL.o SIGACTION.o GETEUID.o GETPPID.o GETEGID.o \
		  MMAP.o SYSCALL.o PIPE.o _SIGACTION.o TRUNCATE.o GETCWD.o \
		  SYSCONF.o	GETLOGIN.o
#	elif (IS_X86_SOLARIS25)
EXTRACT = FORK.o KILL.o SIGACTION.o GETEUID.o GETPPID.o GETEGID.o \
		  MMAP.o SYSCALL.o PIPE.o _SIGACTION.o TRUNCATE.o GETCWD.o \
		  i386_data.o SYSCONF.o GETLOGIN.o

#	elif IS_SGI_IRIX53
EXTRACT = /* don't extract anything */
#	else
EXTRACT = FORK.o KILL.o SIGACTION.o GETEUID.o GETPPID.o GETEGID.o GETWD.o \
		  MMAP.o PIPE.o GETLOGIN.o
#	endif

#else	/* =============  DOES NOT DO CHECKPOINTING ============*/

#	if IS_HPPAR_HPUX9
EXTRACT = GETEUID.o GETEGID.o
#	elif IS_R6000_AIX32
/* Don't extract anything */
#     elif (IS_X86_SOLARIS) || (IS_SUN4M_SOLARIS) || (IS_SUN4M_SOLARIS251) || (IS_X86_SOLARIS25)
EXTRACT = GETEUID.o GETEGID.o
#	else 
EXTRACT = GETEUID.o GETEGID.o GETWD.o
#	endif

#endif	/* ===============  CHECKPOINTING CONDITIONAL ============*/

#if IS_HPPAR_HPUX9
/* UTIL_EXTRACT = GETWD.o */
HP_SPECIFIC_FILES = seteuid.o setegid.o
#if !IS_HPPAR_HPUX10
HP_CKPT = get_reginfo.HPUX.o
#endif   /* of !IS_HPPAR_HPUX10 */
#endif   /* of IS_HPPAR_HPUX9   */

#if IS_SGI_IRIX62
DEP_OS = IRIX62
#elif IS_HPPAR_HPUX10
DEP_OS = HPUX10
#else
DEP_OS = OperatingSystem
#endif

#if IS_SGI_IRIX53 
SGI_CKPT = MMAP.MIPS.$(DEP_OS).o SYSCALL.MIPS.$(DEP_OS).o
#endif

#if !HAS_FLOCK
FLOCK_OBJ = flock.o
#endif

STUBS = switches.o switches.special.o $(SEND_OBJ) $(SETPRIORITY_OBJ)
UTIL = \
	remote_syscall.o \
	syscall_connect.o \
	senders.o \
	remote_startup.o \
	file_stream.o

NAME_TAB = syscall_numbers.o

SRC = \
	extern_path.c \
	receivers.epilogue \
	receivers.prologue \
	remote_startup.c \
	remote_syscall.c \
	senders.epilogue \
	senders.prologue \
	switches.prologue \
	switches.special.c \
	syscall.tmpl \
	syscall_connect.c \
	syscall_numbers.c \
	xfer_file.c \
	file_stream.c

#if IS_ALPHA_OSF1
XDR_STATFS_OBJ = xdr_statfs.OSF1.o
#else
XDR_STATFS_OBJ = xdr_statfs.GEN.o
#endif

XDR_OBJ = \
	xdr_rusage.o \
	xdr_proc.o \
	xdr_strings.o \
	xdr_stat.o \
	$(XDR_STATFS_OBJ) \
	xdr_timeval.o \
	xdr_timezone.o \
	xdr_rlimit.o \
	xdr_startup_info.o \
	xdr_open_flags_t.o \
	xdr_sig_num.o

#if IS_R6000_AIX32
LONGJMP = _longjmp.AIX32.o
#endif

URL_OBJ = url_condor.o include_urls.o cbstp_url.o file_url.o http_url.o \
	cfilter_url.o filter_url.o mailto_url.o ftp_url.o

#if DOES_CHECKPOINTING
CKPT_OBJ =	$(FLOCK_OBJ) file_state.o image.o tmp_stack.o machdep.$(DEP_OS).o \
	syscall_mode.o fake_hooks.o $(LONGJMP) $(HP_CKPT) \
	$(SGI_CKPT) $(SIG_CKPT_OBJS) $(URL_OBJ)
#else
CKPT_OBJ = syscall_mode.o
#endif

#if IS_R6000_AIX32
AIX_OBJ = $(LIB_DIR)/syscall.shr.o $(LIB_DIR)/syscall.exp $(LIB_DIR)/libfort.a
#endif

SYSCALL_SUPPORT_OBJ=senders.o receivers.c syscall_mode.o syscall_connect.o remote_syscall.o syscall_numbers.o xfer_file.o

UTIL_OBJ =  dprintf.o dprintf_config.o except.o update_rusage.o \
			condor_errlst.o $(HP_SPECIFIC_FILES)

LIB_OBJ = $(EXTRACT) $(STUBS) $(UTIL) $(NAME_TAB) $(XDR_OBJ) $(UTIL_OBJ) \
		$(CKPT_OBJ) $(UTIL_EXTRACT) $(HP_UTIL)

SIMPLE_OBJ = $(LIB_DIR)/condor_rt0.o extern_path.o xfer_file.o 
SYSCALL_LIB = $(LIB_DIR)/condor_syscall_lib.a

#if DOES_REMOTE_SYSCALLS
all_target($(SYSCALL_LIB) receivers.c $(SIMPLE_OBJ) $(AIX_OBJ))
#else 
all_target($(SYSCALL_SUPPORT_OBJ))
#endif

stubs: switches.c senders.c receivers.c

ToUpper:
	ln -s ../condor_ckpt/ToUpper ToUpper

uppercase_target($(SIMPLE_LIBC),geteuid.o,GETEUID.o,geteuid,GETEUID)
uppercase_target($(SIMPLE_LIBC),getppid.o,GETPPID.o,getppid,GETPPID)
uppercase_target($(SIMPLE_LIBC),getegid.o,GETEGID.o,getegid,GETEGID)
uppercase_target($(SIMPLE_LIBC),getlogin.o,GETLOGIN.o,getlogin,GETLOGIN)
uppercase_target($(SIMPLE_LIBC),fork.o,FORK.o,fork,FORK)
uppercase_target($(SIMPLE_LIBC),kill.o,KILL.o,kill,KILL)
#if !IS_ALPHA_OSF1
uppercase_target($(SIMPLE_LIBC),sigaction.o,SIGACTION.o,sigaction,SIGACTION)
#endif
#if (IS_SUN4M_SOLARIS) || (IS_X86_SOLARIS) || (IS_SUN4M_SOLARIS251) || (IS_X86_SOLARIS25)
uppercase_target($(SIMPLE_LIBC),syscall.o,SYSCALL.o,syscall,SYSCALL)
uppercase_target($(SIMPLE_LIBC),_sigaction.o,_SIGACTION.o,sigaction,SIGACTION)
uppercase_target($(SIMPLE_LIBC),truncate.o,TRUNCATE.o,ftruncate,FTRUNCATE)
uppercase_target($(SIMPLE_LIBC),getcwd.o,GETCWD.o,getcwd,GETCWD)
#endif
uppercase_target($(SIMPLE_LIBC),mmap.o,MMAP.o,mmap,MMAP)
uppercase_target($(SIMPLE_LIBC),pipe.o,PIPE.o,pipe,PIPE)

uppercase_target($(SIMPLE_LIBC),__geteuid.o,__GETEUID.o,__geteuid,__GETEUID)
uppercase_target($(SIMPLE_LIBC),__getegid.o,__GETEGID.o,__getegid,__GETEGID)
uppercase_target($(SIMPLE_LIBC),__getppid.o,__GETPPID.o,__getppid,__GETPPID)
uppercase_target($(SIMPLE_LIBC),__kill.o,__KILL.o,__kill,__KILL)
uppercase_target($(SIMPLE_LIBC),__sigact.o,__SIGACT.o,__sigaction,__SIGACTION)
uppercase_target($(SIMPLE_LIBC),__fork.o,__FORK.o,__fork,__FORK)
uppercase_target($(SIMPLE_LIBC),__pipe.o,__PIPE.o,__pipe,__PIPE)
uppercase_target($(SIMPLE_LIBC),____sig.o,____SIG.o,___sig_restore,___SIG_RESTORE)
uppercase_target($(SIMPLE_LIBC),____sig.o,____SIG2.o,___masksig_restore,___MASKSIG_RESTORE)

#if (IS_I386_LINUX)
uppercase_target($(SIMPLE_LIBC),syscall.o,SYSCALL.o,syscall,SYSCALL)
uppercase_target($(SIMPLE_LIBC),__prev_stat.o,__PREV_STAT.o,stat,STAT)
uppercase_target($(SIMPLE_LIBC),__prev_lstat.o,__PREV_LSTAT.o,lstat,LSTAT)
uppercase_target($(SIMPLE_LIBC),__prev_fstat.o,__PREV_FSTAT.o,fstat,FSTAT)
#endif

#if (IS_X86_SOLARIS25)
i386_data.o : $(SIMPLE_LIBC)
	ar x $(SIMPLE_LIBC) i386_data.o
#endif

#if (IS_SUN4M_SOLARIS) || (IS_X86_SOLARIS) || (IS_SUN4M_SOLARIS251) || (IS_X86_SOLARIS25)
SYSCONF.o :  $(SIMPLE_LIBC)  ToUpper
	ar x    $(SIMPLE_LIBC)      sysconf.o 	  ; mv  sysconf.o  $(TMP_DIR)
	ToUpper $(TMP_DIR)/sysconf.o   $(TMP_DIR)/SYSCONF.o   sysconf   SYSCONF
	ToUpper $(TMP_DIR)/SYSCONF.o   SYSCONF.o SYSCONFig sysconfig
	rm -f $(TMP_DIR)/sysconf.o $(TMP_DIR)/SYSCONF.o
#endif

#if (DOES_CHECKPOINTING) || (DOES_REMOTE_SYSCALLS)
release_target( condor_rt0.o, $(RELEASE_DIR)/lib, OBJECT_MODE )
#endif

library_target(condor_syscall_lib.a,$(LIB_OBJ))

#if (DOES_CHECKPOINTING) || (DOES_REMOTE_SYSCALLS)
release_library(condor_syscall_lib.a,$(RELEASE_DIR)/lib)
#endif

CMNT If no remote syscalls & no checkpointing support, then no need
CMNT to release anything into RELEASEDIR/lib, since we only do VANILLA jobs
#if (!DOES_CHECKPOINTING) && (!DOES_REMOTE_SYSCALLS)
release:
#endif

CPP = PreProcessCmd


#if IS_I386_LINUX
switches.c: syscall.tmpl switches.prologue stub_gen switches.linux.h
	$(CPP) -DSWITCH $(CLIP) $(SAVE_SIGSTATE) -D$(OS) syscall.tmpl | \
	stub_gen -mode switches  -p switches.prologue \
	> switches.c
#elif IS_SUN4M_SOLARIS251 || IS_X86_SOLARIS25
switches.c: syscall.tmpl switches.prologue stub_gen
	$(CPP) -DSWITCH $(CLIP) $(SAVE_SIGSTATE) -D$(OS) -DSolaris251 \
	syscall.tmpl | stub_gen -mode switches  -p switches.prologue \
	> switches.c
#else
switches.c: syscall.tmpl switches.prologue stub_gen
	$(CPP) -DSWITCH $(CLIP) $(SAVE_SIGSTATE) -D$(OS) syscall.tmpl | \
	stub_gen -mode switches  -p switches.prologue \
	> switches.c
#endif

senders.c: syscall.tmpl stub_gen senders.prologue senders.epilogue
	$(CPP) -DSENDER $(CLIP) $(SAVE_SIGSTATE) -D$(OS) syscall.tmpl | \
	stub_gen -mode senders -p senders.prologue -e senders.epilogue \
	> senders.c

#if IS_SGI_IRIX53 
CMNT
CMNT Bypass a bug in gcc.
CMNT
senders.o: senders.c
	cc -I../h -I../condor_includes -I../condor_c++_util -DSGI -D$(OS) -DNFSFIX -DNDBM -D_BSD_COMPAT -g -DNEW_PROC -c senders.c
#endif

receivers.c: syscall.tmpl stub_gen receivers.prologue receivers.epilogue
	$(CPP) -DRECEIVER $(CLIP) $(SAVE_SIGSTATE) -D$(OS) syscall.tmpl | \
	stub_gen -mode receivers -p receivers.prologue -e receivers.epilogue \
	> receivers.c



#if IS_R6000_AIX32
CMNT
CMNT Provide the syscall() routine.
CMNT Imports: all system calls from /unix
CMNT Exports: syscall() and CondorErrno
CMNT
syscall.shr.o: syscall.o syscall.exp
	ld -o syscall.shr.o \
		-bM:SRE -T512 \
		-bE:syscall.exp \
		-bI:$(SYSCALLS_EXP) \
		-H8 \
		syscall.o
clean::
	rm -f syscall.shr.o syscall.o

release_target( syscall.shr.o, $(LIB_DIR), OBJECT_MODE)
release_target( syscall.exp, $(LIB_DIR), OBJECT_MODE)

#
# The aix fortran library libxlf.a defines a getenv() routine which takes 2
# arguments, the name of the environment variable, and buffer in which to
# put the associated value.
#
# The aix C library libc.a defines a getenv routine which takes 1 argument,
# the name of the environment variable, and it returns a pointer to the
# associated value.
#
# Condor programs need to be linked with the condor libraries, which will
# end up calling getenv(), and expecting the C version.  We therefore
# supply our own C version, so that we can get it linked in before the
# fortran version gets linked.
#
# Of course this will break any fortran programs which call getenv and expect
# the fortran version!  If some AIXpert knows how to fix this, I would be
# very happy to learn about it. -- mike
#
library_target(libfort.a,C_getenv.o)
release_library(libfort.a,$(RELEASE_DIR)/lib)
#endif /* AIX */

#if HAS_GETWD
uppercase_target($(SIMPLE_LIBC),getwd.o,GETWD.o,getwd,GETWD)
#else
uppercase_target(../condor_util_lib/util_lib.a,getwd.o,GETWD.o,getwd,GETWD)
#endif

clean::
	rm -f lex.yy.c y.tab.c y.tab.h switches.c senders.c receivers.c *.o

depend_target($(SRC))


IMPORT_LINKS = ../../config/import_links
import(../condor_xdr_lib,$(XDR_OBJ))
import(../condor_util_lib,$(UTIL_OBJ))
import(../condor_ckpt,condor_rt0.o)
import(../condor_ckpt,$(CKPT_OBJ))
import(../h,syscall_numbers.c)
import(../condor_util_lib, stub_gen)
