#if !defined(OSF1) || defined(__GNUC__)
#	define _POSIX_SOURCE
#endif

#if defined(Solaris)
#	include "_condor_fix_types.h"
#       include <sys/statfs.h>
#endif

#if defined(HPUX9) || defined(Solaris)
#	define sync		__hide_sync
#endif
#include "condor_common.h"
#if	defined(HPUX9) || defined(Solaris)
#	undef sync
#endif

#include "condor_debug.h"
#include "xdr_lib.h"
#include "condor_rsc.h"
#include "condor_xdr.h"
#include "condor_sys.h"
#include "condor_jobqueue.h"
#include "condor_constants.h"
#include "startup.h"
#include "condor_fix_assert.h"

#if defined(OSF1) && defined(__GNUC__ )
#	include "condor_fdset.h"
#endif

#include <sys/types.h>
#define MODE_T unsigned int	/* use 32 bits on all platforms */

#include <sys/stat.h>
#include "_condor_fix_resource.h"
#include <sys/utsname.h>

#if defined(SUNOS41)
#	include "condor_fdset.h"
#endif

#if defined(ULTRIX42) || defined(OSF1)
#	include <sys/param.h>
#	include <sys/mount.h>
#elif defined(ULTRIX43)
#   include <errno.h>
#	include <sys/param.h>
#	include "condor_fix_timeval.h"
#   include <nfs/nfs.h>
#else 
#	include <sys/mount.h>
#endif

#if defined(HPUX9)
#   include <time.h>
#   include <rpc/rpc.h>
#   include <errno.h>
#   include <nfs/export.h>
#   include <nfs/nfs.h> /* for definition of fhandle_t */
#   include <sys/vfs.h>      /* for struct statfs */
#	include <sys/signal.h>
#endif

#if defined(LINUX)
#	include <signal.h>
#	include <sys/vfs.h>
#	include <linux/nfs.h>
#	include <linux/ipc.h>
	typedef struct fhandle fhandle_t;
#endif

#if defined(OSF1)
#	define _AES_SOURCE
#	include <sys/poll.h>
#endif

#if defined(SUNOS41)
#	include <sys/poll.h>
#endif

#if defined(AIX32)
	struct fsid {
		long    val[2];
	};
	typedef struct fsid fsid_t;
#	include <sys/statfs.h>		 /* for struct statfs */
#endif

#if defined(IRIX53)
#	include <sys/statfs.h>
#	include <signal.h>
#endif

#if defined(SUNOS41)
#	include <sys/vfs.h>
#endif

#include "../condor_syscall_lib/syscall_param_sizes.h"

static char *_FileName_ = __FILE__;     /* Used by EXCEPT (see except.h)    */

extern XDR *xdr_syscall;

#if defined(SYSCALL_DEBUG)
	extern char *SyscallLabel;
#endif

typedef int open_flags_t;

int CONDOR_NotSupported( int num, ... );
int CONDOR_Ignored( int num, ... );

#if !defined(PVM_RECEIVE)
int
do_REMOTE_syscall()
{
	int condor_sysnum;
	int	rval;
	xdr_syscall->x_op = XDR_DECODE;

	ASSERT( xdrrec_skiprecord(xdr_syscall) );
	ASSERT( xdr_int(xdr_syscall, &condor_sysnum) );

#if defined(SYSCALL_DEBUG)
	sprintf( SyscallLabel, "%-6d", condor_sysnum );
#endif

	dprintf(D_SYSCALLS,
		"Got request for syscall %d <%s>\n",
		condor_sysnum, _condor_syscall_name(condor_sysnum)
	);
	switch( condor_sysnum ) {
#else

#include "joblist.h"
extern struct tagJobList	*JobList;

int
do_REMOTE_syscall(xdr, jobnum, process)
XDR 	*xdr;
int		jobnum;
int		process;
{
	int condor_sysnum;
	int rval;
	int	read_ok;
	extern int SyscallSockClosed;

	xdr_syscall->x_op = XDR_DECODE;

	SyscallSockClosed = FALSE;
	read_ok = xdrrec_skiprecord(xdr_syscall);
	read_ok &= xdr_int(xdr_syscall, &condor_sysnum);

	if( !read_ok ) {
		ASSERT( SyscallSockClosed );
		dprintf( D_ALWAYS, 
		"Failed to get syscall_code for job %d, proc %d removing..\n",
				jobnum, process);

		RemoveProc( jobnum, process );
		return -1;
	}

	dprintf( D_SYSCALLS, "Shadow: got request for syscall %d <%s>\n",
			condor_sysnum, _condor_syscall_name(condor_sysnum) );

	switch( condor_sysnum ) {
#endif

#if defined( IRIX53 )
	case CONDOR_fstat:
	  {
		int fd;
		struct stat *buf;
		int terrno;

		assert( xdr_int(xdr_syscall,&fd) );
		buf = (struct stat *)malloc( (unsigned)STAT_SIZE );

		errno = 0;
		rval = fstat( fd, buf );
		terrno = errno;
		dprintf( D_SYSCALLS, "\trval = %d, errno = %d\n", rval, terrno );

		xdr_syscall->x_op = XDR_ENCODE;
		assert( xdr_int(xdr_syscall,&rval) );
		if( rval < 0 ) {
			assert( xdr_int(xdr_syscall,&terrno) );
		}
		if( rval >= 0 ) {
			assert( xdr_stat(xdr_syscall,buf) );
		}
		free( (char *)buf );
		assert( xdrrec_endofrecord(xdr_syscall,TRUE) );;
		return 0;
	}
#endif

#if defined( Solaris )
	case CONDOR_ftruncate:
	  {
		int fd;
		off_t length;
		int terrno;

		assert( xdr_int(xdr_syscall,&fd) );
		dprintf( D_SYSCALLS, "	fd = %d\n", fd );
		assert( xdr_off_t(xdr_syscall,&length) );
		dprintf( D_SYSCALLS, "	length = %d\n", length );

		errno = 0;
		rval = ftruncate( fd, length );
		terrno = errno;
		dprintf( D_SYSCALLS, "\trval = %d, errno = %d\n", rval, terrno );

		xdr_syscall->x_op = XDR_ENCODE;
		assert( xdr_int(xdr_syscall,&rval) );
		if( rval < 0 ) {
			assert( xdr_int(xdr_syscall,&terrno) );
		}
		assert( xdrrec_endofrecord(xdr_syscall,TRUE) );;
		return 0;
	}
#endif
