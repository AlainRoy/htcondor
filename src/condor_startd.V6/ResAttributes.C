/***************************Copyright-DO-NOT-REMOVE-THIS-LINE**
 * CONDOR Copyright Notice
 *
 * See LICENSE.TXT for additional notices and disclaimers.
 *
 * Copyright (c)1990-1998 CONDOR Team, Computer Sciences Department, 
 * University of Wisconsin-Madison, Madison, WI.  All Rights Reserved.  
 * No use of the CONDOR Software Program Source Code is authorized 
 * without the express consent of the CONDOR Team.  For more information 
 * contact: CONDOR Team, Attention: Professor Miron Livny, 
 * 7367 Computer Sciences, 1210 W. Dayton St., Madison, WI 53706-1685, 
 * (608) 262-0856 or miron@cs.wisc.edu.
 *
 * U.S. Government Rights Restrictions: Use, duplication, or disclosure 
 * by the U.S. Government is subject to restrictions as set forth in 
 * subparagraph (c)(1)(ii) of The Rights in Technical Data and Computer 
 * Software clause at DFARS 252.227-7013 or subparagraphs (c)(1) and 
 * (2) of Commercial Computer Software-Restricted Rights at 48 CFR 
 * 52.227-19, as applicable, CONDOR Team, Attention: Professor Miron 
 * Livny, 7367 Computer Sciences, 1210 W. Dayton St., Madison, 
 * WI 53706-1685, (608) 262-0856 or miron@cs.wisc.edu.
****************************Copyright-DO-NOT-REMOVE-THIS-LINE**/
#include "startd.h"
static char *_FileName_ = __FILE__;

MachAttributes::MachAttributes()
{
#if !defined(WIN32)
	m_afs_info = new AFS_Info();
#endif
	m_mips = -1;
	m_kflops = -1;
	m_last_benchmark = 0;

	m_arch = NULL;
	m_opsys = NULL;
	m_uid_domain = NULL;
	m_filesystem_domain = NULL;

		// Number of CPUs.  Since this is used heavily by the ResMgr
		// instantiation and initialization, we need to have a real
		// value for this as soon as the MachAttributes object exists.
	m_num_cpus = calc_ncpus();
}


MachAttributes::~MachAttributes()
{
#if !defined(WIN32)
	delete m_afs_info;
#endif
}


void
MachAttributes::init()
{
	this->compute( A_ALL );
}


void
MachAttributes::compute( amask_t how_much )
{

	if( IS_STATIC(how_much) ) {

			// Physical memory
		m_phys_mem = calc_phys_memory();
		if( m_phys_mem <= 0 ) {
				// calc_phys_memory() failed to give us something
				// useful, try paraming. 
			char* ptr;
			if( (ptr = param("MEMORY")) != NULL ) {
				m_phys_mem = atoi(ptr);
				free(ptr);
			}
		}

#if !defined(WIN32) /* NEED TO PORT TO WIN32 */
			// AFS cell
		if( m_afs_info->my_cell() ) {
			dprintf( D_FULLDEBUG, "%s = \"%s\"\n", ATTR_AFS_CELL, 
					 m_afs_info->my_cell() );
		} else {
			dprintf( D_FULLDEBUG, "AFS_Cell not set\n" );
		}
#endif

			// Arch, OpSys, FileSystemDomain and UidDomain.  Note:
			// these will always return something, since config() will
			// insert values if we don't have them in the config file.
		if( m_arch ) {
			free( m_arch );
		}
		m_arch = param( "ARCH" );

		if( m_opsys ) {
			free( m_opsys );
		}
		m_opsys = param( "OPSYS" );

		if( m_uid_domain ) {
			free( m_uid_domain );
		}
		m_uid_domain = param( "UID_DOMAIN" );
		dprintf( D_FULLDEBUG, "%s = \"%s\"\n", ATTR_UID_DOMAIN,
				 m_uid_domain );

		if( m_filesystem_domain ) {
			free( m_filesystem_domain );
		}
		m_filesystem_domain = param( "FILESYSTEM_DOMAIN" );
		dprintf( D_FULLDEBUG, "%s = \"%s\"\n", ATTR_FILE_SYSTEM_DOMAIN,
				 m_filesystem_domain );
	}

	if( IS_UPDATE(how_much) && IS_SHARED(how_much) ) {
		m_virt_mem = calc_virt_memory();
		dprintf( D_FULLDEBUG, "Swap space: %lu\n", m_virt_mem );
		
		m_disk = calc_disk();
		dprintf( D_FULLDEBUG, "Disk space: %lu\n", m_disk );
	}


	if( IS_TIMEOUT(how_much) && IS_SHARED(how_much) ) {
		m_load = calc_load_avg();

		calc_idle_time( m_idle, m_console_idle );

		time_t my_timer;
		struct tm *the_time;
		time( &my_timer );
		the_time = localtime(&my_timer);
		m_clock_min = (the_time->tm_hour * 60) + the_time->tm_min;
		m_clock_day = the_time->tm_wday;
	}

	if( IS_TIMEOUT(how_much) && IS_SUMMED(how_much) ) {
		m_condor_load = resmgr->sum( Resource::condor_load );
	}
}


void
MachAttributes::publish( ClassAd* cp, amask_t how_much) 
{
	char line[100];

	if( IS_STATIC(how_much) || IS_PUBLIC(how_much) ) {

		if( m_afs_info->my_cell() ) {
			sprintf( line, "%s = \"%s\"", ATTR_AFS_CELL,
					 m_afs_info->my_cell() );
			cp->Insert( line );
		}

			// STARTD_IP_ADDR 
		sprintf( line, "%s = \"%s\"", ATTR_STARTD_IP_ADDR, 
				 daemonCore->InfoCommandSinfulString() );
		cp->Insert( line );

		sprintf( line, "%s = \"%s\"", ATTR_ARCH, m_arch );
		cp->Insert( line );

		sprintf( line, "%s = \"%s\"", ATTR_OPSYS, m_opsys );
		cp->Insert( line );

		sprintf( line, "%s = \"%s\"", ATTR_UID_DOMAIN, m_uid_domain );
		cp->Insert( line );

		sprintf( line, "%s = \"%s\"", ATTR_FILE_SYSTEM_DOMAIN, 
				 m_filesystem_domain );
		cp->Insert( line );
	}

	if( IS_UPDATE(how_much) || IS_PUBLIC(how_much) ) {

		sprintf( line, "%s=%lu", ATTR_VIRTUAL_MEMORY, m_virt_mem );
		cp->Insert( line ); 

		sprintf( line, "%s=%lu", ATTR_DISK, m_disk );
		cp->Insert( line ); 

			// KFLOPS and MIPS are only conditionally computed; thus, only
			// advertise them if we computed them.
		if ( m_kflops > 0 ) {
			sprintf( line, "%s=%d", ATTR_KFLOPS, m_kflops );
			cp->Insert( line );
		}
		if ( m_mips > 0 ) {
			sprintf( line, "%s=%d", ATTR_MIPS, m_mips );
			cp->Insert( line );
		}
	}

		// We don't want this inserted into the public ad automatically
	if( IS_UPDATE(how_much) || IS_TIMEOUT(how_much) ) {
		sprintf( line, "%s=%d", ATTR_LAST_BENCHMARK, m_last_benchmark );
		cp->Insert( line );
	}


	if( IS_TIMEOUT(how_much) || IS_PUBLIC(how_much) ) {

		sprintf( line, "%s=%f", ATTR_TOTAL_LOAD_AVG, m_load );
		cp->Insert(line);
		
		sprintf( line, "%s=%f", ATTR_TOTAL_CONDOR_LOAD_AVG, m_condor_load );
		cp->Insert(line);
		
		sprintf(line, "%s=%d", ATTR_CLOCK_MIN, m_clock_min );
		cp->Insert(line); 

		sprintf(line, "%s=%d", ATTR_CLOCK_DAY, m_clock_day );
		cp->Insert(line); 

		sprintf(line, "%s=%d", ATTR_KEYBOARD_IDLE, (int)m_idle );
		cp->Insert(line); 
  
			// ConsoleIdle cannot be determined on all platforms; thus, only
			// advertise if it is not -1.
		if( m_console_idle != -1 ) {
			sprintf( line, "%s=%d", ATTR_CONSOLE_IDLE, (int)m_console_idle );
			cp->Insert(line); 
		}
	}
}


void
MachAttributes::benchmark( Resource* rip, int force )
{

	if( ! force ) {
		if( rip->state() != unclaimed_state &&
			rip->activity() != idle_act ) {
			dprintf( D_ALWAYS, 
					 "Tried to run benchmarks when not idle, aborting.\n" );
			return;
		}
			// Enter benchmarking activity
		rip->change_state( benchmarking_act );
	}

	dprintf( D_FULLDEBUG, "About to compute mips\n" );
	int new_mips_calc = calc_mips();
	dprintf( D_FULLDEBUG, "Computed mips: %d\n", new_mips_calc );

	if ( m_mips == -1 ) {
			// first time we've done benchmarks
		m_mips = new_mips_calc;
	} else {
			// compute a weighted average
		m_mips = (m_mips * 3 + new_mips_calc) / 4;
	}

	dprintf( D_FULLDEBUG, "About to compute kflops\n" );
	int new_kflops_calc = calc_kflops();
	dprintf( D_FULLDEBUG, "Computed kflops: %d\n", new_kflops_calc );
	if ( m_kflops == -1 ) {
			// first time we've done benchmarks
		m_kflops = new_kflops_calc;
	} else {
			// compute a weighted average
		m_kflops = (m_kflops * 3 + new_kflops_calc) / 4;
	}

	dprintf( D_FULLDEBUG, "recalc:DHRY_MIPS=%d, CLINPACK KFLOPS=%d\n",
			 m_mips, m_kflops);

	m_last_benchmark = (int)time(NULL);

	if( ! force ) {
		rip->change_state( idle_act );
	}
}


void
deal_with_benchmarks( Resource* rip )
{
	ClassAd* cp = rip->r_classad;

	int run_benchmarks = 0;
	if( cp->EvalBool( ATTR_RUN_BENCHMARKS, cp, run_benchmarks ) == 0 ) {
		run_benchmarks = 0;
	}

	if( run_benchmarks ) {
		resmgr->m_attr->benchmark( rip );
	}
}

CpuAttributes::CpuAttributes( MachAttributes* map, 
							  float phys_mem_percent, 
							  float virt_mem_percent, 
							  float disk_percent )
{
	c_phys_mem_percent = phys_mem_percent;
	c_virt_mem_percent = virt_mem_percent;
	c_disk_percent = disk_percent;
	this->map = map;
	c_num_cpus = 1;
}


void
CpuAttributes::attach( Resource* rip )
{
	this->rip = rip;
}


void
CpuAttributes::publish( ClassAd* cp, amask_t how_much )
{
	char line[100];

	if( IS_UPDATE(how_much) || IS_PUBLIC(how_much) ) {

		sprintf( line, "%s=%lu", ATTR_VIRTUAL_MEMORY, c_virt_mem );
		cp->Insert( line ); 

		sprintf( line, "%s=%lu", ATTR_DISK, c_disk );
		cp->Insert( line ); 
	}

	if( IS_TIMEOUT(how_much) || IS_PUBLIC(how_much) ) {

		sprintf( line, "%s=%f", ATTR_CONDOR_LOAD_AVG, c_condor_load );
		cp->Insert(line);

		sprintf( line, "%s=%f", ATTR_LOAD_AVG, 
				 (c_owner_load + c_condor_load) );
		cp->Insert(line);
	}		

	if( IS_STATIC(how_much) || IS_PUBLIC(how_much) ) {

		sprintf( line, "%s=%d", ATTR_MEMORY, c_phys_mem );
		cp->Insert(line);

		sprintf( line, "%s=%d", ATTR_CPUS, c_num_cpus );
		cp->Insert(line);
	}
}


void
CpuAttributes::compute( amask_t how_much )
{
	float val;

	if( IS_STATIC(how_much) ) {

			// Physical memory
		val = map->phys_mem() * c_phys_mem_percent;
		c_phys_mem = (int)floor( val );
	}

	if( IS_UPDATE(how_much) ) {

			// Shared attributes that we only get a percentage of
		val = map->virt_mem() * c_virt_mem_percent;
		c_virt_mem = (unsigned long)floor( val );
		
		val = map->disk() * c_disk_percent;
		c_disk = (unsigned long)floor( val );
	}

	if( IS_TIMEOUT(how_much) ) {

		// Dynamic, non-shared attributes we need to actually compute
		c_condor_load = rip->compute_condor_load();
	}	
}


void
CpuAttributes::dprintf( int flags, char* fmt, ... )
{
	va_list args;
	va_start( args, fmt );
	rip->dprintf_va( flags, fmt, args );
	va_end( args );
}

