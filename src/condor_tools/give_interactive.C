/***************************Copyright-DO-NOT-REMOVE-THIS-LINE**
 * CONDOR Copyright Notice
 *
 * See LICENSE.TXT for additional notices and disclaimers.
 *
 * Copyright (c)1990-1998 CONDOR Team, Computer Sciences Department, 
 * University of Wisconsin-Madison, Madison, WI.  All Rights Reserved.  
 * No use of the CONDOR Software Program Source Code is authorized 
 * without the express consent of the CONDOR Team.  For more information 
 * contact: CONDOR Team, Attention: Professor Miron Livny, 
 * 7367 Computer Sciences, 1210 W. Dayton St., Madison, WI 53706-1685, 
 * (608) 262-0856 or miron@cs.wisc.edu.
 *
 * U.S. Government Rights Restrictions: Use, duplication, or disclosure 
 * by the U.S. Government is subject to restrictions as set forth in 
 * subparagraph (c)(1)(ii) of The Rights in Technical Data and Computer 
 * Software clause at DFARS 252.227-7013 or subparagraphs (c)(1) and 
 * (2) of Commercial Computer Software-Restricted Rights at 48 CFR 
 * 52.227-19, as applicable, CONDOR Team, Attention: Professor Miron 
 * Livny, 7367 Computer Sciences, 1210 W. Dayton St., Madison, 
 * WI 53706-1685, (608) 262-0856 or miron@cs.wisc.edu.
****************************Copyright-DO-NOT-REMOVE-THIS-LINE**/
#include "condor_common.h"
#include <math.h>
#include <float.h>
#include "condor_state.h"
#include "condor_debug.h"
#include "condor_config.h"
#include "condor_attributes.h"
#include "condor_api.h"
#include "my_username.h"
#include "condor_classad.h"
#include "condor_adtypes.h"
#include "condor_string.h"
#include "condor_uid.h"
#include "daemon.h"
#include "extArray.h"
#include "HashTable.h"
#include "classad_hashtable.h"
#include "MyString.h"
#include "basename.h"
#include "condor_distribution.h"

// Globals

template class HashBucket<HashKey, int>;
template class HashTable<HashKey, int>;

double priority = 0.00001;
const char *pool = NULL;
struct 	PrioEntry { MyString name; float prio; };
static  ExtArray<PrioEntry> prioTable;
#ifndef WIN32
template class ExtArray<PrioEntry>;
#endif
ExprTree *rankCondStd;// no preemption or machine rank-preemption 
							  // i.e., (Rank > CurrentRank)
ExprTree *rankCondPrioPreempt;// prio preemption (Rank >= CurrentRank)
ExprTree *PreemptionReq;	// only preempt if true
ExprTree *PreemptionRank; 	// rank preemption candidates

char *mySubSystem;

bool
obtainAdsFromCollector (ClassAdList &startdAds, const char *constraint)
{
	CondorQuery startdQuery(STARTD_AD);
	QueryResult result;

	// Use CondorQuery object to fetch ads of startds according 
	// to the constraint.
	if ( constraint ) {
		if ( startdQuery.addANDConstraint(constraint) != Q_OK )
			return false;		
	} 

	if ( pool ) 
		result = startdQuery.fetchAds(startdAds,pool);
	else
		result = startdQuery.fetchAds(startdAds);

	if (result != Q_OK) 
		return false;

	return true;
}

ClassAd *
giveBestMachine(ClassAd &request,ClassAdList &startdAds,
			double preemptPrio)
{
		// the order of values in this enumeration is important!
		// it goes from least preffered to most preffered, i.e. we
		// prefer a match with NO_PREEMPTION best.
	enum PreemptState {PRIO_PREEMPTION,RANK_PREEMPTION,NO_PREEMPTION};
		// to store values pertaining to a particular candidate offer
	ClassAd 		*candidate;
	double			candidateRankValue;
	double			candidatePreemptRankValue;
	PreemptState	candidatePreemptState;
		// to store the best candidate so far
	ClassAd 		*bestSoFar = NULL;	
	double			bestRankValue = -(FLT_MAX);
	double			bestPreemptRankValue = -(FLT_MAX);
	PreemptState	bestPreemptState = (PreemptState)-1;
	bool			newBestFound;
		// to store results of evaluations
	char			remoteUser[128];
	char			remoteHost[256];
	float			tmp;
	MatchClassAd mad;	// NAC
	Value result;		// NAC
	bool match;			// NAC
	bool boolValue;		// NAC

	mad.ReplaceLeftAd( &request );	// NAC
	// scan the offer ads

	startdAds.Open ();
	while ((candidate = startdAds.Next ())) {

			// Add conditional operators to offer Rank expression if needed
		ExprTree* rankExpr = candidate->Lookup( ATTR_RANK );
		ExprTree* newRankExpr = NULL;
		candidate->AddExplicitConditionals( rankExpr, newRankExpr );
		if( newRankExpr != NULL ) {
			candidate->Insert( ATTR_RANK, newRankExpr );
		}
		
		// the candidate offer and request must match
		mad.RemoveRightAd( );
		mad.ReplaceRightAd( candidate );
		mad.EvaluateAttr( "symmetricMatch", result );
		if( result.IsBooleanValue( match ) && match == false ) {
			continue;
		}

		candidatePreemptState = NO_PREEMPTION;
		// if there is a remote user, consider preemption ....
		if (candidate->LookupString (ATTR_REMOTE_USER, remoteUser) ) {
				// check if we are preempting for rank or priority
			rankCondStd->SetParentScope( candidate );
			if( candidate->EvaluateExpr( rankCondStd, result ) &&	// NAC
				result.IsBooleanValue( boolValue ) && 				// NAC
				boolValue == true ) {								// NAC
					// offer strictly prefers this request to the one
					// currently being serviced; preempt for rank
				candidatePreemptState = RANK_PREEMPTION;
			} else {
					// RemoteUser on machine has *worse* priority than request
					// so we can preempt this machine *but* we need to check
					// on two things first
				candidatePreemptState = PRIO_PREEMPTION;
					// (1) we need to make sure that PreemptionReq's hold (i.e.,
					// if the PreemptionReq expression isn't true, dont preempt)
				PreemptionReq->SetParentScope( candidate );
				if( PreemptionReq &&									// NAC
					candidate->EvaluateExpr( PreemptionReq, result ) &&	// NAC
					result.IsBooleanValue( boolValue ) &&				// NAC
					boolValue == true ) {								// NAC
					continue;
				}
					// (2) we need to make sure that the machine ranks the job
					// at least as well as the one it is currently running 
					// (i.e., rankCondPrioPreempt holds)
				rankCondPrioPreempt->SetParentScope( candidate );
				if( candidate->EvaluateExpr( rankCondPrioPreempt, result ) &&	// NAC
					result.IsBooleanValue( boolValue ) &&	// NAC   
					boolValue == true ) {					// NAC
						// machine doesn't like this job as much -- find another
					continue;
				}
			} 
		}


		// calculate the request's rank of the offer
		if(!request.EvalFloat(ATTR_RANK,candidate,tmp)) {
			tmp = 0.0;
		}
		candidateRankValue = tmp;

		// the quality of a match is determined by a lexicographic sort on
		// the following values, but more is better for each component.  
		// The standard condor_negotiator works in this order of preference:
		//  1. job rank of offer 
		//	2. preemption state (2=no preempt, 1=rank-preempt, 0=prio-preempt)
		//  3. preemption rank (if preempting)
		//
		// But the below code for condor_find_host places the desires of the
		// system ahead of the desires of the resource requestor.  Thus the code
		// below works in the following order of preference:
		//	1. preemption state (2=no preempt, 1=rank-preempt, 0=prio-preempt)
		//  2. preemption rank (if preempting)
		//  3. job rank of offer 

		newBestFound = false;
		candidatePreemptRankValue = -(FLT_MAX);
		if( candidatePreemptState != NO_PREEMPTION ) {
			// calculate the preemption rank
			PreemptionRank->SetParentScope( candidate );
			if( PreemptionRank &&									 	// NAC 
				( !candidate->EvaluateExpr( PreemptionRank, result ) ||	// NAC
				  !result.IsRealValue( candidatePreemptRankValue))){	// NAC
				dprintf(D_ALWAYS, "Failed to evaluate PREEMPTION_RANK "
					"expression to a float.\n");
			}
		}
/**** old negotiator-style code: ***
		if( ( candidateRankValue > bestRankValue ) || 	// first by job rank
				( candidateRankValue==bestRankValue && 	// then by preempt state
				candidatePreemptState > bestPreemptState ) ) {
			newBestFound = true;
		} else if( candidateRankValue==bestRankValue && // then by preempt rank
				candidatePreemptState==bestPreemptState && 
				bestPreemptState != NO_PREEMPTION ) {
				// check if the preemption rank is better than the best
			if( candidatePreemptRankValue > bestPreemptRankValue ) {
				newBestFound = true;
			}
		} 
******************************/
		if( candidatePreemptState > bestPreemptState ) {	// first by preempt state
			newBestFound = true;
		} else if( candidatePreemptState==bestPreemptState &&  // then by preempt rank				
				bestPreemptState != NO_PREEMPTION ) {
				// check if the preemption rank is better than the best
			if( candidatePreemptRankValue > bestPreemptRankValue ) {
				newBestFound = true;
			}
		} 
		if( (candidatePreemptState==bestPreemptState &&
			( (bestPreemptState == NO_PREEMPTION) ||
			  ((bestPreemptState != NO_PREEMPTION) && (candidatePreemptRankValue == bestPreemptRankValue))
			)) 
			&& (candidateRankValue > bestRankValue) )	// finally by job rank
		{
			newBestFound = true;
		}

		if( newBestFound ) {
			bestSoFar = candidate;
			bestRankValue = candidateRankValue;
			bestPreemptState = candidatePreemptState;
			bestPreemptRankValue = candidatePreemptRankValue;
		}
	}
	startdAds.Close ();
	
	mad.RemoveLeftAd( );	// NAC
	mad.RemoveRightAd( );	// NAC

	// this is the best match
	return bestSoFar;
}

void
make_request_ad(ClassAd & requestAd, const char *rank)
{
	char buffer[2048];

	requestAd.SetMyTypeName (JOB_ADTYPE);
	requestAd.SetTargetTypeName (STARTD_ADTYPE);

	mySubSystem = "SUBMIT";
	config_fill_ad(&requestAd);
	mySubSystem = "INTERACTIVE";
	config_fill_ad(&requestAd);

	(void) sprintf (buffer, "Interactive = TRUE");	
	requestAd.Insert (buffer);

	(void) sprintf( buffer , "%s = %f" , ATTR_SUBMITTOR_PRIO , priority );
	requestAd.Insert (buffer);

	// Always set Requirements to True - we can do this because we only
	// fetch the startd ads which match the user's constraint in the first place.
	(void)sprintf( buffer, "%s = TRUE", ATTR_REQUIREMENTS );
	requestAd.Insert (buffer);

	if( !rank ) {
		(void)sprintf( buffer, "%s = 0", ATTR_RANK );
		requestAd.Insert (buffer);
	} else {
		(void)sprintf( buffer, "%s = %s", ATTR_RANK, rank );
		requestAd.Insert (buffer);
	}

	(void) sprintf (buffer, "%s = %d", ATTR_Q_DATE, (int)time ((time_t *) 0));	
	requestAd.Insert (buffer);

	(void) sprintf (buffer, "%s = 0", ATTR_COMPLETION_DATE);
	requestAd.Insert (buffer);

	char *owner = my_username();
	if( !owner ) {
		owner = "unknown";
	}
	(void) sprintf (buffer, "%s = \"%s\"", ATTR_OWNER, owner);
	requestAd.Insert (buffer);

#ifdef WIN32
	// put the NT domain into the ad as well
	char *ntdomain = strnewp(get_condor_username());
	if (ntdomain) {
		char *slash = strchr(ntdomain,'/');
		if ( slash ) {
			*slash = '\0';
			if ( strlen(ntdomain) > 0 ) {
				if ( strlen(ntdomain) > 80 ) {
					fprintf(stderr,"NT DOMAIN OVERFLOW (%s)\n",ntdomain);
					exit(1);
				}
				(void) sprintf (buffer, "%s = \"%s\"", ATTR_NT_DOMAIN, 
										ntdomain);
				requestAd.Insert (buffer);
			}
		}
		delete [] ntdomain;
	}
#endif
		
	(void) sprintf (buffer, "%s = 0.0", ATTR_JOB_LOCAL_USER_CPU);
	requestAd.Insert (buffer);

	(void) sprintf (buffer, "%s = 0.0", ATTR_JOB_LOCAL_SYS_CPU);
	requestAd.Insert (buffer);

	(void) sprintf (buffer, "%s = 0.0", ATTR_JOB_REMOTE_USER_CPU);
	requestAd.Insert (buffer);

	(void) sprintf (buffer, "%s = 0.0", ATTR_JOB_REMOTE_SYS_CPU);
	requestAd.Insert (buffer);

	(void) sprintf (buffer, "%s = 0", ATTR_JOB_EXIT_STATUS);
	requestAd.Insert (buffer);

	(void) sprintf (buffer, "%s = 0", ATTR_NUM_CKPTS);
	requestAd.Insert (buffer);

	(void) sprintf (buffer, "%s = 0", ATTR_NUM_RESTARTS);
	requestAd.Insert (buffer);

	(void) sprintf (buffer, "%s = 0", ATTR_JOB_COMMITTED_TIME);
	requestAd.Insert (buffer);

	(void)sprintf (buffer, "%s = 0", ATTR_IMAGE_SIZE);
	requestAd.Insert (buffer);

	(void)sprintf (buffer, "%s = 0", ATTR_EXECUTABLE_SIZE);
	requestAd.Insert (buffer);

	(void)sprintf (buffer, "%s = 0", ATTR_DISK_USAGE);
	requestAd.Insert (buffer);

	// what else?

}


static void
fetchSubmittorPrios()
{
	ClassAd ad;
	char  	attrName[32], attrPrio[32];
  	char  	name[128];
  	float 	priority;
	int		i = 1;

		// Minor hack, if we're talking to a remote pool, assume the
		// negotiator is on the same host as the collector.
	Daemon	negotiator( DT_NEGOTIATOR, pool, pool );

	Sock* sock;

	if (!(sock = negotiator.startCommand( GET_PRIORITY, Stream::reli_sock, 0))) {
		fprintf( stderr, 
				 "Error:  Could not get priorities from negotiator (%s)\n",
				 negotiator.fullHostname() );
		exit( 1 );
	}

	// connect to negotiator

	sock->eom();
	sock->decode();
	if( !getOldClassAdNoTypes(sock, ad) || !sock->end_of_message() ) {
		fprintf( stderr, 
				 "Error:  Could not get priorities from negotiator (%s)\n",
				 negotiator.fullHostname() );
		exit( 1 );
	}
	sock->close();
	delete sock;

	i = 1;
	while( i ) {
    	sprintf( attrName , "Name%d", i );
    	sprintf( attrPrio , "Priority%d", i );

    	if( !ad.LookupString( attrName, name ) || 
			!ad.LookupFloat( attrPrio, priority ) )
            break;

		prioTable[i-1].name = name;
		prioTable[i-1].prio = priority;
		// printf("DEBUG: Prio   %s %f\n",name,priority);
		i++;
	}

	if( i == 1 ) {
		printf( "Warning:  Found no submitters\n" );
	}
}

static int
findSubmittor( char *name ) 
{
	MyString 	sub(name);
	int			last = prioTable.getlast();
	int			i;
	
	for( i = 0 ; i <= last ; i++ ) {
		if( prioTable[i].name == sub ) return i;
	}

	prioTable[i].name = sub;
	prioTable[i].prio = 0.5;

	return i;
}

void
usage(char *name)
{
	printf("\nUsage: %s [-m] -[n number] [-c c_expr] [-r r_expr] [-p pool] \n", name);
	printf(" -m: Return entire machine, not virtual machines\n");
	printf(" -n num: Return num machines, where num is an integer "
			"greater than zero\n");
	printf(" -c c_expr: Use c_expr as the constraint expression\n");
	printf(" -r r_expr: Use r_expr as the rank expression\n");
	printf(" -p pool: Contact the Condor pool \"pool\"\n");
	printf(" -h: this screen\n\n");
	exit(1);
}


int
main(int argc, char *argv[])
{
	ClassAdList startdAds;
	char	**ptr;
	bool WantMachineNames = false;
	int NumMachinesWanted = 1;
	const char *constraint = NULL;
	const char *rank = NULL;
	ClassAd requestAd;
	ClassAd *offer;
	char *tmp;
	int i;
	char buffer[1024];
	HashTable<HashKey, int>	*virtualMachineCounts;

	ClassAdParser parser;	// NAC

	virtualMachineCounts = new HashTable <HashKey, int> (25, hashFunction); 
	mySubSystem = "INTERACTIVE";
	myDistro->Init( argc, argv );
	config();

	// parse command line args
	for( ptr=argv+1,argc--; argc > 0; argc--,ptr++ ) {
		if( ptr[0][0] == '-' ) {
			switch( ptr[0][1] ) {
			case 'm':	// want real machines, not virtual machines
				WantMachineNames = true;
				break;
			case 'n':	// want specific number of machines
				if( !(--argc) || !(*(++ptr)) ) {
					fprintf( stderr, "%s: -n requires another argument\n", 
							 basename(argv[0]) );
					exit(1);
				}					
				NumMachinesWanted = atoi(*ptr);
				if ( NumMachinesWanted < 1 ) {
					fprintf( stderr, "%s: -n requires another argument "
							 "which is an integer greater than 0\n",
							 basename(argv[0]) );
					exit(1);
				}
				break;
			case 'p':	// pool							
				if( !(--argc) || !(*(++ptr)) ) {
					fprintf( stderr, "%s: -p requires another argument\n", 
							 basename(argv[0]) );
					exit(1);
				}
				pool = *ptr;
				break;
			case 'c':	// constraint						
				if( !(--argc) || !(*(++ptr)) ) {
					fprintf( stderr, "%s: -c requires another argument\n", 
							 basename(argv[0]) );
					exit(1);
				}
				constraint = *ptr;
				break;
			case 'r':	// rank
				if( !(--argc) || !(*(++ptr)) ) {
					fprintf( stderr, "%s: -r requires another argument\n", 
							 basename(argv[0]) );
					exit(1);
				}
				rank = *ptr;
				break;
			default:
				usage(basename(argv[0]));
			}		
		}
	}

	// initialize some global expressions
	sprintf (buffer, "MY.%s > MY.%s", ATTR_RANK, ATTR_CURRENT_RANK);
	parser.ParseExpression( buffer, rankCondStd );	// NAC
	sprintf (buffer, "MY.%s >= MY.%s", ATTR_RANK, ATTR_CURRENT_RANK);
	parser.ParseExpression( buffer, rankCondPrioPreempt );	// NAC

	// get PreemptionReq expression from config file
	PreemptionReq = NULL;
	tmp = param("PREEMPTION_REQUIREMENTS");
	if( tmp ) {
		if( !parser.ParseExpression( ( string )tmp, PreemptionReq ) ) {	// NAC
			fprintf(stderr, 
				"\nERROR: Failed to parse PREEMPTION_REQUIREMENTS.\n");
			exit(1);
		}
	}

	// get PreemptionRank expression from config file
	PreemptionRank = NULL;
	tmp = param("PREEMPTION_RANK");
	if( tmp ) {
		if( !parser.ParseExpression( ( string )tmp, PreemptionRank ) ) {// NAC
			fprintf(stderr, 
				"\nERROR: Failed to parse PREEMPTION_RANK.\n");
			exit(1);
		}
	}

	// make the request ad
	make_request_ad(requestAd,rank);

	// grab the startd ads from the collector
	if ( !obtainAdsFromCollector(startdAds, constraint) ) {
		fprintf(stderr,
			"\nERROR:  failed to fetch startd ads ... aborting\n");
		exit(1);
	}

	// fetch submittor prios
	fetchSubmittorPrios();

	// populate startd ads with remote user prios
	ClassAd *ad;
	char remoteUser[1024];
	int index;
	startdAds.Open();
	while( ( ad = startdAds.Next() ) ) {
		if( ad->LookupString( ATTR_REMOTE_USER , remoteUser ) ) {
			if( ( index = findSubmittor( remoteUser ) ) != -1 ) {
				sprintf( buffer , "%s = %f" , ATTR_REMOTE_USER_PRIO , 
							prioTable[index].prio );
				ad->Insert( buffer );
			}
		}
	}
	startdAds.Close();
	

	// find best machines and display them
	char	remoteHost[MAXHOSTNAMELEN];
	for ( i = 0; i < NumMachinesWanted; i++ ) {
		
		offer = giveBestMachine(requestAd,startdAds,priority);
		
		// check if we found a machine
		if (!offer) {
			fprintf(stderr,
				"\nERROR: %d machines not available\n",NumMachinesWanted);
			exit(i+1);
		}

		// If we want the entire machine, and not just a VM...
		if(WantMachineNames) {
			if (offer->LookupString (ATTR_MACHINE, remoteHost) ) {
				int virtMachCount;
				int vmCountThusFar;

				HashKey key(remoteHost);

				// How many VM's are on that machine?
				if(! offer->LookupInteger (ATTR_TOTAL_VIRTUAL_MACHINES,
										 virtMachCount) ) {
						//printf("DEBUG: Setting virtMachineCount to 1\n");
						virtMachCount = 1;
				}

				vmCountThusFar = 0;
				// Keep track of what we've seen in a hashtable
				if(!virtualMachineCounts->lookup(key, vmCountThusFar)) {
					//printf("DEBUG: Already seen a %s %d times\n",
					//		 remoteHost, vmCountThusFar);
					virtualMachineCounts->remove(key);
				}			

				// If we don't have enough virtual machines to complete
				// the set, stick it in the hash table, remove it from the
				// list of startd ads, and keep looking.
				// FIXME(?) This would probably blow up with bogus ads 
				// (ie duplicate ads, but I dunno if those can happen)
				if(++vmCountThusFar < virtMachCount) {
					//printf("DEBUG: Adding %s with %d\n", remoteHost, 
					//		vmCountThusFar);
					virtualMachineCounts->insert(key, vmCountThusFar);
					startdAds.Delete(offer);
					i--;
					continue;
				}
			}
		} //end if(WantMachineNames) 

		// here we found a machine; spit out the name to stdout
		remoteHost[0] = '\0';
		if(WantMachineNames)
			offer->LookupString(ATTR_MACHINE, remoteHost);
		else
			offer->LookupString(ATTR_NAME, remoteHost);

		if ( remoteHost[0] ) {
			printf("%s\n", remoteHost);
		}

		// remote this startd ad from our list 
		startdAds.Delete(offer);
	}

	return 0;
}

