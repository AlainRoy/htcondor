/***************************Copyright-DO-NOT-REMOVE-THIS-LINE**
 * CONDOR Copyright Notice
 *
 * See LICENSE.TXT for additional notices and disclaimers.
 *
 * Copyright (c)1990-1998 CONDOR Team, Computer Sciences Department, 
 * University of Wisconsin-Madison, Madison, WI.  All Rights Reserved.  
 * No use of the CONDOR Software Program Source Code is authorized 
 * without the express consent of the CONDOR Team.  For more information 
 * contact: CONDOR Team, Attention: Professor Miron Livny, 
 * 7367 Computer Sciences, 1210 W. Dayton St., Madison, WI 53706-1685, 
 * (608) 262-0856 or miron@cs.wisc.edu.
 *
 * U.S. Government Rights Restrictions: Use, duplication, or disclosure 
 * by the U.S. Government is subject to restrictions as set forth in 
 * subparagraph (c)(1)(ii) of The Rights in Technical Data and Computer 
 * Software clause at DFARS 252.227-7013 or subparagraphs (c)(1) and 
 * (2) of Commercial Computer Software-Restricted Rights at 48 CFR 
 * 52.227-19, as applicable, CONDOR Team, Attention: Professor Miron 
 * Livny, 7367 Computer Sciences, 1210 W. Dayton St., Madison, 
 * WI 53706-1685, (608) 262-0856 or miron@cs.wisc.edu.
****************************Copyright-DO-NOT-REMOVE-THIS-LINE**/


#include "condor_common.h"
#include "condor_version.h"
#include "condor_mmap.h"
#include <math.h>
#if defined(Solaris)
#include <netconfig.h>		// for setnetconfig()
#endif

#include "condor_config.h"
#include "condor_syscalls.h"
#include "condor_sys.h"
#include "image.h"
#include "file_table_interf.h"
#include "condor_debug.h"
#include "condor_ckpt_mode.h"
#include "signals_control.h"

static char *_FileName_ = __FILE__;

extern int _condor_in_file_stream;

const int KILO = 1024;

extern "C" void mydprintf(int foo, const char *fmt, ...);

extern "C" void report_image_size( int );
extern "C"	int	SYSCALL(int ...);

#ifdef SAVE_SIGSTATE
extern "C" void _condor_save_sigstates();
extern "C" void _condor_restore_sigstates();
#endif

#if defined(COMPRESS_CKPT)
#include "zlib.h"
extern "C" {
	int condor_malloc_data_size();
	int condor_malloc_init(void *start);
	char *condor_malloc(size_t);
	void condor_free(void *);
	void *condor_morecore(int);
	static /*struct*/ z_stream *zstr = NULL;
	unsigned char *zbuf = Z_NULL;
	const int zbufsize = 64*1024;
}
#endif

#if defined(OSF1)
	extern "C" unsigned int htonl( unsigned int );
	extern "C" unsigned int ntohl( unsigned int );
#elif defined(HPUX)
#	include <netinet/in.h>
#elif defined(Solaris) && defined(sun4m)
	#define htonl(x)		(x)
	#define ntohl(x)		(x)
#elif defined(Solaris)
	/* Already included it */
#elif defined(IRIX)
	#include <sys/endian.h>
#elif defined(LINUX)
	#include <netinet/in.h>
#else
	extern "C" unsigned long htonl( unsigned long );
	extern "C" unsigned long ntohl( unsigned long );
#endif

#if defined(HPUX10)
extern "C" int _sigreturn();
#endif

void terminate_with_sig( int sig );
static void find_stack_location( RAW_ADDR &start, RAW_ADDR &end );
static int SP_in_data_area();
static void calc_stack_to_save();
void seg_handler( int signal, siginfo_t *info, void *context ); 
void test_seg_handler( );
extern "C" void _install_signal_handler( int sig, void * handler );
extern "C" int open_ckpt_file( const char *name, int flags, size_t n_bytes );
extern "C" int get_ckpt_mode( int sig );
extern "C" int get_ckpt_speed( );

Image MyImage;
static jmp_buf Env;
static RAW_ADDR SavedStackLoc;
volatile int InRestart = TRUE;
volatile int check_sig;		// the signal which activated the checkpoint; used
							// by some routines to determine if this is periodic
							// checkpoint (USR2) or a check & vacate (TSTP).
static size_t StackSaveSize;
unsigned int _condor_numrestarts = 0;
int condor_compress_ckpt = 0; // compression off(0) or on(1)
int condor_incremental_ckpt = 1; // incremental ckpt off(0) or on(1)
int condor_slow_ckpt = 0;

// set mySubSystem for Condor components which expect it
char *mySubSystem = "JOB";

static int
net_read(int fd, void *buf, int size)
{
	int		bytes_read;
	int		this_read;

	bytes_read = 0;
	do {
		this_read = read(fd, buf, size - bytes_read);
		if (this_read < 0) {
			return this_read;
		}
		bytes_read += this_read;
		buf = (void *) ( (char *) buf + this_read );
	} while (bytes_read < size);
	return bytes_read;
}

// this used to be in the #if defined(COMPRESS_CKPT) but I moved it
// out so I could use it for incr. ckpting  - jmb
void *condor_map_seg(void *base, size_t size)
{
	int zfd;
	if ((zfd = SYSCALL(SYS_open, "/dev/zero", O_RDWR)) == -1) {
		dprintf( D_ALWAYS,
				 "Unable to open /dev/zero in read/write mode.\n");
		dprintf( D_ALWAYS, "open: %s\n", strerror(errno));
		Suicide();
	}

	int flags;
	if (base == NULL) {
		flags = MAP_PRIVATE;
	} else {
		flags = MAP_PRIVATE|MAP_FIXED;
	}
	base = MMAP((MMAP_T)base, (size_t)size, PROT_READ|PROT_WRITE,
				flags, zfd, (off_t)0);
	if (base == MAP_FAILED) {
		dprintf(D_ALWAYS, "mmap: %s", strerror(errno));
		Suicide();
	}
	return base;
}

#if defined(COMPRESS_CKPT)
// TODO: deallocate segments on negative incr
void *condor_morecore(int incr)
{
	// begin points to the start of our heap segment
	// corestart points to the start of the allocated portion of the segment
	// *coreend points to the end of the allocated portion of the segment
	// *segend points to the end of our allocated segment
	// coreend and segend are stored at the start of the segment because
	//   we don't want them to be overwritten on a restart
	static void *begin = NULL, *corestart = NULL,
		**coreend = NULL, **segend = NULL;
	static int pagesize = -1;

	if (pagesize == -1) {
		pagesize = getpagesize();
	}
	
	if (begin == NULL) {
		begin = MyImage.FindAltHeap();
		int malloc_static_data = condor_malloc_data_size();
		int segincr =
			(((incr+malloc_static_data+
			   (2*sizeof(void *)))/pagesize)+1)*pagesize;
		begin = condor_map_seg(begin, segincr);
		corestart = (void *) (
			(int)begin+(int)(2*sizeof(void *))+(int)malloc_static_data ); 
		condor_malloc_init((void *)((int)begin+(int)(2*sizeof(void *))));
		coreend = (void **)begin;
		segend = (void **)((int)begin+(int)sizeof(void *));
		*segend = (void *)((int)begin+(int)segincr);
		*coreend = (void *)((int)corestart+(int)incr);
		return corestart;
	} else if (incr == 0) {
		return *coreend;
	} else {
		void *old_break = *coreend;
		*coreend = (void *)((int)*coreend + (int)incr);
		if (*coreend > *segend) {
			int segincr = (int)((((int)*coreend-(int)*segend)/(int)pagesize)+1)*(int)pagesize;
			if ((int)*coreend+(int)segincr-(int)begin > ALT_HEAP_SIZE) {
				dprintf(D_ALWAYS,
						"fatal error: exceeded ALT_HEAP_SIZE of %d bytes!\n",
						ALT_HEAP_SIZE);
				Suicide();
			}
			if (condor_map_seg(*segend, segincr) != *segend) {
				dprintf(D_ALWAYS, "failed to allocate contiguous segments in "
						"condor_morecore!\n");
				Suicide();
			}
			*segend = (void *)((int)*segend + (int)segincr);
		}
		return old_break;
	}
}

void *
zalloc(voidpf opaque, uInt items, uInt size)
{
	return condor_malloc(items*size);
}

void
zfree(voidpf opaque, voidpf address)
{
	condor_free(address);
}
#endif

void
Header::Init()
{
	if (condor_compress_ckpt)
		magic = COMPRESS_MAGIC;
	else
		magic = MAGIC;
	n_segs = 0;
	alt_heap = 0;
}

void
Header::ResetMagic()
{
	if (condor_compress_ckpt)
		magic = COMPRESS_MAGIC;
	else
		magic = MAGIC;
}

void
Header::Display()
{
	DUMP( " ", magic, 0x%X );
	DUMP( " ", n_segs, %d );
}

void
SegMap::Init( const char *n, RAW_ADDR c, long l, int p )
{
	strcpy( name, n );
	file_loc = -1;
	core_loc = c;
	len = l;
	prot = p;
}

void
SegMap::MSync()
{
	/* We use msync() to commit our dirty pages to swap space periodically.
	   This reduces the number of dirty pages that need to be swapped out
	   if we are suspended, reducing the cost of a suspend operation.
	   We would like to use MS_ASYNC, like this:
		 if (msync((char *)core_loc, len, MS_ASYNC) < 0) {
		   dprintf( D_ALWAYS, "msync(%x, %d) failed with errno = %d\n",
		   core_loc, len, errno );
		 }
	   Unfortunately, this seems to overwhelm some systems with write
	   requests (possibly because MS_ASYNC is rarely used, so kernel
	   developers don't work to get it right), so instead we use MS_SYNC
	   below to write pagesize chunks synchronously.  This may be less
	   efficient, but it is better than hanging the machine.
	*/
	int pagesize = getpagesize();
	for (int i = 0; i < len; i += pagesize) {
		if (msync((char *)core_loc+i, pagesize, MS_SYNC) < 0) {
			dprintf( D_ALWAYS, "msync(%x, %d) failed with errno = %d\n",
					 core_loc+i, pagesize, errno );
		}
	}
}

void
SegMap::Display()
{
	DUMP( " ", name, %s );
	printf( " file_loc = %Lu (0x%X)\n", file_loc, file_loc );
	printf( " core_loc = %Lu (0x%X)\n", core_loc, core_loc );
	printf( " len = %d (0x%X)\n", len, len );
}


/* don't assume we have libc.so in a good state right now... - Jim B. */
static int mystrcmp(const char *str1, const char *str2)
{
	while (*str1 != '\0' && *str2 != '\0' && *str1 == *str2) {
		str1++;
		str2++;
	}
	return (int) *str1 - *str2;
}


// find and return a pointer to a segment, NULL if not found
SegMap *
Image::GetSeg(const char * name ) {
	int i;
	for (i = 0; i < head.N_Segs(); i++) {
		if ( mystrcmp(name, map[i].GetName()) == 0 ) {
			return &map[i];	
		}
	}
	return NULL;
}

// returns how many pages have been added to the data segment
// if negative, the data segment has shrunk
long
Image::NewPages() {
	char *orig_brk;
	char *cur_brk;
	SegMap *data;

	if ( (data = GetSeg( "DATA" )) == NULL ) {
		dprintf( D_ALWAYS, "Couldn't find DATA segment.\n" );
		Suicide();
	}

	cur_brk  = (char *)sbrk(0);
	orig_brk = (char *)data->GetBrk(); 
	orig_brk = (char *)incr_ckpt_data->orig_brk;

	if (orig_brk != cur_brk) {
		dprintf( D_ALWAYS, "New pages: orig_brk was Ox%x, cur is Ox%x.\n",
				orig_brk, cur_brk );
	}
	return (cur_brk - orig_brk) / getpagesize();
}

void
Image::PrintBitmap()
{
	dprintf( D_ALWAYS, "Per page analysis: " );
	for (int i = 0; i < incr_ckpt_data->total_pages; i++) {
		dprintf( D_ALWAYS, "%i", bitIsSet( i, incr_ckpt_data->bitmap ) );
	}
	dprintf( D_ALWAYS, "\n" );
}

// set a bit in the bitmap
// returns true if bit is set
// returns false if bit was already set
bool
Image::NewDirtyPage(char * page)
{
	int i;
	char * data_start;

	SegMap *data = GetSeg( "DATA" );
	if (data == NULL) {
		dprintf( D_ALWAYS, "Couldn't find DATA segment.\n" );
		Suicide();
	}

	data_start = (char *) data->GetLoc();

	// now we have start address of segment in data_start and page address
	// compute which page number of the segment this is
	int dirtyPage = ( (int)(page - data_start) ) / getpagesize();
	if (bitIsSet( dirtyPage, incr_ckpt_data->bitmap ) ) {
		// should not seg-fault on same page twice
		dprintf( D_ALWAYS, "Caught an internal segfault on page %i (Ox%x) in "
				"\n\tseg %s (Ox%x, len %d).\n", dirtyPage, page, "DATA", 
				data_start, data->GetLen() );
		PrintBitmap();
		// should really return false, but there seems to be a problem
		// just to test the timing, I'll set it to true - jmb
		return false;
	}
	setBit( dirtyPage, incr_ckpt_data->bitmap ); 
	incr_ckpt_data->dirty_pages++;
	return true;
}


void
Image::SetFd( int f )
{
	fd = f;
	pos = 0;
}

void
Image::SetFileName( char *ckpt_name )
{
		// Save the checkpoint file name
	file_name = new char [ strlen(ckpt_name) + 1 ];
	strcpy( file_name, ckpt_name );

	fd = -1;
	pos = 0;
}

void
Image::SetMode( int syscall_mode )
{
	if( syscall_mode & SYS_LOCAL ) {
		mode = STANDALONE;
	} else {
		mode = REMOTE;
	}
}

#if defined(COMPRESS_CKPT)
/* 
** Return the start of the alternate heap, used internally by the
** checkpointing library.  The alternate heap is always located in
** the free area above the heap, leaving ALT_HEAP_SIZE of space between
** the start of the alt heap and the end of the free area.  It is
** essential that this heap be located in the same place after a
** restart, so our static pointer to the alt heap is not trashed.
** We never save the alt heap at checkpoint time.
*/
void *
Image::FindAltHeap()
{
	if (head.AltHeap() > 0) return (void *)head.AltHeap();

	void *datatop = 0, *freetop = (void *)-1;

	for (int i=0; i < head.N_Segs(); i++) {
		if (strcmp(map[i].GetName(), "DATA") == MATCH) {
			void *ptr = (void *)((int)map[i].GetLoc() + (int)map[i].GetLen());
			if (ptr > datatop) {
				datatop = ptr;
			}
		}
	}

	for (int i=0; i < head.N_Segs(); i++) {
		if (strcmp(map[i].GetName(), "DATA") != MATCH) {
			void *ptr = (void *) map[i].GetLoc();
			if (ptr > datatop && ptr < freetop) {
				freetop = ptr;
			}
		}
	}

	// if we didn't find anything above the heap, we don't want to
	// return (void *)-1 - ALT_HEAP_SIZE, because this address might
	// be too big on 64 bit architectures, so we instead return
	// datatop + RESERVED_HEAP - ALT_HEAP_SIZE
	if (freetop == (void *)-1) {
		freetop = (void *)((int)datatop + (int)RESERVED_HEAP);
	}

	// make sure that we begin on a page boundary
	int pagesize = getpagesize();
	freetop = (void *)(((RAW_ADDR)freetop/pagesize)*pagesize);
	head.AltHeap((RAW_ADDR)freetop - ALT_HEAP_SIZE);
	return (void *)head.AltHeap();
}
#endif


/*
  These actions must be done on every startup, regardless whether it is
  local or remote, and regardless whether it is an original invocation
  or a restart.
*/
extern "C"
void
_condor_prestart( int syscall_mode )
{
	MyImage.SetMode( syscall_mode );

	_condor_file_table_init();

		// Install initial signal handlers
	_install_signal_handler( SIGTSTP, (SIG_HANDLER)Checkpoint );
	_install_signal_handler( SIGUSR2, (SIG_HANDLER)Checkpoint );
		// install one for incremental checkpointing
	if ( condor_incremental_ckpt ) {
		_install_signal_handler( SIGSEGV, seg_handler );
		dprintf( D_ALWAYS, "Registered seg_handler (Ox%x)\n", seg_handler );
	}

	calc_stack_to_save();

	/* On the first call to setnetconfig(), space is malloc()'ed to store
	   the net configuration database.  This call is made by Solaris during
	   a socket() call, which we do inside the Checkpoint signal handler.
	   So, we call setnetconfig() here to do the malloc() before we are
	   in the signal handler.  (Doing a malloc() inside a signal handler
	   can have nasty consequences.)  -Jim B.  */
	/* Note that the floating point code below is needed to initialize
	   this process as a process which potentially uses floating point
	   registers.  Otherwise, the initialization is possibly not done
	   on restart, and we will lose floats on context switches.  -Jim B. */
#if defined(Solaris)
	setnetconfig();
#if defined(sun4m)
	float x=23, y=14, z=256;
	if ((x+y)>z) {
		dprintf(D_ALWAYS,
				"Internal error: Solaris floating point test failed\n");
		Suicide();
	}
	z=x*y;
#endif
#endif

}

void
test_seg_handler( ) {
	char * test = (char *) malloc( 2 * getpagesize( ) );
	char * page = condor_getpagestart( test ) + getpagesize();

	// turn this off for a second, it works and now we're assuming that
	// all segfaults must occur within data segment
	if (true) return;

	dprintf( D_ALWAYS, "TESTING SEG_HANDLER\n" );
	//dprintf( D_ALWAYS, "Mprotecting page: Start 0x%x, len %d\n", 
	//		page, getpagesize() );
	condor_mprotect( page, getpagesize(), PROT_READ );
	//dprintf( D_ALWAYS, "Trying to initiate a segfault at Ox%x.\n",
	//		&page[2]);
	page[2]++;
	//dprintf( D_ALWAYS, "Successfully able to fix segv at Ox%x.\n",
	//		&page[2]);
	free( test );
	dprintf( D_ALWAYS, "TESTING SUCCESSFULL\n" );
}

extern "C" void
_install_signal_handler( int sig,  void *handler )
{
	int		scm;
	struct sigaction action;

	scm = SetSyscalls( SYS_LOCAL | SYS_UNMAPPED );

#if defined(HPUX10) 
	action.sa_sigaction = handler;
#else
	// do increment chpting differently
	if (sig == SIGSEGV) {
			// there is an annoying conversion warning here
		action.sa_sigaction = handler;
	} else {
		action.sa_handler = (SIG_HANDLER)handler;
	}
#endif
	sigemptyset( &action.sa_mask );
	/* We do not want "recursive" checkpointing going on.  So block SIGUSR2
		during a SIGTSTP checkpoint, and vice-versa.  -Todd Tannenbaum, 8/95 */
	if ( sig == SIGTSTP )
		sigaddset(&action.sa_mask,SIGUSR2);
	if ( sig == SIGUSR2 )
		sigaddset(&action.sa_mask,SIGTSTP);
	
#if defined(HPUX10) 
	action.sa_flags = SA_SIGINFO;	/* so our handler is passed the context */
#else
	if (sig == SIGSEGV) {
		action.sa_flags = SA_SIGINFO; /* so our handler is passed the context */
	} else {
		action.sa_flags = 0;
	}
#endif

	if( sigaction(sig,&action,NULL) < 0 ) {
		dprintf(D_ALWAYS, "can't install sighandler for sig %d: %s\n",
				sig, strerror(errno));
		Suicide();
	}

	SetSyscalls( scm );
}


/*
  Save checkpoint information about our process in the "image" object.  Note:
  this only saves the information in the object.  You must then call the
  Write() method to get the image transferred to a checkpoint file (or
  possibly moved to another process.
*/
void
Image::Save()
{
#if !defined(HAS_DYNAMIC_USER_JOBS)
	RAW_ADDR	stack_start, stack_end;
#else
	RAW_ADDR	addr_start, addr_end;
	int             numsegs, prot, rtn, stackseg=-1;
#endif
	RAW_ADDR	data_start, data_end;
	ssize_t		pos;
	int			i;

#if defined(COMPRESS_CKPT)
	RAW_ADDR	alt_heap = head.AltHeap();
#endif

	head.Init();

#if defined(COMPRESS_CKPT)
	head.AltHeap(alt_heap);
#endif

#if !defined(HAS_DYNAMIC_USER_JOBS)

		// Set up data segment
	data_start = data_start_addr();
	data_end = data_end_addr();
	dprintf(D_CKPT, "Adding a DATA segment: start[0x%x], end [0x%x]\n",
		data_start, data_end);
	AddSegment( "DATA", data_start, data_end, 0 );

		// Set up stack segment
	find_stack_location( stack_start, stack_end );
	dprintf(D_CKPT, "Adding a STACK segment: start[0x%x], end [0x%x]\n",
		stack_start, stack_end);
	AddSegment( "STACK", stack_start, stack_end, 0 );

#else

	// Note: the order in which the segments are put into the checkpoint
	// file is important.  The DATA segment must be first, followed by
	// all shared library segments, and then followed by the STACK
	// segment.  There are two reasons for this: (1) restoring the 
	// DATA segment requires the use of sbrk(), which is in libc.so; if
	// we mess up libc.so, our calls to sbrk() will fail; (2) we 
	// restore segments in order, and the STACK segment must be restored
	// last so that we can immediately return to user code.  - Jim B.

	
	dprintf(D_CKPT, "About to ask the OS for segments...\n");
	numsegs = num_segments();
	dprintf(D_CKPT, "I should have %d segments...\n", numsegs);

#if !defined(IRIX) && !defined(Solaris)

	// data segment is saved and restored as before, using sbrk()
	data_start = data_start_addr();
	data_end = data_end_addr();
/*	printf( "Data start = 0x%x, data end = 0x%x\n",*/
/*			data_start, data_end );*/
	AddSegment( "DATA", data_start, data_end, 0 );

#else

	// sbrk() doesn't give reliable values on IRIX and Solaris
	// use ioctl info instead
	data_start=MAXLONG;
	data_end=0;
	for( i=0; i<numsegs; i++ ) {
		rtn = segment_bounds(i, addr_start, addr_end, prot);
		if (rtn == 3) {
			if (data_start > addr_start)
				data_start = addr_start;
			if (data_end < addr_end)
				data_end = addr_end;
		}
	}
	AddSegment( "DATA", data_start, data_end, prot );
	dprintf(D_CKPT, "I just added the data segment\n");

#endif	

	for( i=0; i<numsegs; i++ ) {
		rtn = segment_bounds(i, addr_start, addr_end, prot);
		switch (rtn) {
		case -1:
			dprintf( D_ALWAYS, "Internal error, segment_bounds returned -1\n");
			Suicide();
			break;
		case 0:
			dprintf(D_CKPT, "Adding SHARED LIB\n");
			if (addr_start != head.AltHeap()) {	// don't ckpt alt heap
				AddSegment( "SHARED LIB", addr_start, addr_end, prot);
				dprintf(D_CKPT, "\tlen:[0x%x]\n", 
					addr_end - addr_start);
			}
			break;
		case 1:
			dprintf(D_CKPT, "Skipping Text Segment\n");
			break;		// don't checkpoint text segment
		case 2:
			dprintf(D_CKPT, "Adding Stack Segment\n");
			stackseg = i;	// don't add STACK segment until the end
			break;
		case 3:
			dprintf(D_CKPT, "Don't add DATA segment again\n");
			break;		// don't add DATA segment again
		default:
			dprintf( D_ALWAYS, "Internal error, segment_bounds"
					 "returned unrecognized value\n");
			Suicide();
		}
	}	

	if(stackseg==-1) {
		dprintf(D_ALWAYS,"Image::Save: Never found stackseg!\n");
		Suicide();
	}

	// now add stack segment
	rtn = segment_bounds(stackseg, addr_start, addr_end, prot);
	AddSegment( "STACK", addr_start, addr_end, prot);
	dprintf( D_CKPT, "stack start = 0x%x, stack end = 0x%x\n",
			addr_start, addr_end);

#endif

		// Calculate positions of segments in ckpt file
	pos = sizeof(Header) + head.N_Segs() * sizeof(SegMap);
	for( i=0; i<head.N_Segs(); i++ ) {
		pos = map[i].SetPos( pos );
		dprintf( D_CKPT,"Pos: %d\n",pos);
	}

	if( pos < 0 ) {
		dprintf( D_ALWAYS, "Internal error, ckpt size calculated is %d\n", pos );
		Suicide();
	}

	dprintf( D_ALWAYS, "Size of ckpt image = %d bytes\n", pos );
	len = pos;

	valid = TRUE;
}

ssize_t
SegMap::SetPos( ssize_t my_pos )
{
	file_loc = my_pos;
	return file_loc + len;
}

void
Image::Display()
{
	int		i;

	printf( "===========\n" );
	printf( "Ckpt File Header:\n" );
	head.Display();
	for( i=0; i<head.N_Segs(); i++ ) {
		printf( "Segment %d:\n", i );
		map[i].Display();
	}
	printf( "===========\n" );
}

void
Image::AddSegment( const char *name, RAW_ADDR start, RAW_ADDR end, int prot )
{
	RAW_ADDR	len = end - start;
	int idx = head.N_Segs();

	if( idx >= MAX_SEGS ) {
		dprintf( D_ALWAYS, "Don't know how to grow segment map yet!\n" );
		Suicide();
	}
	dprintf(D_CKPT, "Image::AddSegment: name=[%s], start=[0x%x], end=[0x%x], len=[0x%x], prot=[0x%x]\n", name, start, end, len, prot);
	head.IncrSegs();
	map[idx].Init( name, start, len, prot );
}

char *
Image::FindSeg( void *addr )
{
	int		i;
	if( !valid ) {
		return NULL;
	}
	for( i=0; i<head.N_Segs(); i++ ) {
		if( map[i].Contains(addr) ) {
			return map[i].GetName();
		}
	}
	return NULL;
}

BOOL
SegMap::Contains( void *addr )
{
	return ((RAW_ADDR)addr >= core_loc) && ((RAW_ADDR)addr < core_loc + len);
}


#define USER_DATA_SIZE 256
#if defined(PVM_CHECKPOINTING)
extern "C" int user_restore_pre(char *, int);
extern "C" int user_restore_post(char *, int);
char	global_user_data[USER_DATA_SIZE];
#endif

/*
  Given an "image" object containing checkpoint information which we have
  just read in, this method actually effects the restart.
*/
void
Image::Restore()
{
	int		save_fd = fd;
	char	user_data[USER_DATA_SIZE];


#if defined(PVM_CHECKPOINTING)
	user_restore_pre(user_data, sizeof(user_data));
#endif

#if defined(COMPRESS_CKPT)
	// If the checkpoint header contains an alt heap pointer, then we must
	// create an alt heap, because the alt heap pointer is going to be
	// restored, and it has to point to something.
	if (head.AltHeap() > 0) {
		condor_morecore(0);
	}
	if (head.Magic() == COMPRESS_MAGIC) {
		if (head.AltHeap() == 0) {
			dprintf( D_ALWAYS, "Checkpoint is compressed but no alt heap is "
					 "specified!  Aborting restart.\n" );
			fprintf( stderr, "CONDOR ERROR: Checkpoint header is malformed. "
					 "Compression is specified without a corresponding alt "
					 "heap.\n" );
			exit( 1 );
		}
		dprintf( D_ALWAYS, "Reading compressed segments...\n" );
		zstr = (z_stream *) condor_malloc(sizeof(z_stream));
		if (!zstr) {
			dprintf( D_ALWAYS, "out of memory in condor_malloc!\n");
			Suicide();
		}
		zbuf = (unsigned char *)condor_malloc(zbufsize);
		if (!zbuf) {
			dprintf( D_ALWAYS, "out of memory in condor_malloc!\n");
			Suicide();
		}
		zstr->zalloc = zalloc;
		zstr->zfree = zfree;
		zstr->opaque = Z_NULL;
		if (inflateInit(zstr) != Z_OK) {
			dprintf( D_ALWAYS, "zlib (inflateInit): %s\n", zstr->msg );
			Suicide();
		}
	}
#endif

		// Overwrite our data segment with the one saved at checkpoint
		// time *and* restore any saved shared libraries.

	RestoreAllSegsExceptStack();

		// We have just overwritten our data segment, so the image
		// we are working with has been overwritten too.  Fortunately,
		// the only thing that has changed is the file descriptor.
	fd = save_fd;

#if defined(PVM_CHECKPOINTING)
	memcpy(global_user_data, user_data, sizeof(user_data));
#endif

		// Now we're going to restore the stack, so we move our execution
		// stack to a temporary area (in the data segment), then call
		// the RestoreStack() routine.
	dprintf(D_CKPT, "About to execute on TmpStk\n");
	ExecuteOnTmpStk( RestoreStack );

		// RestoreStack() also does the jump back to user code
	dprintf( D_ALWAYS, "Error: reached code past the restore point!\n" );
	Suicide();
}

#if defined(COMPRESS_CKPT)
/* zlib uses memcpy, but we can't assume that libc.so is in a good state,
   so we provide our own version... - Jim B. */
extern "C" {
void *memcpy(void *s1, const void *s2, size_t n)
{
	char *cs1 = NULL;
	char *cs2 = NULL;
	void *r = s1;

	cs1 = (char*)s1;
	cs2 = (char*)s2;

	while (n > 0) {
		*cs1++ = *cs2++;
		n--;
	}
	return r;
}
void *_memcpy(void *s1, const void *s2, size_t n)
{
	return memcpy(s1, s2, n);
}
}
#endif

void
Image::RestoreSeg( const char *seg_name )
{
	SegMap *seg = GetSeg( seg_name );
	if (seg == NULL) {
		dprintf( D_ALWAYS, "Can't find segment \"%s\"\n", seg_name );
		fprintf( stderr, "CONDOR ERROR: can't find segment \"%s\" on restart\n",
			 seg_name );
		exit( 1 );
	}
	
	if( (pos = seg->Read(fd,pos)) < 0 ) {
		dprintf(D_ALWAYS, "SegMap::Read() failed!\n");
		Suicide();
	} else {
		return;
	}
}


// call to mprotect MyImage, currently only doing incremental ckpting on data
// segment, should be trivial to extend logic to work on all segments
// we're initially doing it only on data segment mostly as a proof of concept
// and since all other segments are such an insignificant proportion of the
// image size
BOOL
Image::Mprotect( int prot ) {
	dprintf( D_ALWAYS, "Mprotect called on image (%s)\n",
		(prot == PROT_READ) ? "ro" : "rw" );
	test_seg_handler(); 									// this works
	for (int i = 0; i<head.N_Segs(); i++) {
		if ( mystrcmp("DATA", map[i].GetName()) == 0 ) {
			dprintf( D_ALWAYS, "Will mprotect data segment\n" );
			map[i].Mprotect( prot ); 					// this crashes
			dprintf( D_ALWAYS, "Mproctected data segment\n" );
		}
	} 
}

// for the time being, only do increment ckpting on the data segment
// later if we protect all segments, we will need to rethink how we
// keep the dirty page information for each segment
void
Image::InitIncrCkptSegment( ) 
{
	long totalPages, bitmap_size, size;
	void * addr;
	SegMap * data;

	if ( (data = GetSeg( "DATA" )) == NULL ) {
		dprintf( D_ALWAYS, "Couldn't find DATA segment.\n" );
		Suicide();
	}

	totalPages  = data->GetPageCount();
	bitmap_size = totalPages / 8 + 1;	// 8 bits in byte, one bit for each page
	size = bitmap_size + sizeof( Incr_ckpt_data ) - 1;	// -1 for stretchy array
	addr = condor_map_seg( NULL, size );

	dprintf( D_ALWAYS, "InitIncrCkptSegment: totalPages is %d, bitmap_size is "
			"%d, size is %d, addr is Ox%x.\n", totalPages, bitmap_size,
			size, addr );

	// set up incremental checkpoint structure on top of the new segment
	incr_ckpt_map.Init( 
		"Incr_CKPT_map", (RAW_ADDR) addr, size, PROT_READ | PROT_WRITE );
	dprintf( D_ALWAYS, "Mapped segment at Ox%x\n", addr );
	incr_ckpt_data = (Incr_ckpt_data *) addr;
	incr_ckpt_data->total_pages = totalPages;
	incr_ckpt_data->dirty_pages = 0;
	incr_ckpt_data->orig_brk    = (RAW_ADDR) data->GetBrk();
	dprintf( D_ALWAYS, "Addr of bitmap is Ox%x\n", 
			incr_ckpt_data->bitmap );

	// do a little check of our bit set and get and clear methods
	if ( BitmapOK() ) {
		dprintf( D_ALWAYS, "Bitmap passed tests.\n" );
	} else {
		dprintf( D_ALWAYS, "Bitmap error.\n" );
		Suicide();
	}

	dprintf( D_ALWAYS, "Inited incr ckpt segment\n" );
}

bool 
Image::BitmapOK() {
	for (int i = 0; i < incr_ckpt_data->total_pages; i++) {
		if (bitIsSet( i, incr_ckpt_data->bitmap ) ) {
			dprintf( D_ALWAYS, "Bitmap problem (1), bit %d\n" );
			return false;
		}
		setBit( i, MyImage.incr_ckpt_data->bitmap );
		if ( ! bitIsSet( i, MyImage.incr_ckpt_data->bitmap ) ) {
			dprintf( D_ALWAYS, "Bitmap problem (2), bit %d\n" );
			return false;
		}
		clearBit( i, MyImage.incr_ckpt_data->bitmap );	
		if (bitIsSet( i, MyImage.incr_ckpt_data->bitmap ) ) {
			dprintf( D_ALWAYS, "Bitmap problem (3), bit %d\n" );
			return false;
		}
	}
	return true;
}

void
Image::DestroyIncrCkptSegment( ) 
{
	dprintf( D_ALWAYS, "Unmapping incr_ckpt_map segment, addr Ox%x, len %d\n",
		(void *)MyImage.incr_ckpt_map.GetLoc(), MyImage.incr_ckpt_map.GetLen());
	Display();
	if (munmap( (void *) MyImage.incr_ckpt_map.GetLoc(), 
				MyImage.incr_ckpt_map.GetLen() ) < 0) 
	{
		dprintf( D_ALWAYS, "Couldn't unmap incr_ckpt_map segment\n" );
	}
}

void Image::RestoreAllSegsExceptStack()
{
	int		i;
	int		save_fd = fd;

#if defined(Solaris) || defined(IRIX)
	dprintf( D_ALWAYS, "Current segmap dump follows\n");
	display_prmap();
#endif
	for( i=0; i<head.N_Segs(); i++ ) {
		if( mystrcmp("STACK",map[i].GetName()) != 0 ) {
			if( (pos = map[i].Read(fd,pos)) < 0 ) {
				dprintf(D_ALWAYS, "SegMap::Read() failed!\n" );
				Suicide();
			}
			/*
			if( mystrcmp("DATA", map[i].GetName()) == 0 ) {
				map[i].Mprotect(PROT_READ);
			}
			*/	
		}
		else if (i<head.N_Segs()-1) {
			dprintf( D_ALWAYS, "Checkpoint file error: STACK is not the "
					"last segment in ckpt file.\n");
			fprintf( stderr, "CONDOR ERROR: STACK is not the last segment "
					 " in ckpt file.\n" );
			exit( 1 );
		}
		fd = save_fd;
	}
	// mprotect necessary here ????
	/* this screws things up, maybe MyImage isn't inited yet 
	dprintf( D_ALWAYS, "About to Mprotect MyImage (2).\n" );
	MyImage.Mprotect( PROT_READ );	
	*/
}



void
RestoreStack()
{

#if defined(ALPHA)			
	unsigned int nbytes;		// 32 bit unsigned
#else
	unsigned long nbytes;		// 32 bit unsigned
#endif
	int		status;

	dprintf(D_CKPT, "RestoreStack() Entrance!\n");
	MyImage.RestoreSeg( "STACK" );

		// In remote mode, we have to send back size of ckpt informaton
	if( MyImage.GetMode() == REMOTE ) {
		nbytes = MyImage.GetLen();
		nbytes = htonl( nbytes );
		status = write( MyImage.GetFd(), &nbytes, sizeof(nbytes) );
		dprintf( D_ALWAYS, "USER PROC: CHECKPOINT IMAGE RECEIVED OK\n" );

		SetSyscalls( SYS_REMOTE | SYS_MAPPED );
	} else {
		SetSyscalls( SYS_LOCAL | SYS_MAPPED );
	}

#if defined(PVM_CHECKPOINTING)
	user_restore_post(global_user_data, sizeof(global_user_data));
#endif

#if defined(COMPRESS_CKPT)
	if (zstr) {
		int rval = inflateEnd(zstr);
		if (rval != Z_OK) {
			dprintf( D_ALWAYS, "zlib (inflateEnd): %d\n", rval );
			Suicide();
		}
		condor_free(zstr);
		zstr = NULL;
		condor_free(zbuf);
		zbuf = Z_NULL;
	}
#endif

	dprintf(D_CKPT, "RestoreStack() Exit!\n");
	
	_condor_signals_enable();

	LONGJMP( Env, 1 );
}

int
Image::Write( int incremental )
{
	dprintf( D_ALWAYS, "Image::Write(): fd %d file_name %s\n",
			 fd, file_name?file_name:"(NULL)");
	if (fd == -1) {
		return Write( file_name, incremental );
	} else {
		return Write( fd, incremental );
	}
}

void
Image::MSync()
{
	for (int i=0; i < head.N_Segs(); i++) {
		map[i].MSync();
	}
}

/*
  Set up a stream to write our checkpoint information onto, then write
  it.  Note: there are two versions of "open_ckpt_stream", one in
  "local_startup.c" to be linked with programs for "standalone"
  checkpointing, and one in "remote_startup.c" to be linked with
  programs for "remote" checkpointing.  Of course, they do very different
  things, but in either case a file descriptor is returned which we
  should access in LOCAL and UNMAPPED mode.
*/
int
Image::Write( const char *ckpt_file, int incremental )
{
	int	fd;
	int	status;
	int	scm;
	int bytes_read;
	char	tmp_name[ _POSIX_PATH_MAX ];
#if defined(ALPHA)
	unsigned int  nbytes;		// 32 bit unsigned
#else
	unsigned long  nbytes;		// 32 bit unsigned
#endif

	if( ckpt_file == 0 ) {
		ckpt_file = file_name;
	}

	if( MyImage.GetMode() == REMOTE ) {
		// In remote mode we update the shadow on our image size
		report_image_size( (MyImage.GetLen() + KILO - 1) / KILO );

		// Get checkpoint parameters from the shadow
		int mode = get_ckpt_mode(check_sig);
		if (mode > 0) {
			condor_compress_ckpt = (mode&CKPT_MODE_USE_COMPRESSION) ? 1 : 0;
			if (mode&CKPT_MODE_SLOW) {
				condor_slow_ckpt = get_ckpt_speed();
				dprintf(D_ALWAYS, "Checkpointing at %d KB/s.\n",
						condor_slow_ckpt);
			} else {
				condor_slow_ckpt = 0;
			}
			if (mode&CKPT_MODE_MSYNC) {
				dprintf(D_ALWAYS,
						"Performing an msync() on all dirty pages...\n");
				MSync();
			}
			if (mode&CKPT_MODE_ABORT) {
				dprintf(D_ALWAYS, "Checkpoint aborted by shadow request.\n");
				return -1;
			}
		} else {
			condor_compress_ckpt = condor_slow_ckpt = 0;
		}
		head.ResetMagic();			// set magic according to compression mode
	}


		// Generate tmp file name
	dprintf( D_ALWAYS, "Checkpoint name is \"%s\"\n", ckpt_file );

		// Open the tmp file
	scm = SetSyscalls( SYS_LOCAL | SYS_UNMAPPED );
	tmp_name[0] = '\0';
	/* For now we comment out the open_url() call because we are currently
	 * inside of a signal handler.  POSIX says malloc() is not safe to call
	 * in a signal handler; open_url calls malloc() and this messes up
	 * checkpointing on SGI IRIX6 bigtime!!  so it is commented out for
	 * now until we get rid of all mallocs in open_url() -Todd T, 2/97 */
	// if( (fd=open_url(ckpt_file,O_WRONLY|O_TRUNC|O_CREAT,len)) < 0 ) {
		sprintf( tmp_name, "%s.tmp", ckpt_file );
		dprintf( D_ALWAYS, "Tmp name is \"%s\"\n", tmp_name );
#if defined(COMPRESS_CKPT)
		/* If we are writing a compressed checkpoint, we don't send the file
		   size, since we don't know it yet.  The file transfer code accepts
		   a file size of -1 to mean that the size is unknown. */
		if ((fd = open_ckpt_file(tmp_name, O_WRONLY|O_TRUNC|O_CREAT,
								 condor_compress_ckpt ? -1 : len)) < 0)  {
#else
		if ((fd = open_ckpt_file(tmp_name, O_WRONLY|O_TRUNC|O_CREAT,
								 len)) < 0)  {
#endif
			dprintf( D_ALWAYS, "ERROR:open_ckpt_file failed, aborting ckpt\n");
			return -1;
		}
	// }  // this is the matching brace to the open_url; see comment above

		// Write out the checkpoint
	if( Write(fd, incremental ) < 0 ) {
		return -1;
	}

		// Have to check close() in AFS
	dprintf( D_ALWAYS, "About to close ckpt fd (%d)\n", fd );
	if( close(fd) < 0 ) {
		dprintf( D_ALWAYS, "Close failed!\n" );
		return -1;
	}
	dprintf( D_ALWAYS, "Closed OK\n" );

	SetSyscalls( scm );

		// We now know it's complete, so move it to the real ckpt file name
	if (tmp_name[0] != '\0') {
		dprintf(D_ALWAYS, "About to rename \"%s\" to \"%s\"\n",
				tmp_name, ckpt_file);
		if( rename(tmp_name,ckpt_file) < 0 ) {
			dprintf( D_ALWAYS, "rename failed, aborting ckpt\n" );
			return -1;
		}
		dprintf( D_ALWAYS, "Renamed OK\n" );
	}

		// Report
	dprintf( D_ALWAYS, "USER PROC: CHECKPOINT IMAGE SENT OK\n" );

	return 0;
}

/*
  Write our checkpoint "image" to a given file descriptor.  At this level
  it makes no difference whether the file descriptor points to a local
  file, a remote file, or another process (for direct migration).
  TODO: This is where we put the code to use our bitmap of dirty pages
  to stop writing sequential checkpoints and start writing incremental ones
*/
int
Image::Write( int fd, int incremental )
{
	int		i;
	int		pos = 0;
	int		nbytes;
	int		ack;
	int		status;

#if defined(COMPRESS_CKPT)
	if (condor_compress_ckpt) {
		condor_morecore(0);			// initialize alt heap before we write head
	}
#endif

		// Write out the header
	if( (nbytes=write(fd,&head,sizeof(head))) < 0 ) {
		return -1;
	}
	pos += nbytes;
	dprintf( D_ALWAYS, "Wrote headers OK\n" );

		// Write out the SegMaps
	if( (nbytes=write(fd,map,sizeof(SegMap)*head.N_Segs()))
		!= sizeof(SegMap)*head.N_Segs() ) {
		return -1;
	}
	pos += nbytes;
	dprintf( D_ALWAYS, "Wrote all SegMaps OK\n" );

#if defined(COMPRESS_CKPT)
	if (condor_compress_ckpt) {
		dprintf( D_ALWAYS, "Writing compressed segments...\n" );
		zstr = (z_stream *) condor_malloc(sizeof(z_stream));
		if (!zstr) {
			dprintf( D_ALWAYS, "out of memory in condor_malloc!\n");
			Suicide();
		}
		zbuf = (unsigned char *) condor_malloc(zbufsize);
		if (!zbuf) {
			dprintf( D_ALWAYS, "out of memory in condor_malloc!\n");
			Suicide();
		}
		zstr->zalloc = zalloc;
		zstr->zfree = zfree;
		zstr->opaque = Z_NULL;
		if (deflateInit(zstr, Z_DEFAULT_COMPRESSION) != Z_OK) {
			dprintf( D_ALWAYS, "zlib (deflateInit): %s\n", zstr->msg );
			Suicide();
		}
	}
#endif

		// Write out the Segments
	for( i=0; i<head.N_Segs(); i++ ) {
		/*map[i].Display();*/
		// actually can just put the incremental writing into the segment
		// write function
		if( (nbytes=map[i].Write(fd,pos,incremental)) < 0 ) {
			dprintf( D_ALWAYS, "Write() Segment[%d] of type %s -> FAILED\n", i,
				map[i].GetName() );
			dprintf( D_ALWAYS, "errno = %d, nbytes = %d\n", errno, nbytes );
			return -1;
		}
		pos += nbytes;
		dprintf( D_ALWAYS, "Wrote Segment[%d] of type %s -> OK\n", i, 
				map[i].GetName() );
	}

#if defined(COMPRESS_CKPT)
	if (condor_compress_ckpt) {
		int bytes_to_go, rval;
		unsigned char *ptr;

		zstr->next_out = zbuf;
		zstr->avail_out = zbufsize;
		if (deflate(zstr, Z_FINISH) != Z_STREAM_END) {
			dprintf( D_ALWAYS, "zlib (deflate): %s\n", zstr->msg );
			Suicide();
		}
		for (bytes_to_go = (zbufsize-zstr->avail_out), ptr = zbuf;
			 bytes_to_go > 0;
			 bytes_to_go -= rval, ptr += rval, zstr->avail_out += rval) {
			rval = write(fd,ptr,bytes_to_go);
			if (rval < 0) {
				dprintf(D_ALWAYS, "write failed with errno %d in "
						"SegMap::Write\n", errno);
				Suicide();
			}
		}
		if (zstr->avail_out != zbufsize) {
			dprintf(D_ALWAYS, "deflate logic error, avail_out (%d) != "
					"zbufsize (%d)\n", zstr->avail_out, zbufsize);
			Suicide();
		}

		zstr->avail_out = 0;
		zstr->next_out = Z_NULL;
		condor_free(zbuf);
		zbuf = Z_NULL;
	
		rval = deflateEnd(zstr);
		if (rval != Z_OK) {
			dprintf( D_ALWAYS, "zlib (deflateEnd): %d\n", rval );
			Suicide();
		}
		condor_free(zstr);
		zstr = NULL;
	}
#endif

	dprintf( D_ALWAYS, "Wrote all Segments OK\n" );

		/* When using the stream protocol the shadow echo's the number
		   of bytes transferred as a final acknowledgement.  If, however,
		   we wrote a compressed checkpoint, then our peer won't know
		   that we have finished until we close the socket, so we can't
		   expect the acknowledgement. */
#if defined(COMPRESS_CKPT)
	if( _condor_in_file_stream && !condor_compress_ckpt ) {
#else
	if( _condor_in_file_stream ) {
#endif
		status = net_read( fd, &ack, sizeof(ack) );
		if( status < 0 ) {
			dprintf( D_ALWAYS, "Can't read final ack from the shadow\n" );
			return -1;
		}

		ack = ntohl( ack );	// Ack is in network byte order, fix here
		if( ack != len ) {
			dprintf( D_ALWAYS, "Ack - expected %d, but got %d\n", len, ack );
			return -1;
		}
	}

	return 0;
}


/*
  Read in our checkpoint "image" from a given file descriptor.  The
  descriptor could point to a local file, a remote file, or another
  process (in the case of direct migration).  Here we only read in
  the image "header" and the maps describing the segments we need to
  restore.  The Restore() function will do the rest.
*/
int
Image::Read()
{
	int		i;
	int		nbytes;

		// Make sure we have a valid file descriptor to read from
	if( fd < 0 && file_name && file_name[0] ) {
//		if( (fd=open_url(file_name,O_RDONLY,0)) < 0 ) {
			if( (fd=open_ckpt_file(file_name,O_RDONLY,0)) < 0 ) {
				dprintf( D_ALWAYS, "open_ckpt_file failed: %s",
						 strerror(errno));
				return -1;
			}
//		}		// don't use URL library -- Jim B.
	}

		// Read in the header
	if( (nbytes=net_read(fd,&head,sizeof(head))) < 0 ) {
		return -1;
	}
	pos += nbytes;
	dprintf( D_ALWAYS, "Read headers OK\n" );

		// Read in the segment maps
	for( i=0; i<head.N_Segs(); i++ ) {
		if( (nbytes=net_read(fd,&map[i],sizeof(SegMap))) < 0 ) {
			return -1;
		}
/*		map[i].Display();*/
		pos += nbytes;
		dprintf( D_ALWAYS, "Read SegMap[%d](%s) OK\n", i, map[i].GetName() );
	}
	dprintf( D_ALWAYS, "Read all SegMaps OK\n" );

	return 0;
}

void
Image::Close()
{
	if( fd < 0 ) {
		dprintf( D_ALWAYS, "Image::Close - file not open!\n" );
	}
	close( fd );
	/* The next checkpoint is going to assume the fd is -1, so set it here */
	fd = -1;
}

// get the number of pages used to contain this segment in memory
// basically just len / getpagesize, but have to check for partial pages
// on the front and back.  Probably not necessary to check for partial front
// page bec. most systems will start segments on page boundaries . . . 
long
SegMap::GetPageCount() {

	char * firstpage, * endaddress, *lastpage;
	bool partialFrontPage, partialBackPage;

	firstpage = condor_getpagestart((char *)core_loc);
	endaddress = (char *)(core_loc + len);
	lastpage =  condor_getpagestart((char *)endaddress);
	partialFrontPage = (firstpage != (char *)core_loc);
	partialBackPage  = (lastpage  != endaddress);

	/*
	dprintf( D_ALWAYS, "core_loc is Ox%x, firstpage is 0x%x, endaddress is "
	"Ox%x\n\tlastpage is Ox%x, partialFrontPage is %i, partialBackPage is %i\n",
	core_loc,firstpage,endaddress,lastpage,partialFrontPage,partialBackPage );
	*/

	return
	len / getpagesize() + (int) partialFrontPage + (int) partialBackPage;
}

/* a function for incremental ckpting.  Mprotect the segment in memory */
BOOL
SegMap::Mprotect( int prot ) 
{
	char * start = condor_getpagestart((char *)GetLoc());
	dprintf( D_ALWAYS, "Mprotecting segment %s. Start 0x%x, len %d\n", 
			GetName(), start, GetLen());
	/* should we protect the boundary pages?? */
	condor_mprotect (start, len, prot);
	return true;
}

ssize_t
SegMap::Read( int fd, ssize_t pos )
{
	int		nbytes;
	char *orig_brk;
	char *cur_brk;
	char	*ptr;
	int		bytes_to_go;
	int		read_size;
	long	saved_len = len;
	int 	saved_prot = prot;
	RAW_ADDR	saved_core_loc = core_loc;

	if( pos != file_loc ) {
		dprintf( D_ALWAYS, "Checkpoint sequence error (%d != %d)\n", pos,
				 file_loc );
		Suicide();
	}

	dprintf(D_CKPT, "Restoring a %s segment\n", name);

	if( mystrcmp(name,"DATA") == 0 ) {
		orig_brk = (char *)sbrk(0);
		if( orig_brk < (char *)(core_loc + len) ) {
			brk( (char *)(core_loc + len) );
		}
		cur_brk = (char *)sbrk(0);
		dprintf(D_ALWAYS, 
			"Found a DATA block, increasing heap from 0x%x to 0x%x\n", 
			orig_brk, cur_brk);
	}

#if defined(HAS_DYNAMIC_USER_JOBS)
	else if ( mystrcmp(name,"SHARED LIB") == 0) {
		int zfd, segSize = len;
		if ((zfd = SYSCALL(SYS_open, "/dev/zero", O_RDWR)) == -1) {
			dprintf( D_ALWAYS,
					 "Unable to open /dev/zero in read/write mode.\n");
			dprintf( D_ALWAYS, "open: %s\n", strerror(errno));
			Suicide();
		}

	  /* Some notes about mmap:
		 - The MAP_FIXED flag will ensure that the memory allocated is
		   exactly what was requested.
		 - Both the addr and off parameters must be aligned and sized
		   according to the value returned by getpagesize() when MAP_FIXED
		   is used.  If the len parameter is not a multiple of the page
		   size for the machine, then the system will automatically round
		   up. 
		 - Protections must allow writing, so that the dll data can be
		   copied into memory. 
		 - Memory should be private, so we don't mess with any other
		   processes that might be accessing the same library. */

#if defined(Solaris) || defined(LINUX)
		if ((MMAP((MMAP_T)core_loc, (size_t)segSize,
				  prot|PROT_WRITE,
				  MAP_PRIVATE|MAP_FIXED, zfd,
				  (off_t)0)) == MAP_FAILED) {
#elif defined(IRIX)
		if (MMAP((caddr_t)saved_core_loc, (size_t)segSize,
				 (saved_prot|PROT_WRITE)&(~MA_SHARED),
				 MAP_PRIVATE|MAP_FIXED, zfd,
				 (off_t)0) == MAP_FAILED) {
#endif

			dprintf(D_ALWAYS, "mmap: %s", strerror(errno));
			dprintf(D_ALWAYS, "Attempted to mmap /dev/zero at "
				"address 0x%x, size 0x%x\n", saved_core_loc,
				segSize);
			dprintf(D_ALWAYS, "Current segmap dump follows\n");
			display_prmap();
			Suicide();
		}

		/* WARNING: We have potentially just overwritten libc.so.  Do
		   not make calls that are defined in this (or any other)
		   shared library until we restore all shared libraries from
		   the checkpoint (i.e., use mystrcmp and SYSCALL).  -Jim B. */

		if (SYSCALL(SYS_close, zfd) < 0) {
			dprintf( D_ALWAYS,
					 "Unable to close /dev/zero file descriptor.\n" );
			dprintf( D_ALWAYS, "close: %s\n", strerror(errno));
			Suicide();
		}
	}		
#endif		

		// This overwrites an entire segment of our address space
		// (data or stack).  Assume we have been handed an fd which
		// can be read by purely local syscalls, and we don't need
		// to need to mess with the system call mode, fd mapping tables,
		// etc. as none of that would work considering we are overwriting
		// them.
	bytes_to_go = saved_len;
	ptr = (char *)saved_core_loc;

	dprintf(D_ALWAYS, 
		"About to overwrite 0x%x bytes starting at 0x%x(%s)\n", 
			bytes_to_go, ptr, name);

#if defined(COMPRESS_CKPT)
	if (zstr) {
		/*struct*/ z_stream *saved_zstr = zstr;
		unsigned char *saved_zbuf = zbuf;
		saved_zstr->next_out = (unsigned char *)saved_core_loc;
		saved_zstr->avail_out = saved_len;
		while (saved_zstr->avail_out > 0) {
			// make at least 32 bytes available
			if (saved_zstr->avail_in < 32) {
				if (saved_zstr->avail_in > 0) {
					memcpy(saved_zbuf, saved_zstr->next_in,
						   saved_zstr->avail_in);
				}
				nbytes = SYSCALL(SYS_read, fd,
								 saved_zbuf+saved_zstr->avail_in,
								 zbufsize-saved_zstr->avail_in);
				if (nbytes > 0) {
					saved_zstr->avail_in += nbytes;
				}
				saved_zstr->next_in = saved_zbuf;
			}
			if (inflate(saved_zstr, Z_PARTIAL_FLUSH) != Z_OK &&
				saved_zstr->avail_out > 0) {
				dprintf( D_ALWAYS, "zlib (inflate): %s\n", saved_zstr->msg );
				Suicide();
			}
		}
		zstr = saved_zstr;
		zbuf = saved_zbuf;
		return pos + saved_len;
	}
#endif

	while( bytes_to_go ) {
		read_size = bytes_to_go > 65536 ? 65536 : bytes_to_go;
#if defined(HAS_DYNAMIC_USER_JOBS)
		nbytes =  SYSCALL(SYS_read, fd, (void *)ptr, read_size );
#else
		nbytes =  syscall( SYS_read, fd, (void *)ptr, read_size );
#endif
		if( nbytes < 0 ) {
			dprintf(D_ALWAYS, "in Segmap::Read(): fd = %d, read_size=%d\n", fd,
				read_size);
			dprintf(D_ALWAYS, "core_loc=%x, nbytes=%d\n",
				core_loc, nbytes);
			return -1;
		}
		bytes_to_go -= nbytes;
		ptr += nbytes;
	}

	return pos + len;
}

// can add the code here to do incremental ckpting
ssize_t
SegMap::Write( int fd, ssize_t pos, int incremental )
{
	if( pos != file_loc && ! incremental ) {
		dprintf( D_ALWAYS, "Checkpoint sequence error (%d != %d)\n",
				 pos, file_loc );
		Suicide();
	}
#if defined(COMPRESS_CKPT)
	if (condor_compress_ckpt) {
		int bytes_to_go, rval, old_avail_in;
		unsigned char *ptr;

		zstr->next_in = (unsigned char *)core_loc;
		zstr->avail_in = len;
		while (zstr->avail_in > 0) {
			zstr->next_out = zbuf;
			zstr->avail_out = zbufsize;
			old_avail_in = zstr->avail_in;
			if (deflate(zstr, Z_PARTIAL_FLUSH) != Z_OK) {
				dprintf( D_ALWAYS, "zlib (deflate): %s\n", zstr->msg );
				Suicide();
			}
			for (bytes_to_go = (zbufsize-zstr->avail_out), ptr = zbuf;
				 bytes_to_go > 0;
				 bytes_to_go -= rval, ptr += rval, zstr->avail_out += rval) {
				// note: bytes_to_go <= 65536 (bufsize)
				rval = write(fd,ptr,bytes_to_go);
				if (rval < 0) {
					dprintf(D_ALWAYS, "write failed with errno %d in "
							"SegMap::Write\n", errno);
					Suicide();
				}
			}
			if (condor_slow_ckpt) {
				// write condor_slow_ckpt KB per second
				sleep(((old_avail_in-zstr->avail_in)/
					   (condor_slow_ckpt*KILO))+1);
			}
			if (zstr->avail_out != zbufsize) {
				dprintf(D_ALWAYS, "deflate logic error, avail_out (%d) != "
						"zbufsize (%d)\n", zstr->avail_out, zbufsize);
				Suicide();
			}
		}
		return len;
	}
#endif
	dprintf( D_ALWAYS, "write(fd=%d,core_loc=0x%x,len=0x%x)\n",
			fd, core_loc, len );

	if ( strcmp("DATA", name) == 0 && incremental) 
		return WriteIncremental( fd, pos );

	int bytes_to_go = len, nbytes;
	int writes = 0;

	char *ptr = (char *)core_loc;
	while (bytes_to_go) {
		size_t write_size;
		if (condor_slow_ckpt && bytes_to_go > (condor_slow_ckpt*KILO)) {
			// write condor_slow_ckpt KB per second
			write_size = condor_slow_ckpt*KILO;
		} else {
			write_size = bytes_to_go;
		}
		nbytes = write(fd,(void *)ptr,write_size);
		//dprintf(D_CKPT, "I wrote %d bytes with write...\n", nbytes);
		if ( nbytes < 0 ) {
			//dprintf( D_ALWAYS, "in SegMap::Write(): fd = %d, write_size=%d\n",
			//		 fd, bytes_to_go );
			//dprintf( D_ALWAYS, "errno=%d, core_loc=%x\n", errno, ptr );
			return -1;
		}
		writes++;
		if (condor_slow_ckpt) sleep(1);
		bytes_to_go -= nbytes;
		ptr += nbytes;
	}
	if ( strcmp("DATA", name) == 0) {
		int pages = len / getpagesize();
		MyImage.ckptinfo.writes = writes;
		MyImage.ckptinfo.pages  = pages;
		//printf( "Sequ wrote %i pages (%i writes).\n", pages, writes );
	}
	return len;
}

ssize_t
SegMap::WriteIncremental( int fd, ssize_t pos ) {

	struct Incr_ckpt_data *data = MyImage.GetIncrCkptData();
	char *ptr = (char *)core_loc;
	size_t pagesize   = getpagesize();
	size_t write_size = 0; 
	size_t nbytes = 0, length = 0; 
	int writes = 0;

	for (long i = 0; i < data->total_pages; i++) {
		write_size = 0;
		while (bitIsSet( i, data->bitmap ) ) {
			write_size += pagesize;
			if (++i == data->total_pages) break;
		}
		if (write_size) {
			//dprintf( D_ALWAYS, "writing %d bytes from Ox%x\n", write_size, (void*)ptr); 
			length = write( fd, (void *)ptr, write_size );		 
			if (length != write_size) {
				dprintf(D_ALWAYS,"in SegMap::Write(): fd = %d, write_size=%d\n",
						 fd, write_size );
				dprintf( D_ALWAYS, "errno=%d, core_loc=%x\n", errno, ptr );
				return -1;
			}
			writes++;
			nbytes += write_size;
			ptr    += write_size; 
		} else {
			ptr += pagesize;
		}  
	}

	// this is a bug that is not in the WriteIncrementalOld
	if (ptr != (char *) data->orig_brk) {
		int diff = (ptr - (char *) data->orig_brk) / pagesize; 
		//dprintf( D_ALWAYS, "ptr is Ox%x, orig_brk is Ox%x, diff is %i\n", 
		//ptr, (char*)data->orig_brk, diff );
		ptr = (char *) data->orig_brk;
	}

	// write any new pages
	write_size = MyImage.NewPages() * pagesize;
	if (write_size) {
		//dprintf( D_ALWAYS, "writing %d bytes from Ox%x\n", write_size, (void*)ptr); 
		length = write( fd, (void *)ptr, write_size );
		if (length != write_size) {
			dprintf(D_ALWAYS,"in SegMap::Write(): fd = %d, write_size=%d\n",
					 fd, write_size );
			dprintf( D_ALWAYS, "errno=%d, core_loc=%x\n", errno, ptr );
			return -1;
		}
		writes++;
		nbytes += write_size;
	}
	ptr += write_size;

	if ( ptr != (char *)core_loc + len ) {
		printf( D_ALWAYS, "WARNING: ptr is %s, dataend is %s.\n", ptr, 
			(char *)core_loc + len );
	}
	
	int pages = nbytes / getpagesize();
	//dprintf( D_ALWAYS, "Incr wrote %i pages (%i writes).\n", pages, writes );
	//printf( "Incr wrote %i pages (%i writes).\n", pages, writes );
	MyImage.ckptinfo.writes = writes;
	MyImage.ckptinfo.pages  = pages;
	if (pages != MyImage.DirtyPages() + MyImage.NewPages() ) {
		printf( "WARNING: counts are bad (%i, %i)\n", MyImage.DirtyPages(),
		MyImage.NewPages());
	}
	return nbytes;
}


ssize_t
SegMap::WriteIncrementalOld( int fd, ssize_t pos ) {

	struct Incr_ckpt_data *data = MyImage.GetIncrCkptData();
	char *ptr = (char *)core_loc;
	size_t write_size = getpagesize();
	size_t nbytes, length = 0; 
	int writes = 0;

	for (long i = 0; i < data->total_pages; i++) {
		if (bitIsSet( i, data->bitmap ) ) {
			// write each dirty page
			dprintf( D_ALWAYS, "writing %d bytes from Ox%x\n", write_size, (void*)ptr); 
			nbytes = write( fd, (void *)ptr, write_size );		 
			if (nbytes != write_size) {
				dprintf(D_ALWAYS,"in SegMap::Write(): fd = %d, write_size=%d\n",
						 fd, write_size );
				dprintf( D_ALWAYS, "errno=%d, core_loc=%x\n", errno, ptr );
				return -1;
			}
			length += nbytes;
			writes++;
		}
		// move ptr to next page
		ptr += getpagesize();	
	}

	// write any new pages
	write_size *= MyImage.NewPages();
	if (write_size) {
		dprintf( D_ALWAYS, "writing %d bytes from Ox%x\n", write_size, (void*)ptr); 
		nbytes = write( fd, (void *)ptr, write_size );
		if (nbytes != write_size) {
			dprintf(D_ALWAYS,"in SegMap::Write(): fd = %d, write_size=%d\n",
					 fd, write_size );
			dprintf( D_ALWAYS, "errno=%d, core_loc=%x\n", errno, ptr );
			return -1;
		}
		writes++;
		length += nbytes;
	}

	ptr += write_size;
	if ( ptr != (char *)core_loc + len ) {
		printf( D_ALWAYS, "WARNING: ptr is %s, dataend is %s.\n", ptr, 
			(char *)core_loc + len );
	}
	
	int pages = length / getpagesize();
	//dprintf( D_ALWAYS, "Incr wrote %i pages (%i writes).\n", pages, writes );
	//printf( "Incr wrote %i pages (%i writes).\n", pages, writes );
	MyImage.ckptinfo.writes = writes;
	MyImage.ckptinfo.pages  = pages;
	if (pages != MyImage.DirtyPages() + MyImage.NewPages() ) {
		printf( "WARNING: counts are bad (%i, %i)\n", MyImage.DirtyPages(),
		MyImage.NewPages());
	}
	return length;
}

#define MILLION 1000000
long
time_diff( struct timeval start, struct timeval end ) {

    long micros = end.tv_sec * MILLION + end.tv_usec;
    micros -= (start.tv_sec * MILLION + start.tv_usec);

    return micros;
}

void
printTms( struct tms *tms ) {

	fprintf( stderr, "utime: %7.2f, stime: %7.2f\n", tms->tms_utime, tms->tms_stime );
} 

float
time_diff( struct tms * start, struct tms * end, long clicks ) {

	fprintf( stderr, "clicks is %d\n" );
	printTms( start );
	printTms( end );

	float diff = (end->tms_utime - start->tms_utime) / clicks;
	diff      += (end->tms_stime - start->tms_stime) / clicks;		

	return diff;
}


extern "C" {

/*
  This is the signal handler which actually effects a checkpoint.  This
  must be implemented as a signal handler, since we assume the signal
  handling code provided by the system will save and restore important
  elements of our context (register values, etc.).  A process wishing
  to checkpoint itself should generate the correct signal, not call this
  routine directory, (the ckpt()) function does this.
  8/95: And now, SIGTSTP means "checkpoint and vacate", and other signal
  that gets here (aka SIGUSR2) means checkpoint and keep running (a 
  periodic checkpoint). -Todd Tannenbaum
*/
void
#if defined( HPUX10 )
Checkpoint( int sig, siginfo_t *code, void *scp )
#else
Checkpoint( int sig, int code, void *scp )
#endif
{
	int		scm, p_scm;
	int		do_full_restart = 1; // set to 0 for periodic checkpoint
	int		write_result;
	struct	timezone tz;
	struct 	timeval  startTime, endTime;
	struct  tms tmsstart, tmsend;
	clock_t start_time, end_time;
	char 	TIMING[256];
	long	clock_tick;

	/*
		WARNING: Do not put any code here. This check prevents a race condition.
		The Checkpoint signal could arrive before we block the signal, thus
		causing a checkpoint within a checkpoint.  We _could_ prevent this race
		condition by using sigaction to automatically set the signal mask, but
		then the user's mask would not be available to be saved by
		_condor_save_sigstate.
	*/

	if( InRestart ) {
		if ( sig == SIGTSTP )
			Suicide();		// if we're supposed to vacate, kill ourselves
		else {
			return;			// if periodic ckpt or we're currently ckpting
		}
	} else {
		InRestart = TRUE;
	}

	/*
		WARNING: Do not put any code here either.  _condor_save_sigstate() will
		save the user's signal mask, block all signals, and then save all the
		other associated signal state.  This must be the first action in
		Checkpoint after the race condition check above.
	*/

	_condor_save_sigstates();
	dprintf( D_ALWAYS, "Saved signal state.\n");

	check_sig = sig;

	// turn off mprotect used by incremental checkpointing
	// any new dirtiness is caused by checkpoint code not user
	if (condor_incremental_ckpt) MyImage.Mprotect( PROT_READ | PROT_WRITE ); 


#if defined(OSF1)
		clock_tick = CLK_TCK;
#else
		clock_tick = sysconf( _SC_CLK_TCK );
#endif


	if( MyImage.GetMode() == REMOTE ) {
		scm = SetSyscalls( SYS_REMOTE | SYS_UNMAPPED );
#if !defined(PVM_CHECKPOINTING)
		if ( MyImage.GetFd() != -1 ) {
			// Here we make _certain_ that fd is -1.  on remote checkpoints,
			// the fd is always new since we open a fresh TCP socket to the
			// shadow.  I have detected some buggy behavior where the remote
			// job prematurely exits with a status 4, and think that it is
			// related to the fact that fd is _not_ -1 here, so we make
			// certain.  Hopefully the real bug will be found someday and
			// this "patch" can go away...  -Todd 11/95
			
		dprintf(D_ALWAYS,"WARNING: fd is %d for remote checkpoint, should be -1\n",MyImage.GetFd());
		MyImage.SetFd( -1 );
		}
#endif

		/* now update shadow with CPU time info.  unfortunately, we need
		 * to convert to struct rusage here in the user code, because
		 * clock_tick is platform dependent and we don't want CPU times
		 * messed up if the shadow is running on a different architecture */
		/* We do this before we write the checkpoint now, so the shadow
		 * can send usage info to the checkpoint server with the checkpoint.
		 * The usage is committed with the checkpoint. -Jim B. */
		struct tms posix_usage;
		struct rusage bsd_usage;

		p_scm = SetSyscalls( SYS_LOCAL | SYS_UNMAPPED );
		memset(&bsd_usage,0,sizeof(struct rusage));
		times( &posix_usage );
		bsd_usage.ru_utime.tv_sec = posix_usage.tms_utime / clock_tick;
		bsd_usage.ru_utime.tv_usec = posix_usage.tms_utime % clock_tick;
		(bsd_usage.ru_utime.tv_usec) *= 1000000 / clock_tick;
		bsd_usage.ru_stime.tv_sec = posix_usage.tms_stime / clock_tick;
		bsd_usage.ru_stime.tv_usec = posix_usage.tms_stime % clock_tick;
		(bsd_usage.ru_stime.tv_usec) *= 1000000 / clock_tick;
		SetSyscalls( SYS_REMOTE | SYS_UNMAPPED );
		(void)REMOTE_syscall( CONDOR_send_rusage, (void *) &bsd_usage );
		SetSyscalls( p_scm );

	} else {
		scm = SetSyscalls( SYS_LOCAL | SYS_UNMAPPED );
	}


	if ( sig == SIGTSTP ) {
		dprintf( D_ALWAYS, "Got SIGTSTP\n" );
	} else {
		dprintf( D_ALWAYS, "Got SIGUSR2\n" );
	}

#undef WAIT_FOR_DEBUGGER
#if defined(WAIT_FOR_DEBUGGER)
	int		wait_up = 1;
	while( wait_up )
		;
#endif
	if( SETJMP(Env) == 0 ) {	// Checkpoint
		dprintf( D_ALWAYS, "About to save file state\n");
		if( sig==SIGTSTP ) {
			// Suspend all operations and save files
			_condor_file_table_suspend();
		} else {
			// A periodic safety checkpoint
			_condor_file_table_checkpoint();
		}
		dprintf( D_ALWAYS, "Done saving file state\n");

		dprintf( D_ALWAYS, "About to save MyImage\n" );
		MyImage.Save();
		/* 	Here is the code to print out dirty page count from last checkpoint.
			Also, at this point can unmap the old incrCkptData segment
			This will be the point to change the code to just write dirty pages
		*/
		if 	( _condor_numrestarts > 0 && condor_incremental_ckpt ) {
			dprintf( D_ALWAYS, "Dirty DATA pages: %d / %d (%d new)\n", 
			MyImage.DirtyPages(), MyImage.TotalPages(), MyImage.NewPages() );
			MyImage.PrintBitmap();
				// for some reason, attempting to unmap the old seg will crash
			//MyImage.DestroyIncrCkptSegment( );


			// first do an incremental ckpt to get the timing, then do 
			// a real one so we can do a restart
				// start the clock
    		if ( gettimeofday( &startTime, &tz ) < 0 ) {
    		    dprintf( D_ALWAYS, "Couldn't set start time.\n" );
    		}
			// need to restore back to old value however
				// this doesn't help
			// SetSyscalls( SYS_LOCAL | SYS_UNMAPPED );
			if ( (start_time = times( &tmsstart )) < 0) {
    		    dprintf( D_ALWAYS, "Couldn't set start time(1).\n" );
			}
			write_result = MyImage.Write(condor_incremental_ckpt);
			if ( (end_time = times( &tmsend )) == -1 ) {
    		    dprintf( D_ALWAYS, "Couldn't set end time(1).\n" );
			}	
			if ( gettimeofday( &endTime, &tz ) < 0 ) {
    		    dprintf( D_ALWAYS, "Couldn't set end time.\n" );
			}	
			long ckptTime1 = time_diff( startTime, endTime );
			printf( "%i:%i:%i:%i:%d:%i:%i\n", 
					ckptTime1,
					tmsend.tms_utime - tmsstart.tms_utime,
					tmsend.tms_stime - tmsstart.tms_stime,
					_condor_numrestarts,
					1, // for incremental
					MyImage.ckptinfo.pages,
					MyImage.ckptinfo.writes
					);
		}


			// now do the real image write, time it as well
    	if ( gettimeofday( &startTime, &tz ) < 0 ) {
    	    dprintf( D_ALWAYS, "Couldn't set start time.\n" );
    	}
		if ( (start_time = times( &tmsstart )) < 0) {
    	    dprintf( D_ALWAYS, "Couldn't set start time(1).\n" );
		}
		write_result = MyImage.Write(0);
		if ( (start_time = times( &tmsend )) < 0) {
    	    dprintf( D_ALWAYS, "Couldn't set start time(1).\n" );
		}
		if ( gettimeofday( &endTime, &tz ) < 0 ) {
    	    dprintf( D_ALWAYS, "Couldn't set start time.\n" );
		}	
		long ckptTime = time_diff( startTime, endTime );
		if (_condor_numrestarts > 0) {
			printf( "%i:%i:%i:%i:%d:%i:%i\n", 
				ckptTime,
				tmsend.tms_utime - tmsstart.tms_utime,
				tmsend.tms_stime - tmsstart.tms_stime,
				_condor_numrestarts,
				0, // for incremental
				MyImage.ckptinfo.pages,
				MyImage.ckptinfo.writes
				);
		}

		if ( sig == SIGTSTP ) {
			/* we have just checkpointed; now time to vacate */
			dprintf( D_ALWAYS,  "Ckpt exit\n" );
			SetSyscalls( SYS_LOCAL | SYS_UNMAPPED );
			if ( write_result == 0 ) {
				terminate_with_sig( SIGUSR2 );
/*				terminate_with_sig( SIGKILL );*/
			} else {
				dprintf(D_ALWAYS, "Write failed with [%d]\n", write_result);
				Suicide();
			}
			/* should never get here */
			dprintf(D_ALWAYS, "You should never see this line in the log!\n");
		} else {
			if ( MyImage.GetMode() == REMOTE ) {

				// first, reset the fd to -1.  this is normally done in
				// a call in remote_startup, but that will not get called
				// before the next periodic checkpoint so we must clear
				// it here.
				MyImage.SetFd( -1 );

			}
			do_full_restart = 0;
			dprintf(D_ALWAYS, "Periodic Ckpt complete, doing a virtual restart...\n");
			LONGJMP( Env, 1);
		}
	} else {					// Restart
		if ( do_full_restart ) {
			scm = SetSyscalls( SYS_LOCAL | SYS_UNMAPPED );
			patch_registers( scp );
			MyImage.Close();

			if( MyImage.GetMode() == REMOTE ) {
				SetSyscalls( SYS_REMOTE | SYS_MAPPED );
			} else {
				SetSyscalls( SYS_LOCAL | SYS_MAPPED );
			}

			dprintf( D_ALWAYS, "About to restore file state\n");
			_condor_file_table_resume();

			dprintf( D_ALWAYS, "Done restoring file state\n" );
			int mode = get_ckpt_mode(0);
			if (mode > 0) {
				if (mode&CKPT_MODE_MSYNC) {
					dprintf(D_ALWAYS,
							"Performing an msync() on all dirty pages...\n");
					MyImage.MSync();
				}
				if (mode&CKPT_MODE_ABORT) {
					dprintf(D_ALWAYS, "Restart aborted by shadow request.\n");
					Suicide();
				}
			}
		} else {
			patch_registers( scp );
		}

#ifdef HPUX10
	/* TODD'S SCARY FIX TO THE HPUX10.X FORTRAN PROBLEM ------
	 * reset the return-pointer in the current stack frame
	 * to _sigreturn, as it sometimes is a screwed-up address during
	 * a restart with HPUX10 Fortran. weird trampoline code in HPUX f77?
	 * We find the return-pointer in the stack frame by adding an offset (16)
	 * from the address of the 1st parameter on the frame. (in this case, &sig)
	 * WARNING: we are only dealing here with 32-bit RP addresses!  We
	 * may need to make this patch more intelligent someday.
	 * WANRING: do not move this code to a different procedure/func,
	 * we need to twiddle _this_ stack frame and &sig is only in scope
	 * here in Checkpoint().  -Todd, 4/97 */
		*((unsigned int *)( ((unsigned int) &sig)+16 )) = (unsigned int) _sigreturn;
#endif

		// Here we check if we received checkpoint&exit signal
		// while all this was going on.  
		SetSyscalls(SYS_LOCAL | SYS_UNRECORDED);
		sigset_t pending_sig_set;
		sigpending( &pending_sig_set );
		if ( sigismember(&pending_sig_set,SIGTSTP) ) {
			dprintf(D_ALWAYS,
				"Received a SIGTSTP while checkpointing or restarting.\n");
			if ( do_full_restart ) {
				// Here we were restarting, and while our checkpoint
				// signal was perhaps blocked we were asked to checkpoint
				// and exit.
				// May as well do a suicide.
				Suicide();
			} else {
				// Here we just completed a periodic checkpoint, and
				// while our checkpoint signal was blocked we received
				// a checkpoint and exit.  Since we just finished 
				// writing out a checkpoint, we may as well exit with
				// SIGUSR2 which tells the starter we exited OK after
				// a checkpoint.
				terminate_with_sig(SIGUSR2);
			}
		}
		_condor_numrestarts++;
		SetSyscalls( scm );

		/*
			WARNING: The restoring of signal states must be the last
			thing that happens in a checkpoint restart.  Once this 
			function returns, the user's signal handlers are installed
			and the saved signal state is replaced, so nothing that
			is signal-unsafe can follow this restore.
		*/

		dprintf( D_ALWAYS, "About to restore signal state\n" );
		_condor_restore_sigstates();

		// need to do mprotect here following restart - JMB
		if (condor_incremental_ckpt) {
			dprintf( D_ALWAYS, "About to mprotect and setup new segment\n");
			MyImage.InitIncrCkptSegment( );
			MyImage.Mprotect ( PROT_READ );
		}
		dprintf( D_ALWAYS, "About to return to user code\n"  );
		InRestart = FALSE;
		return;
	}
}

void
init_image_with_file_name( char *ckpt_name )
{
	MyImage.SetFileName( ckpt_name );
}

void
init_image_with_file_descriptor( int fd )
{
	MyImage.SetFd( fd );
}

#ifdef linux
char * 
condor_getfaultaddr( void *context ) {
	return (char*)(((struct ucontext *)context)->uc_mcontext.cr2);
}
#endif

/*
  Effect a restart by reading in an "image" containing checkpointing
  information and then overwriting our process with that image.
  All signals are disabled while this is in progress.
*/
void
restart( )
{
	sigset_t mask;

	sigfillset( &mask );
	sigprocmask( SIG_SETMASK, &mask, 0 );

	InRestart = TRUE;
	if (MyImage.Read() < 0) Suicide();
	MyImage.Restore();
}

}	// end of extern "C"



/*
  Checkpointing must by implemented as a signal handler.  This routine
  generates the required signal to invoke the handler.
  ckpt() = periodic ckpt
  ckpt_and_exit() = ckpt and "vacate"
*/
extern "C" {
void
ckpt()
{
	int		scm;

	dprintf( D_ALWAYS, "About to send CHECKPOINT signal to SELF\n" );
	scm = SetSyscalls( SYS_LOCAL | SYS_UNMAPPED );
	kill( getpid(), SIGUSR2 );
	SetSyscalls( scm );
}
void
ckpt_and_exit()
{
	int		scm;

	dprintf( D_ALWAYS, "About to send CHECKPOINT and EXIT signal to SELF\n" );
	scm = SetSyscalls( SYS_LOCAL | SYS_UNMAPPED );
	kill( getpid(), SIGTSTP );
	SetSyscalls( scm );
}

/*
** Some FORTRAN compilers expect "_" after the symbol name.
*/
void
ckpt_() {
	ckpt();
}
void
ckpt_and_exit_() {
	ckpt_and_exit();
}

/*
** Some FORTRAN compilers expect "__" after the name!
*/

void ckpt__()
{
	ckpt();
}

void ckpt_and_exit__()
{
	ckpt_and_exit();
}


}   /* end of extern "C" */

/*
  Arrange to terminate abnormally with the given signal.  Note: the
  expectation is that the signal is one whose default action terminates
  the process - could be with a core dump or not, depending on the sig.
*/
void
terminate_with_sig( int sig )
{
	sigset_t	mask;
	pid_t		my_pid;
	struct sigaction act;

	/* Note: If InRestart, avoid accessing any non-local data, as it
	   may be corrupt.  This includes calling dprintf().  Also avoid
	   calling any libc functions, since libc might be corrupt during
	   a restart. Since sigaction and sigsuspend are defined in
	   signals_support.C, they should be safe to call. -Jim B. */

		// Make sure all system calls handled "straight through"
	if (!InRestart) SetSyscalls( SYS_LOCAL | SYS_UNMAPPED );

		// Make sure we have the default action in place for the sig
	if( sig != SIGKILL && sig != SIGSTOP ) {
#ifdef HPUX10
		act.sa_handler = SIG_DFL;
#else
		act.sa_handler = (SIG_HANDLER)SIG_DFL;
#endif
		// mask everything so no user-level sig handlers run
		sigfillset( &act.sa_mask );
		act.sa_flags = 0;
		errno = 0;
		if( sigaction(sig,&act,0) < 0 ) {
			if (!InRestart) dprintf(D_ALWAYS, "sigaction: %s\n",
									strerror(errno));
			Suicide();
		}
	}

		// Send ourself the signal
	my_pid = SYSCALL(SYS_getpid);
	if (!InRestart) {
		dprintf( D_ALWAYS, "About to send signal %d to process %d\n",
				sig, my_pid );
	}

	// Sleep for 1 second to allow our debug socket to drain.  This is
	// very important for debugging when Suicide() is called, because if
	// our debug message doesn't arrive at the shadow, we won't know why
	// the job died.  Note that we don't necessarily have access to any
	// libc functions here, so we must use SYSCALL(SYS_something, ...).
#if defined(SYS_sleep)
	SYSCALL(SYS_sleep, 1);
#elif defined(SYS_select)
	struct timeval t;
	t.tv_sec = 1;
	t.tv_usec = 0;
	SYSCALL(SYS_select, 0, NULL, NULL, NULL, &t);
#elif defined(SYS_nanosleep)
	struct timespec t;
	t.tv_sec = 1;
	t.tv_nsec = 0;
	SYSCALL(SYS_nanosleep, &t, NULL);
#else
#error "Please port me!  I need a sleep system call."
#endif

	if( SYSCALL(SYS_kill, my_pid, sig) < 0 ) {
		EXCEPT( "kill" );
	}

		// Wait to die... and mask all sigs except the one to kill us; this
		// way a user's sig won't sneak in on us - Todd 12/94
		// If sig is SIGKILL, we just busy loop since the sig will be SIGKILL
		// if we are called from Suicide(), and Suicide() could be called
		// from inside our restart code before sigfillset(), sigsuspend(), etc,
		// have been mapped to anything (thus we'd exit with a SEGV instead). 
		// -Todd 12/99, "5 yrs later I'm still messing with this f(*ing code!"
	if( sig != SIGKILL && sig != SIGSTOP ) {
		sigfillset( &mask );
		sigdelset( &mask, sig );
		sigsuspend( &mask );
	} else {
		while(1);
	}

		// Should never get here
	EXCEPT( "Should never get here" );

}

// check whether bit is set in our bitmap
bool
bitIsSet( long n, char * bitmap ) {
	long whichByte = n / 8;
	int  whichBit  = n % 8;
    return ((bitmap[whichByte] << whichBit) & 0x80) != 0;
}

// set a bit in a bitmap
void
setBit( long n, char * bitmap ) {
	long whichByte = n / 8;
	int  whichBit  = n % 8;

    char temp = bitmap[whichByte];
    bitmap[whichByte] = (char)(temp | (0x80 >> whichBit));
}

// clear a bit in a bitmap
void
clearBit( long n, char * bitmap ) {
	long whichByte = n / 8;
	int  whichBit  = n % 8;

    char temp = bitmap[whichByte];
    bitmap[whichByte] = (char)(temp & ~(0x80 >> whichBit));
}

/*
  We have been requested to exit.  We do it by sending ourselves a
  SIGKILL, i.e. "kill -9".
*/
void
Suicide()
{
	terminate_with_sig( SIGKILL );
}

static void
find_stack_location( RAW_ADDR &start, RAW_ADDR &end )
{
	if( SP_in_data_area() ) {
		dprintf( D_ALWAYS, "Stack pointer in data area\n" );
		if( StackGrowsDown() ) {
			end = stack_end_addr();
			start = end - StackSaveSize;
		} else {
			start = stack_start_addr();
			end = start + StackSaveSize;
		}
	} else {
		start = stack_start_addr();
		end = stack_end_addr();
	}
}

extern "C" double atof( const char * );

const size_t	MEG = (1024 * 1024);

void
calc_stack_to_save()
{
	char	*ptr;

	ptr = getenv( "CONDOR_STACK_SIZE" );
	if( ptr ) {
		StackSaveSize = (size_t) (atof(ptr) * MEG);
	} else {
		StackSaveSize = MEG * 2;	// default 2 megabytes
	}
}

/*
  Return true if the stack pointer points into the "data" area.  This
  will often be the case for programs which utilize threads or co-routine
  packages.
*/
static int
SP_in_data_area()
{
	RAW_ADDR	data_start, data_end;
	RAW_ADDR	SP;

	data_start = data_start_addr();
	data_end = data_end_addr();

	if( StackGrowsDown() ) {
		SP = stack_start_addr();
	} else {
		SP = stack_end_addr();
	}

	return data_start <= SP && SP <= data_end;
}

/* Incremental ckpting stuff - jmb */
/* takes an address and returns the start boundary of the containing page */
char *
condor_getpagestart (char * addr) {
	char * p;
	// align to a multiple of getpagesize(), p will be >= to addr
	p = (char *)(((int) addr + getpagesize()-1) & ~(getpagesize()-1));
	if (p != addr) {
		assert (p > addr);
		p -= getpagesize();
	}	
	return p;
}

/* given a start addr and a size and a protection value, this
* will set those permissions for that memory
* NOTE: if the parameters are not page sized, this will extend the 
* protection to the page boundaries
*/
void
condor_mprotect (char * startaddr, long size, int prot) {
	char * end = startaddr + size;
	char * p = condor_getpagestart (startaddr);
	
	int diff = startaddr - p;
	int pagesize = getpagesize();
	size += diff; 
	if (size % pagesize) {
		size += (pagesize - (size % pagesize));
		assert (size % pagesize == 0);
	} 
	/* silence dprintf's cause they're maybe problematic in the signal handler*/
	/*
	dprintf( D_ALWAYS, "Gonna protect Ox%x, length %i, with prot of %i\n", 
		p, size, prot );
	*/
	// don't use mprotect, bec. it is overwritten in syscall_lib/switches.C
	if ( syscall( SYS_mprotect, p, size , prot ) < 0) {
	//if ( mprotect(p, size, prot) < 0) {
		dprintf( D_ALWAYS, "Couldn't mprotect: %i\n", errno );
		perror("Couldn't mprotect");
		Suicide();	
	}
	/*
	dprintf( D_ALWAYS, "Protected Ox%x, length %i, with prot of %i\n", 
		p, size, prot );
	*/
}

char seg_message[] = "**caught segv, will reset prots\n\0"; 

/** 
DON"T do malloc or free in the signal handler !!!
This is the signal catcher for the incremental ckpting.
*/
void
seg_handler(int signal, siginfo_t *info, void *context) {
	int saved_errno = errno;
	char * pagestart;

	assert (signal == SIGSEGV);

    #ifdef linux
           info->si_addr = condor_getfaultaddr(context);
    #endif

	/* 	if the fault is not within a region we are protecting, then it is 
		a real fault and we should suicide.  Similarly, the NewDirtyPage call
		will return false if that page is already dirty, this indicates
		that we've already fixed the protections on that page and that this
		fault is a real one
	*/

	SegMap * data = MyImage.GetSeg("DATA");
	if (data == NULL) {
		dprintf( D_ALWAYS, "Couldn't find DATA segment\n" );
		Suicide();
	}

	if ( ! data->Contains( info->si_addr ) ) {
		dprintf( D_ALWAYS, "Death by seg fault.  External.\n" );
		Suicide();
	}

	// get the page boundary of the offending address, fix permissions and
	// set the corresponding bit
	pagestart = condor_getpagestart((char *)info->si_addr);
	condor_mprotect( pagestart, getpagesize(), PROT_READ | PROT_WRITE );
	if ( ! MyImage.NewDirtyPage( pagestart ) ) {
		dprintf( D_ALWAYS, "Death by seg fault.  Internal.\n" );
		Suicide();
	}
	errno = saved_errno;
} 

extern "C" {
void
_condor_save_stack_location()
{
	SavedStackLoc = stack_start_addr();
}

#if defined( X86 ) && defined( Solaris ) 
int
__CERROR() 
{
	return errno;
}
#endif


#if defined( X86 ) && defined( Solaris26 ) 
int
__CERROR64()
{
	return errno;
}
#endif

void mydprintf(int foo, const char *fmt, ...)
{
		va_list args;

		va_start(args, fmt);
		vfprintf(stdout, fmt, args);
		va_end(args);
		fflush(0);

		foo = foo;
}

} /* extern "C" */
