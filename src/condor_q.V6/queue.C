/***************************Copyright-DO-NOT-REMOVE-THIS-LINE**
 * CONDOR Copyright Notice
 *
 * See LICENSE.TXT for additional notices and disclaimers.
 *
 * Copyright (c)1990-2001 CONDOR Team, Computer Sciences Department, 
 * University of Wisconsin-Madison, Madison, WI.  All Rights Reserved.  
 * No use of the CONDOR Software Program Source Code is authorized 
 * without the express consent of the CONDOR Team.  For more information 
 * contact: CONDOR Team, Attention: Professor Miron Livny, 
 * 7367 Computer Sciences, 1210 W. Dayton St., Madison, WI 53706-1685, 
 * (608) 262-0856 or miron@cs.wisc.edu.
 *
 * U.S. Government Rights Restrictions: Use, duplication, or disclosure 
 * by the U.S. Government is subject to restrictions as set forth in 
 * subparagraph (c)(1)(ii) of The Rights in Technical Data and Computer 
 * Software clause at DFARS 252.227-7013 or subparagraphs (c)(1) and 
 * (2) of Commercial Computer Software-Restricted Rights at 48 CFR 
 * 52.227-19, as applicable, CONDOR Team, Attention: Professor Miron 
 * Livny, 7367 Computer Sciences, 1210 W. Dayton St., Madison, 
 * WI 53706-1685, (608) 262-0856 or miron@cs.wisc.edu.
****************************Copyright-DO-NOT-REMOVE-THIS-LINE**/

#define EXPERIMENTAL

#include "condor_common.h"
#include "condor_config.h"
//#include "condor_accountant.h"
#include "condor_classad.h"
#include "condor_debug.h"
#include "condor_api.h"
//#include "condor_query.h"
//#include "condor_q.h"
#include "condor_io.h"
#include "condor_string.h"
#include "condor_attributes.h"
#include "match_prefix.h"
#include "my_hostname.h"
#include "get_daemon_addr.h"
#include "get_full_hostname.h"
#include "MyString.h"
#include "extArray.h"
#include "files.h"
//#include "ad_printmask.h"
#include "internet.h"
#include "sig_install.h"
#include "format_time.h"
#include "daemon.h"
#include "my_hostname.h"
#include "basename.h"
#include "metric_units.h"
#include "condor_classad_analysis.h"
#include "globus_utils.h"
#include "print_wrapped_text.h"

extern 	"C" int SetSyscalls(int val){return val;}
extern  void short_print(int,int,const char*,int,int,int,int,int,const char *);
static  void processCommandLineArguments(int, char *[]);

static  bool process_buffer_line( ClassAd * );

static 	void short_header (void);
static 	void usage (char *);
static 	void io_display (ClassAd *);
static 	char * buffer_io_display (ClassAd *);
static 	void displayJobShort (ClassAd *);
static 	char * bufferJobShort (ClassAd *);
static 	void shorten (char *, int);
static	bool show_queue (char* scheddAddr, char* scheddName, char* scheddMachine);
static	bool show_queue_buffered (char* scheddAddr, char* scheddName,
								  char* scheddMachine);

static 	int verbose = 0, summarize = 1, global = 0, show_io = 0, dag = 0;
static  int use_xml = 0;
static  bool expert = false;
static 	int malformed, unexpanded, running, idle, held;

static const float PriorityDelta = 0.5;  // NAC - from condor_accountant.h

static	CondorQ 	Q;
static	QueryResult result;
static	CondorQuery	scheddQuery(SCHEDD_AD);
static	CondorQuery submittorQuery(SUBMITTOR_AD);
static	ClassAdList	scheddList;

static  ClassAdAnalyzer analyzer;	// NAC

static char* format_owner( char*, ClassAd* );

// clusterProcString is the container where the output strings are
//    stored.  We need the cluster and proc so that we can sort in an
//    orderly manner (and don't need to rely on the cluster.proc to be
//    available....)

class clusterProcString {
public:
	clusterProcString();
	int parent_cluster;
	int parent_proc;
	int cluster;
	int proc;
	char * string;
};

clusterProcString::
clusterProcString() {
	// these need to be initialized so that sorting works
	parent_cluster = 0;
	parent_proc = 0;
}

static  ExtArray<clusterProcString *> *output_buffer;
static	bool		output_buffer_empty = true;

static	bool		usingPrintMask = false;
static 	bool		customFormat = false;
static  bool		cputime = false;
static	bool		current_run = false;
static 	bool		globus = false;
static  char		*JOB_TIME = "RUN_TIME";
static	bool		querySchedds 	= false;
static	bool		querySubmittors = false;
static	char		constraint[4096];
static	char		*pool = NULL;
static	char		scheddAddr[64];	// used by format_remote_host()
//static	AttrListPrintMask 	mask;
static	ClassAdPrintMask 	mask;

// for run failure analysis
static  int			findSubmittor( char * );
static	void 		setupAnalysis();
static 	void		fetchSubmittorPrios();
static	void		doRunAnalysis( ClassAd* );
static	char *		doRunAnalysisToBuffer( ClassAd* );
struct 	PrioEntry { MyString name; float prio; };
static 	bool		analyze	= false;
static	bool		run = false;
static	bool		goodput = false;
static	char		*fixSubmittorName( char*, int );
static	ClassAdList startdAds;
static	ExprTree	*stdRankCondition;
static	ExprTree	*preemptRankCondition;
static	ExprTree	*preemptPrioCondition;
static	ExprTree	*preemptionReq;
static  ExtArray<PrioEntry> prioTable;
#ifndef WIN32
template class ExtArray<PrioEntry>;
#endif
	
char return_buff[4096];

extern 	"C"	int		Termlog;

int main (int argc, char **argv)
{
	ClassAd		*ad;
	bool		first = true;
	char		scheddName[64];
	char		scheddMachine[64];
	char		*tmp;

	// load up configuration file
	config();


#if !defined(WIN32)
	install_sig_handler(SIGPIPE, SIG_IGN );
#endif

	// process arguments
	processCommandLineArguments (argc, argv);

	// check if analysis is required
	if( analyze ) {
		setupAnalysis();
	}
	// if we haven't figured out what to do yet, just display the
	// local queue 
	if (!global && !querySchedds && !querySubmittors) {
		Daemon schedd( DT_SCHEDD, 0, 0 );
		if ( schedd.locate() ) {
			sprintf( scheddAddr, "%s", schedd.addr() );
			if( (tmp = schedd.name()) ) {
				sprintf( scheddName, "%s", tmp );
			} else {
				sprintf( scheddName, "Unknown" );
			}
			if( (tmp = schedd.fullHostname()) ) {
				sprintf( scheddMachine, "%s", tmp );
			} else {
				sprintf( scheddMachine, "Unknown" );
			}
			if ( verbose ) {
				exit( !show_queue( scheddAddr, scheddName,
							scheddMachine ) );
			} else {
				exit( !show_queue_buffered( scheddAddr, scheddName,
							scheddMachine ) );
			}
		} else {
			int text_position = 0;
			char error_message[1024];
			print_wrapped_text("Error: Couldn't contact the local "
							   "condor_schedd process.",
							   stderr);
			if (!expert) {
				char *log_directory = NULL;
				log_directory = param("LOG");
				fprintf(stderr, "\n");
				print_wrapped_text("Extra Info: the condor_schedd is the local process "
								   "that runs "
								   "on this machine and monitors your job "
								   "submissions. Either it "
								   "isn't running, or it is failing to "
								   "communicate. Check with your system administrator "
								   "to see why.", stderr);
				fprintf(stderr, "\n");
				sprintf(error_message, 
						"If you are the system administrator, check the "
						"MasterLog and SchedLog in %s "
						"for possible clues as to why the condor_schedd "
						"is misbehaving. Also see the Troubleshooting "
						"section of the manual.", 
						log_directory ? log_directory : "your Condor log directory");
				print_wrapped_text(error_message, stderr);
                if (log_directory) {
                    free(log_directory);
                }
			}
			exit( 1 );
		}
  	}

	// if a global queue is required, query the schedds instead of submittors
	if (global) {
		querySchedds = true;
		sprintf( constraint, "%s > 0 || %s > 0 || %s > 0 || %s > 0", 
			ATTR_TOTAL_RUNNING_JOBS, ATTR_TOTAL_IDLE_JOBS,
			ATTR_TOTAL_HELD_JOBS, ATTR_TOTAL_REMOVED_JOBS );
		result = scheddQuery.addANDConstraint( constraint );
		if( result != Q_OK ) {
			fprintf( stderr, "Error: Couldn't add constraint %s\n", constraint);
			exit( 1 );
		}		
	}

	// get the list of ads from the collector
	if( pool ) {
		result = querySchedds ? scheddQuery.fetchAds(scheddList, pool) : 
			submittorQuery.fetchAds(scheddList, pool);
	} else {
		result = querySchedds ? scheddQuery.fetchAds(scheddList) : 
			submittorQuery.fetchAds(scheddList);
	}

	if (result != Q_OK) {
		fprintf (stderr, "Error %d: %s\n", result, getStrQueryResult(result));
		exit(1);
	}
	
	// get queue from each ScheddIpAddr in ad
	scheddList.Open();
	while ((ad = scheddList.Next()))
	{
		// get the address of the schedd
		if( !ad->EvaluateAttrString( ATTR_SCHEDD_IP_ADDR, scheddAddr, 64 )
			|| !ad->EvaluateAttrString( ATTR_NAME, scheddName, 64 )
			|| !ad->EvaluateAttrString( ATTR_MACHINE, scheddMachine, 64 ) ) {
				continue;
		}
		
  		if ( verbose ) {
  			show_queue( scheddAddr, scheddName, scheddMachine );
  		} else {
 			show_queue_buffered( scheddAddr, scheddName, scheddMachine );
		}
		first = false;
	}

	// close list
	scheddList.Close();

	if( first ) {
		if( global ) {
			printf( "All queues are empty\n" );
		} else {
			fprintf(stderr,"Error: Collector has no record of "
							"schedd/submitter\n");
			exit(1);
		}
	}

	return 0;
}

static void 
processCommandLineArguments (int argc, char *argv[])
{
	int i, cluster, proc;
	char *arg, *at, *daemonname;
	
	for (i = 1; i < argc; i++)
	{
		if( *argv[i] != '-' ) {
			// no dash means this arg is a cluster/proc, proc, or owner
			if( sscanf( argv[i], "%d.%d", &cluster, &proc ) == 2 ) {
				sprintf( constraint, "((%s == %d) && (%s == %d))", 
						 ATTR_CLUSTER_ID, cluster, ATTR_PROC_ID, proc );
				Q.addOR( constraint );
				summarize = 0;
			} 
			else if( sscanf ( argv[i], "%d", &cluster ) == 1 ) {
				sprintf( constraint, "(%s == %d)", ATTR_CLUSTER_ID, cluster );
				Q.addOR( constraint );
				summarize = 0;
			} 
			else if( Q.add( CQ_OWNER, argv[i] ) != Q_OK ) {
				// this error doesn't seem very helpful... can't we say more?
				fprintf( stderr, "Error: Argument %d (%s)\n", i, argv[i] );
				exit( 1 );
			}
			continue;
		}

		// the argument began with a '-', so use only the part after
		// the '-' for prefix matches
		arg = argv[i]+1;

		if (match_prefix (arg, "long")) {
			verbose = 1;
			summarize = 0;
		} 
		else
		if (match_prefix (arg, "xml")) {
			use_xml = 1;
			verbose = 1;
			summarize = 0;
		}
		else
		if (match_prefix (arg, "pool")) {
			if( pool ) {
				delete [] pool;
			}
            if( ++i >= argc ) {
				fprintf( stderr,
						 "Error: Argument -pool requires a hostname as an argument.\n" );
				if (!expert) {
					printf("\n");
					print_wrapped_text("Extra Info: The hostname should be the central "
									   "manager of the Condor pool you wish to work with.",
									   stderr);
				}
				exit(1);
			}
			pool = get_full_hostname((const char *)argv[i]);
			if( ! pool ) {
				fprintf( stderr, "Error: Unknown host %s\n", argv[i] );
				if (!expert) {
					printf("\n");
					print_wrapped_text("Extra Info: You specified a hostname for a pool "
									   "(the -pool argument). That should be the Internet "
									   "host name for the central manager of the pool, "
									   "but it does not seem to "
									   "be a valid hostname. (The DNS lookup failed.)",
									   stderr);
				}
				exit(1);
			}
		} 
		else
		if (match_prefix (arg, "D")) {
			if( ++i >= argc ) {
				fprintf( stderr, 
						 "Error: Argument -D requires a list of flags as an argument.\n" );
				if (!expert) {
					printf("\n");
					print_wrapped_text("Extra Info: You need to specify debug flags "
									   "as a quoted string. Common flags are D_ALL, and "
									   "D_ALWAYS.",
									   stderr);
				}
				exit( 1 );
			}
			Termlog = 1;
			set_debug_flags( argv[i] );
		} 
		else
		if (match_prefix (arg, "name")) {

			if (querySubmittors) {
				// cannot query both schedd's and submittors
				fprintf (stderr, "Cannot query both schedd's and submitters\n");
				if (!expert) {
					printf("\n");
					print_wrapped_text("Extra Info: You cannot specify both -name and "
									   "-submitter. -name implies you want to only query "
									   "the local schedd, while -submitter implies you want "
									   "to find everything in the entire pool for a given"
									   "submitter.",
									   stderr);
				}
				exit(1);
			}

			// make sure we have at least one more argument
			if (argc <= i+1) {
				fprintf( stderr, 
						 "Error: Argument -name requires the name of a schedd as a parameter.\n" );
				exit(1);
			}

			if( !(daemonname = get_daemon_name(argv[i+1])) ) {
				fprintf( stderr, "Error: unknown host %s\n",
						 get_host_part(argv[i+1]) );
				if (!expert) {
					printf("\n");
					print_wrapped_text("Extra Info: The name given with the -name "
									   "should be the name of a condor_schedd process. "
									   "Normally it is either a hostname, or "
									   "\"name@hostname\". "
									   "In either case, the hostname should be the Internet "
									   "host name, but it appears that it wasn't.",
									   stderr);
				}
				exit(1);
			}
			sprintf (constraint, "%s == \"%s\"", ATTR_NAME, daemonname);
			delete [] daemonname;

			result = scheddQuery.addORConstraint (constraint);
			if (result != Q_OK) {
				fprintf (stderr, "Argument %d (%s): Error %s\n", i, argv[i],
							getStrQueryResult(result));
				exit (1);
			}
			i++;
			querySchedds = true;
		} 
		else
		if (match_prefix (arg, "submitter")) {

			if (querySchedds) {
				// cannot query both schedd's and submittors
				fprintf (stderr, "Cannot query both schedd's and submitters\n");
				if (!expert) {
					printf("\n");
					print_wrapped_text("Extra Info: You cannot specify both -name and "
									   "-submitter. -name implies you want to only query "
									   "the local schedd, while -submitter implies you want "
									   "to find everything in the entire pool for a given"
									   "submitter.",
									   stderr);
				}
				exit(1);
			}
			
			// make sure we have at least one more argument
			if (argc <= i+1) {
				fprintf( stderr, "Error: Argument -submitter requires the name of a "
						 "user.\n");
				exit(1);
			}
				
			i++;
			if ((at = strchr(argv[i],'@'))) {
				// is the name already qualified with a UID_DOMAIN?
				sprintf (constraint, "%s == \"%s\"", ATTR_NAME, argv[i]);
				*at = '\0';
			} else {
				// no ... add UID_DOMAIN
				char *uid_domain = param( "UID_DOMAIN" );
				if (uid_domain == NULL)
				{
					EXCEPT ("No 'UID_DOMAIN' found in config file");
				}
				sprintf (constraint, "%s == \"%s@%s\"", ATTR_NAME, argv[i], 
							uid_domain);
				free (uid_domain);
			}

			// insert the constraints
			result = submittorQuery.addORConstraint (constraint);
			if (result != Q_OK) {
				fprintf (stderr, "Argument %d (%s): Error %s\n", i, argv[i],
							getStrQueryResult(result));
				exit (1);
			}

			{
				char *ownerName = argv[i];
				// ensure that the "nice-user" prefix isn't inserted as part
				// of the job ad constraint
				if( strstr( argv[i] , NiceUserName ) == argv[i] ) {
					ownerName = argv[i]+strlen(NiceUserName)+1;
				}
				if (Q.add (CQ_OWNER, ownerName) != Q_OK) {
					fprintf (stderr, "Error:  Argument %d (%s)\n", i, argv[i]);
					exit (1);
				}
			}

			querySubmittors = true;
		}
		else
		if (match_prefix (arg, "constraint")) {
			// make sure we have at least one more argument
			if (argc <= i+1) {
				fprintf( stderr, "Error: Argument -constraint requires "
							"another parameter\n");
				exit(1);
			}

			if (Q.addAND (argv[++i]) != Q_OK) {
				fprintf (stderr, "Error: Argument %d (%s)\n", i, argv[i]);
				exit (1);
			}
			summarize = 0;
		} 
		else
		if (match_prefix (arg, "address")) {

			if (querySubmittors) {
				// cannot query both schedd's and submittors
				fprintf (stderr, "Cannot query both schedd's and submitters\n");
				exit(1);
			}

			// make sure we have at least one more argument
			if (argc <= i+1) {
				fprintf( stderr,
						 "Error: Argument -address requires another "
						 "parameter\n" );
				exit(1);
			}
			if( ! is_valid_sinful(argv[i+1]) ) {
				fprintf( stderr, 
					 "Address must be of the form: \"<ip.address:port>\"\n" );
				exit(1);
			}
			sprintf(constraint, "%s == \"%s\"", ATTR_SCHEDD_IP_ADDR, argv[i+1]);
			result = scheddQuery.addORConstraint(constraint);
			if (result != Q_OK) {
				fprintf (stderr, "Argument %d (%s): Error %s\n", i, argv[i],
							getStrQueryResult(result));
				exit (1);
			}
			i++;
			querySchedds = true;
		} 
		else
		if( match_prefix( arg, "format" ) ) {
				// make sure we have at least two more arguments
			if( argc <= i+2 ) {
				fprintf( stderr, "Error: Argument -format requires "
						 "format and attribute parameters\n" );
				exit( 1 );
			}
			customFormat = true;
			mask.registerFormat( argv[i+1], argv[i+2] );
			usingPrintMask = true;
			i+=2;
		}
		else
		if (match_prefix (arg, "global")) {
			global = 1;
		} 
		else
		if (match_prefix (arg, "help")) {
			usage(argv[0]);
			exit(0);
		}
		else
		if (match_prefix( arg , "analyze")) {
			analyze = true;
		}
		else
		if (match_prefix( arg, "run")) {
			Q.add (CQ_STATUS, RUNNING);
			run = true;
		}
		else
		if (match_prefix( arg, "goodput")) {
			// goodput and show_io require the same column
			// real-estate, so they're mutually exclusive
			goodput = true;
			show_io = false;
		}
		else
		if (match_prefix( arg, "cputime")) {
			cputime = true;
			JOB_TIME = "CPU_TIME";
		}
		else
		if (match_prefix( arg, "currentrun")) {
			current_run = true;
		}
		else
		if( match_prefix( arg, "globus" ) ) {
			Q.addAND( "GlobusStatus =!= UNDEFINED" );
			globus = true;
		}
		else
		if( match_prefix( arg, "debug" ) ) {
			// dprintf to console
			Termlog = 1;
			dprintf_config ("TOOL", 2 );
		}
		else
		if (match_prefix(arg,"io")) {
			// goodput and show_io require the same column
			// real-estate, so they're mutually exclusive
			show_io = true;
			goodput = false;
		}   
		else if( match_prefix( arg, "dag" ) ) {
			dag = true;
		}   
		else if (match_prefix(arg, "expert")) {
			expert = true;
		}
		else {
			fprintf( stderr, "Error: unrecognized argument -%s\n", arg );
			usage(argv[0]);
			exit( 1 );
		}
	}
}

static float
job_time(float cpu_time,ClassAd *ad)
{
	if ( cputime ) {
		return cpu_time;
	}

		// here user wants total wall clock time, not cpu time
	int job_status = !RUNNING;
	int cur_time = 0;
	int shadow_bday = 0;
	float previous_runs = 0;
	double previous_runsD;		// NAC

	ad->EvaluateAttrInt( ATTR_JOB_STATUS, job_status);			// NAC
	ad->EvaluateAttrInt( ATTR_SERVER_TIME, cur_time);			// NAC
	ad->EvaluateAttrInt( ATTR_SHADOW_BIRTHDATE, shadow_bday );	// NAC
	if ( current_run == false ) {
		ad->EvaluateAttrReal( ATTR_JOB_REMOTE_WALL_CLOCK, previous_runsD );
		previous_runs = (float)previous_runsD;
	}

		// if we have an old schedd, there is no ATTR_SERVER_TIME,
		// so return a "-1".  This will cause "?????" to show up
		// in condor_q.
	if ( cur_time == 0 ) {
		return -1;
	}

	/* Compute total wall time as follows:  previous_runs is not the 
	 * number of seconds accumulated on earlier runs.  cur_time is the
	 * time from the point of view of the schedd, and shadow_bday is the
	 * epoch time from the schedd's view when the shadow was started for
	 * this job.  So, we figure out the time accumulated on this run by
	 * computing the time elapsed between cur_time & shadow_bday.  
	 * NOTE: shadow_bday is set to zero when the job is RUNNING but the
	 * shadow has not yet started due to JOB_START_DELAY parameter.  And
	 * shadow_bday is undefined (stale value) if the job status is not
	 * RUNNING.  So we only compute the time on this run if shadow_bday
	 * is not zero and the job status is RUNNING.  -Todd <tannenba@cs.wisc.edu>
	 */
	float total_wall_time = previous_runs + 
		(cur_time - shadow_bday)*(job_status == RUNNING && shadow_bday);

	return total_wall_time;
}

static void
io_display(ClassAd *ad)
{
	printf("%s", buffer_io_display( ad ) );
}

static char *
buffer_io_display( ClassAd *ad )
{
	int cluster=0, proc=0;
	float read_bytes=0, write_bytes=0, seek_count=0;
	int buffer_size=0, block_size=0;
	float wall_clock=-1;

	double read_bytesD, write_bytesD, seek_countD, wall_clockD;

	char owner[256];

	ad->EvaluateAttrInt( ATTR_CLUSTER_ID, cluster );	// NAC
	ad->EvaluateAttrInt( ATTR_PROC_ID, proc );			// NAC
	ad->EvaluateAttrString( ATTR_OWNER, owner, 256 );	// NAC

	ad->EvaluateAttrReal( ATTR_FILE_READ_BYTES, read_bytesD );			// NAC
	ad->EvaluateAttrReal( ATTR_FILE_WRITE_BYTES, write_bytesD );		// NAC
	ad->EvaluateAttrReal( ATTR_FILE_SEEK_COUNT, seek_countD );			// NAC
	ad->EvaluateAttrReal( ATTR_JOB_REMOTE_WALL_CLOCK, wall_clockD );	// NAC
	ad->EvaluateAttrInt( ATTR_BUFFER_SIZE, buffer_size );				// NAC
	ad->EvaluateAttrInt( ATTR_BUFFER_BLOCK_SIZE, block_size );			// NAC

	sprintf( return_buff, "%4d.%-3d %-14s", cluster, proc,
			 format_owner( owner, ad ) );

	/* If the jobAd values are not set, OR the values are all zero,
	   report no data collected.  This could be true for a vanilla
	   job, or for a standard job that has not checkpointed yet. */

	if(wall_clock<0 || (!read_bytes && !write_bytes && !seek_count) ) {
		strcat(return_buff, "   [ no i/o data collected ]\n");
	} else {
		if(wall_clock==0) wall_clock=1;

		/*
		Note: metric_units() cannot be used twice in the same
		statement -- it returns a pointer to a static buffer.
		*/

		sprintf( return_buff,"%s %8s", return_buff, metric_units(read_bytes) );
		sprintf( return_buff,"%s %8s", return_buff, metric_units(write_bytes) );
		sprintf( return_buff,"%s %8.0f", return_buff, seek_count );
		sprintf( return_buff,"%s %8s/s", return_buff, metric_units((int)((read_bytes+write_bytes)/wall_clock)) );
		sprintf( return_buff,"%s %8s", return_buff, metric_units(buffer_size) );
		sprintf( return_buff,"%s %8s\n", return_buff, metric_units(block_size) );
	}
	return ( return_buff );
}

static void
displayJobShort (ClassAd *ad)
{ 
	printf( "%s", bufferJobShort( ad ) );
}

static char *
bufferJobShort( ClassAd *ad ) {
	int cluster, proc, date, status, prio, image_size;
	float utime;
	double utimeD;
	char owner[64], cmd[ATTRLIST_MAX_EXPRESSION], args[ATTRLIST_MAX_EXPRESSION];
	char buffer[ATTRLIST_MAX_EXPRESSION];
	if (!ad->EvaluateAttrInt( ATTR_CLUSTER_ID,  cluster )			||	// NAC
		!ad->EvaluateAttrInt( ATTR_PROC_ID,  proc )					||	// NAC
		!ad->EvaluateAttrInt( ATTR_Q_DATE,  date )					||	// NAC
		!ad->EvaluateAttrReal( ATTR_JOB_REMOTE_USER_CPU,  utimeD )	||	// NAC
		!ad->EvaluateAttrInt( ATTR_JOB_STATUS,  status )			||	// NAC
		!ad->EvaluateAttrInt( ATTR_JOB_PRIO,  prio )				||	// NAC
		!ad->EvaluateAttrInt( ATTR_IMAGE_SIZE,  image_size )		||	// NAC
		!ad->EvaluateAttrString( ATTR_OWNER, owner, 64 )   			||	// NAC
		!ad->EvaluateAttrString( ATTR_JOB_CMD, cmd, 10240 ) )	   		// NAC
	{	
		sprintf (return_buff, " --- ???? --- \n");
		return( return_buff );
	}
	utime = (float)utimeD;

	int niceUser;
    if( ad->EvaluateAttrInt( ATTR_NICE_USER, niceUser ) && niceUser ) {	// NAC
        char tmp[100];
        strncpy(tmp,NiceUserName,99);
        strcat(tmp,".");
        strcat(tmp,owner);
        strncpy(owner,tmp, 63);
    }

	shorten (owner, 14);
	if (ad->EvaluateAttrString ("Args", args, 10240 ) ) {
		sprintf( buffer, "%s %s", basename(cmd), args );
	} else {
		sprintf( buffer, "%s", basename(cmd) );
	}
	utime = job_time(utime,ad);

	sprintf( return_buff,
			 "%4d.%-3d %-14s %-11s %-12s %-2c %-3d %-4.1f %-18.18s\n",
			 cluster,
			 proc,
			 format_owner( owner, ad ),
			 format_date( (time_t)date ),
			 /* In the next line of code there is an (int) typecast. This
			 	has to be there otherwise the compiler produces incorrect code
				here and performs a structural typecast from the float to an
				int(like how a union works) and passes a garbage number to the
				format_time function. The compiler is *supposed* to do a
				functional typecast, meaning generate code that changes the
				float to an int legally. Apparently, that isn't happening here.
				-psilord 09/06/01 */
			 format_time( (int)utime ),
			 encode_status( status ),
			 prio,
			 (image_size / 1024.0),
			 buffer );

	return return_buff;
}

static void 
short_header (void)
{
	printf( " %-7s %-14s ", "ID", dag ? "OWNER/NODENAME" : "OWNER" );
	if( goodput ) {
		printf( "%11s %12s %-16s\n", "SUBMITTED", JOB_TIME,
				"GOODPUT CPU_UTIL   Mb/s" );
	} else if ( globus ) {
		printf( "%-7s %-8s %-18s  %-18s\n", "STATUS",
				"MANAGER", "HOST", "EXECUTABLE" );
	} else if ( show_io ) {
		printf( "%8s %8s %8s %10s %8s %8s\n",
				"READ", "WRITE", "SEEK", "XPUT", "BUFSIZE", "BLKSIZE" );
	} else if( run ) {
		printf( "%11s %12s %-16s\n", "SUBMITTED", JOB_TIME, "HOST(S)" );
	} else {
		printf( "%11s %12s %-2s %-3s %-4s %-18s\n",
			"SUBMITTED",
			JOB_TIME,
			"ST",
			"PRI",
			"SIZE",
			"CMD"
		);
	}
}

static char *
//format_remote_host (char *, AttrList *ad)
format_remote_host (char *, ClassAd *ad)	// NAC
{
	static char result[MAXHOSTNAMELEN];
	static char unknownHost [] = "[????????????????]";
	char* tmp;
	struct sockaddr_in sin;

	int universe = CONDOR_UNIVERSE_STANDARD;
	ad->EvaluateAttrInt( ATTR_JOB_UNIVERSE, universe );
	if (universe == CONDOR_UNIVERSE_SCHEDULER &&
		string_to_sin(scheddAddr, &sin) == 1) {
		if( (tmp = sin_to_hostname(&sin, NULL)) ) {
			strcpy( result, tmp );
			return result;
		} else {
			return unknownHost;
		}
	} else if (universe == CONDOR_UNIVERSE_PVM) {
		int current_hosts;
		if (ad->EvaluateAttrInt( ATTR_CURRENT_HOSTS, current_hosts )) {
			if (current_hosts == 1) {
				sprintf(result, "1 host");
			} else {
				sprintf(result, "%d hosts", current_hosts);
			}
			return result;
		}
	} else if (universe == CONDOR_UNIVERSE_GLOBUS) {
        string tmp;
		if (ad->EvaluateAttrString( ATTR_GLOBUS_RESOURCE, tmp)) {
            strncpy(result, tmp.data(), MAXHOSTNAMELEN);
			return result;
        }
		else
			return unknownHost;
	}

	if ( ad->EvaluateAttrString( ATTR_REMOTE_HOST, result, MAXHOSTNAMELEN ) ) {
		if( is_valid_sinful(result) && 
			(string_to_sin(result, &sin) == 1) ) {  
			if( (tmp = sin_to_hostname(&sin, NULL)) ) {
				strcpy( result, tmp );
			} else {
				return unknownHost;
			}
		}
		return result;
	} else {
		int universe = CONDOR_UNIVERSE_STANDARD;
		ad->EvaluateAttrInt( ATTR_JOB_UNIVERSE, universe );	// NAC
		if (universe == CONDOR_UNIVERSE_SCHEDULER &&
			string_to_sin(scheddAddr, &sin) == 1) {
			if( (tmp = sin_to_hostname(&sin, NULL)) ) {
				strcpy( result, tmp );
				return result;
			} else {
				return unknownHost;
			}
		} else if (universe == CONDOR_UNIVERSE_PVM) {
			int current_hosts;
			if ( ad->EvaluateAttrInt( ATTR_CURRENT_HOSTS, current_hosts ) ) {
				if (current_hosts == 1) {
					sprintf(result, "1 host");
				} else {
					sprintf(result, "%d hosts", current_hosts);
				}
				return result;
			}
		}
	}
	return unknownHost;
}

static char *
format_cpu_time ( float utime, ClassAd *ad )	// NAC
{
	return format_time( (int) job_time(utime, ad) );
}

static char *
format_goodput ( int job_status, ClassAd *ad )	// NAC
{
	static char result[9];
	int ckpt_time = 0, shadow_bday = 0, last_ckpt = 0;
	float wall_clock = 0.0;
	double wall_clockD;
	ad->EvaluateAttrInt( ATTR_JOB_COMMITTED_TIME, ckpt_time );			// NAC
	ad->EvaluateAttrInt( ATTR_SHADOW_BIRTHDATE, shadow_bday );			// NAC
	ad->EvaluateAttrInt( ATTR_LAST_CKPT_TIME, last_ckpt );				// NAC
	ad->EvaluateAttrReal( ATTR_JOB_REMOTE_WALL_CLOCK, wall_clockD );	// NAC
	wall_clock = (float)wall_clockD;									// NAC
	
	if (job_status == RUNNING && shadow_bday && last_ckpt > shadow_bday) {
		wall_clock += last_ckpt - shadow_bday;
	}
	if (wall_clock <= 0.0) return " [?????]";
	float goodput = ckpt_time/wall_clock*100.0;
	if (goodput > 100.0) goodput = 100.0;
	else if (goodput < 0.0) return " [?????]";
	sprintf(result, " %6.1f%%", goodput);
	return result;
}

static char *
//format_mbps (float bytes_sent, AttrList *ad)
format_mbps (float bytes_sent, ClassAd *ad)
{
	static char result[10];
	float wall_clock=0.0, bytes_recvd=0.0, total_mbits;
	int shadow_bday = 0, last_ckpt = 0, job_status = IDLE;
	double wall_clockD, bytes_recvdD;	// NAC
	ad->EvaluateAttrReal( ATTR_JOB_REMOTE_WALL_CLOCK, wall_clockD );	// NAC
	ad->EvaluateAttrInt( ATTR_SHADOW_BIRTHDATE, shadow_bday );			// NAC
	ad->EvaluateAttrInt( ATTR_LAST_CKPT_TIME, last_ckpt );				// NAC
	ad->EvaluateAttrInt( ATTR_JOB_STATUS, job_status );					// NAC
	wall_clock = (float)wall_clockD;									// NAC

	if (job_status == RUNNING && shadow_bday && last_ckpt > shadow_bday) {
		wall_clock += last_ckpt - shadow_bday;
	}
	ad->EvaluateAttrReal( ATTR_BYTES_RECVD, bytes_recvdD );				// NAC
	bytes_recvd = (float)bytes_recvdD;									// NAC
	total_mbits = (bytes_sent+bytes_recvd)*8/(1024*1024); // bytes to mbits
	if (total_mbits <= 0) return " [????]";
	sprintf(result, " %6.2f", total_mbits/wall_clock);
	return result;
}

static char *
format_cpu_util (float utime, ClassAd *ad)
{
	static char result[10];
	int ckpt_time = 0;
	ad->EvaluateAttrInt( ATTR_JOB_COMMITTED_TIME, ckpt_time);	// NAC
	if (ckpt_time == 0) return " [??????]";
	float util = (ckpt_time) ? utime/ckpt_time*100.0 : 0.0;
	if (util > 100.0) util = 100.0;
	else if (util < 0.0) return " [??????]";
	sprintf(result, "  %6.1f%%", util);
	return result;
}

static char *
format_owner (char *owner, ClassAd *ad)
{
	static char result[15] = "";

	// [this is a somewhat kludgey place to implement DAG formatting,
	// but for a variety of reasons (maintainability, allowing future
	// changes to be made in only one place, etc.), Todd & I decided
	// it's the best way to do it given the existing code...  --pfc]

	// if -dag is specified, check whether this job was started by a
	// DAGMan (by seeing if it has a valid DAGManJobId attribute), and
	// if so, print DAGNodeName in place of owner

	// (we need to check that the DAGManJobId is valid because DAGMan
	// >= v6.3 inserts "unknown..." into DAGManJobId when run under a
	// pre-v6.3 schedd)

	//char dagman_job_id[ATTRLIST_MAX_EXPRESSION];
	//char dag_node_name[ATTRLIST_MAX_EXPRESSION];
    string dagman_job_id, dag_node_name;

	if( dag && ad->EvaluateAttrString( ATTR_DAGMAN_JOB_ID, dagman_job_id ) &&
		(dagman_job_id.find("unknown" ) != 0) &&
		ad->EvaluateAttrString( ATTR_DAG_NODE_NAME, dag_node_name ) ) {
		sprintf( result, " |-%-11.11s", dag_node_name.data() );
		return result;
	}

	int niceUser;
	if ( ad->EvaluateAttrInt( ATTR_NICE_USER, niceUser ) && niceUser ) {// NAC
		char tmp[100];
		strncpy(tmp,NiceUserName,99);
		strcat(tmp, ".");
		strcat(tmp, owner);
		sprintf(result, "%-14.14s", tmp);
	} else {
		sprintf(result, "%-14.14s", owner);
	}
	return result;
}

static char *
format_globusStatus( int globusStatus, AttrList *ad )
{
	static char result[64];

	strcpy( result, GlobusJobStatusName( globusStatus ) );

	return result;
}

static char *
format_globusHostAndJM( char  *globusResource, AttrList *ad )
{
	static char result[64];
	char	host[80] = "[?????]";
	char	jm[80] = "fork";
	char	*tmp;
	int	p;

	if ( globusResource != NULL ) {
		// copy the hostname
		p = strcspn( globusResource, ":/" );
		if ( p > sizeof(host) )
			p = sizeof(host) - 1;
		strncpy( host, globusResource, p );
		host[p] = '\0';

		if ( ( tmp = strstr( globusResource, "jobmanager-" ) ) != NULL ) {
			tmp += 11; // 11==strlen("jobmanager-")

			// copy the jobmanager name
			p = strcspn( tmp, ":" );
			if ( p > sizeof(jm) )
				p = sizeof(jm) - 1;
			strncpy( jm, tmp, p );
			jm[p] = '\0';
		}
	}

	// done --- pack components into the result string and return
	sprintf( result, " %-8.8s %-18.18s  ", jm, host );
	return( result );
}



static char *
format_q_date (int d, ClassAd *)
{
	return format_date(d);
}

static void
shorten (char *buff, int len)
{
	if ((unsigned int)strlen (buff) > (unsigned int)len) buff[len] = '\0';
}
		
static void
usage (char *myName)
{
	printf ("Usage: %s [options]\n\twhere [options] are\n"
		"\t\t-global\t\t\tGet global queue\n"
		"\t\t-submitter <submitter>\tGet queue of specific submitter\n"
		"\t\t-help\t\t\tThis screen\n"
		"\t\t-name <name>\t\tName of schedd\n"
		"\t\t-pool <host>\t\tUse host as the central manager to query\n"
		"\t\t-long\t\t\tVerbose output\n"
		"\t\t-format <fmt> <attr>\tPrint attribute attr using format fmt\n"
		"\t\t-analyze\t\tPerform schedulability analysis on jobs\n"
		"\t\t-run\t\t\tGet information about running jobs\n"
		"\t\t-goodput\t\tDisplay job goodput statistics\n"	
		"\t\t-cputime\t\tDisplay CPU_TIME instead of RUN_TIME\n"
		"\t\t-currentrun\t\tDisplay times only for current run\n"
		"\t\t-io\t\t\tShow information regarding I/O\n"
		"\t\t-dag\t\t\tSort DAG jobs under their DAGMan\n"
		"\t\t-expert\t\t\tDisplay shorter error messages\n"
		"\t\trestriction list\n"
		"\twhere each restriction may be one of\n"
		"\t\t<cluster>\t\tGet information about specific cluster\n"
		"\t\t<cluster>.<proc>\tGet information about specific job\n"
		"\t\t<owner>\t\t\tInformation about jobs owned by <owner>\n"
		"\t\t-constraint <expr>\tAdd constraint on classads\n",
			myName);
}

int
output_sorter( const void * va, const void * vb ) {

	clusterProcString **a, **b;

	a = ( clusterProcString ** ) va;
	b = ( clusterProcString ** ) vb;

	// when -dag is specified, we want to display DAG jobs under the
	// DAGMan that started them, so we sort first by parent_cluster,
	// which is zero for non-DAG jobs (and the DAGMan jobs themselves)

	if ((*a)->parent_cluster < (*b)->parent_cluster ) { return -1; }
	if ((*a)->parent_cluster > (*b)->parent_cluster ) { return  1; }
	if ((*a)->parent_proc    < (*b)->parent_proc    ) { return -1; }
	if ((*a)->parent_proc    > (*b)->parent_proc    ) { return  1; }

	if ((*a)->cluster < (*b)->cluster ) { return -1; }
	if ((*a)->cluster > (*b)->cluster ) { return  1; }
	if ((*a)->proc    < (*b)->proc    ) { return -1; }
	if ((*a)->proc    > (*b)->proc    ) { return  1; }

	return 0;
}

static bool
show_queue_buffered( char* scheddAddr, char* scheddName, char* scheddMachine )
{
	static bool	setup_mask = false;
	clusterProcString **the_output;
	output_buffer = new ExtArray<clusterProcString*>;

	output_buffer->setFiller( (clusterProcString *) NULL );

		// initialize counters
	unexpanded = idle = running = held = malformed = 0;
	output_buffer_empty = true;

	if ( run || goodput ) {
		summarize = false;
		if (!setup_mask) {
			mask.registerFormat ("%4d.", ATTR_CLUSTER_ID);
			mask.registerFormat ("%-3d ", ATTR_PROC_ID);
			mask.registerFormat ( (StringCustomFmt) format_owner,
								  ATTR_OWNER, "[????????????] " );
			mask.registerFormat(" ", "*bogus*", " ");  // force space
			mask.registerFormat ( (IntCustomFmt) format_q_date,
								  ATTR_Q_DATE, "[????????????]");
			mask.registerFormat(" ", "*bogus*", " ");  // force space
			mask.registerFormat ( (FloatCustomFmt) format_cpu_time,
								  ATTR_JOB_REMOTE_USER_CPU,
								  "[??????????]");
			if( run && !goodput ) {
				mask.registerFormat(" ", "*bogus*", " "); // force space
				// We send in ATTR_OWNER since we know it is always
				// defined, and we need to make sure
				// format_remote_host() is always called. We are
				// actually displaying ATTR_REMOTE_HOST if defined,
				// but we play some tricks if it isn't defined.
				mask.registerFormat ( (StringCustomFmt) format_remote_host,
									  ATTR_OWNER, "[????????????????]");
			} else {			// goodput
				mask.registerFormat ( (IntCustomFmt) format_goodput,
									  ATTR_JOB_STATUS,
									  " [?????]");
				mask.registerFormat ( (FloatCustomFmt) format_cpu_util,
									  ATTR_JOB_REMOTE_USER_CPU,
									  " [??????]");
				mask.registerFormat ( (FloatCustomFmt) format_mbps,
									  ATTR_BYTES_SENT,
									  " [????]");
			}
			mask.registerFormat("\n", "*bogus*", "\n");  // force newline
			setup_mask = true;
			usingPrintMask = true;
		}
	} else if( globus ) {
		summarize = false;
		if (!setup_mask) {
			mask.registerFormat ("%4d.", ATTR_CLUSTER_ID);
			mask.registerFormat ("%-3d ", ATTR_PROC_ID);
			mask.registerFormat ( (StringCustomFmt) format_owner,
								  ATTR_OWNER, "[????????????] " );
			mask.registerFormat( (IntCustomFmt) format_globusStatus,
								 ATTR_GLOBUS_STATUS, "[?????]" );
			mask.registerFormat( (StringCustomFmt)
								 format_globusHostAndJM,
								 ATTR_GLOBUS_RESOURCE, "fork    [?????]" );
			mask.registerFormat( "%-18.18s\n", ATTR_JOB_CMD );
			setup_mask = true;
			usingPrintMask = true;
		}
	} else if ( customFormat ) {
		summarize = false;
	}

	// fetch queue from schedd and stash it in output_buffer.
	if( Q.fetchQueueFromHostAndProcess( scheddAddr,
									 process_buffer_line ) != Q_OK ) {
		printf ("\n-- Failed to fetch ads from: %s : %s\n", 
									scheddAddr, scheddMachine);	
		delete output_buffer;

		return false;
	}

	// before sorting, for non-DAGMan-spawned jobs (i.e., those whose
	// parent_cluster is zero), set parent_cluster equal to cluster so
	// that they sort properly against parent DAGMan jobs
	for( int i = 0; i <= output_buffer->getlast(); i++ ) {
		clusterProcString* cps = (*output_buffer)[i];
		if( cps && cps->parent_cluster == 0 ) {
			cps->parent_cluster = cps->cluster;
			cps->parent_proc = cps->proc;
		}
	}

	// If this is a global, don't print anything if this schedd is empty.
	// If this is NOT global, print out the header and footer to show that we
	//    did something.
	if (!global || !output_buffer_empty) {
		the_output = &(*output_buffer)[0];
		qsort(the_output, output_buffer->getlast()+1, sizeof(clusterProcString*),
			output_sorter);

		if (! customFormat ) {
			if( querySchedds ) {
				printf ("\n\n-- Schedd: %s : %s\n", scheddName, scheddAddr);
			} else {
				printf ("\n\n-- Submitter: %s : %s : %s\n", scheddName, 
						scheddAddr, scheddMachine);	
			}
			// Print the output header
		
			short_header();
		}

		if (!output_buffer_empty) {
			for (int i=0;i<=output_buffer->getlast(); i++) {
				if ((*output_buffer)[i])
					printf("%s",((*output_buffer)[i])->string);
			}
		}

		// If we want to summarize, do that too.
		if( summarize ) {
			printf( "\n%d jobs; "
					"%d idle, %d running, %d held",
					unexpanded+idle+running+held+malformed,
					idle,running,held);
			if (unexpanded>0) printf( ", %d unexpanded",unexpanded);
			if (malformed>0) printf( ", %d malformed",malformed);
           	printf("\n");
		}
	}
	delete output_buffer;
	return true;
}


// process_buffer_line returns 1 so that the ad that is passed
// to it should be deleted.


static bool
process_buffer_line( ClassAd *job )
{
	int status = 0;

	clusterProcString * tempCPS = new clusterProcString;
	(*output_buffer)[output_buffer->getlast()+1] = tempCPS;
	job->EvaluateAttrInt( ATTR_CLUSTER_ID, tempCPS->cluster );
	job->EvaluateAttrInt( ATTR_PROC_ID, tempCPS->proc );
	job->EvaluateAttrInt( ATTR_JOB_STATUS, status );

	switch (status)
	{
		case UNEXPANDED: unexpanded++; break;
		case IDLE:       idle++;       break;
		case RUNNING:    running++;    break;
		case HELD:		 held++;	   break;
	}

	if( analyze ) {
  		tempCPS->string = strnewp( doRunAnalysisToBuffer( job ) );
	} else if ( show_io ) {
		tempCPS->string = strnewp( buffer_io_display( job ) );
	} else if ( usingPrintMask ) {
		char * tempSTR = mask.display ( job );
		// strnewp the mask.display return, since its an 8k string.
		tempCPS->string = strnewp( tempSTR );
		delete [] tempSTR;
	} else {
		tempCPS->string = strnewp( bufferJobShort( job ) );
	}

	output_buffer_empty = false;

	return true;
}

static bool
show_queue( char* scheddAddr, char* scheddName, char* scheddMachine )
{
	ClassAdList jobs; 
	ClassAd		*job;
	static bool	setup_mask = false;

		// fetch queue from schedd	
	if( Q.fetchQueueFromHost(jobs, scheddAddr) != Q_OK ) {
		printf ("\n-- Failed to fetch ads from: %s : %s\n", 
									scheddAddr, scheddMachine);	
		return false;
	}

		// sort jobs by (cluster.proc)
	jobs.Sort( (SortFunctionType)JobSort );

		// check if job is being analyzed
	if( analyze ) {
			// print header
		if( querySchedds ) {
			printf ("\n\n-- Schedd: %s : %s\n", scheddName, scheddAddr);
		} else {
			printf ("\n\n-- Submitter: %s : %s : %s\n", scheddName, 
					scheddAddr, scheddMachine);	
		}

		jobs.Open();
		while( ( job = jobs.Next() ) ) {
			doRunAnalysis( job );
		}
		jobs.Close();

		return true;
	}

		// display the jobs from this submittor
	if( jobs.MyLength() != 0 || !global ) {
			// print header
		if ( ! customFormat ) {
			if( querySchedds ) {
				printf ("\n\n-- Schedd: %s : %s\n", scheddName, scheddAddr);
			} else {
				printf ("\n\n-- Submitter: %s : %s : %s\n", scheddName, 
					scheddAddr, scheddMachine);	
			}
		}
		
			// initialize counters
		malformed = 0; idle = 0; running = 0; unexpanded = 0, held = 0;
		
		if( verbose || use_xml ) {
			jobs.PrintClassAdList( );
			//jobs.fPrintAttrListList( stdout, use_xml ? true : false);
		} else if( customFormat ) {
			summarize = false;
			mask.display( stdout, &jobs );
		} else if( globus ) {
			summarize = false;
			printf( " %-7s %-14s %-11s %-8s %-18s  %-18s\n", 
				"ID", "OWNER", "STATUS", "MANAGER", "HOST", "EXECUTABLE" );
			if (!setup_mask) {
				mask.registerFormat ("%4d.", ATTR_CLUSTER_ID);
				mask.registerFormat ("%-3d ", ATTR_PROC_ID);
				mask.registerFormat ( (StringCustomFmt) format_owner,
									  ATTR_OWNER, "[????????????] " );
				mask.registerFormat( (IntCustomFmt) format_globusStatus,
									 ATTR_GLOBUS_STATUS, "[?????]" );
				mask.registerFormat( (StringCustomFmt)
									 format_globusHostAndJM,
									 ATTR_GLOBUS_RESOURCE, "fork    [?????]" );
				mask.registerFormat( "%-18.18s\n", ATTR_JOB_CMD );
				setup_mask = true;
				usingPrintMask = true;
			}
			mask.display( stdout, &jobs );
		} else if ( run || goodput ) {
			summarize = false;
			printf( " %-7s %-14s %11s %12s %-16s\n", "ID", "OWNER",
					"SUBMITTED", JOB_TIME,
					run ? "HOST(S)" : "GOODPUT CPU_UTIL   Mb/s" );
			if (!setup_mask) {
				mask.registerFormat ("%4d.", ATTR_CLUSTER_ID);
				mask.registerFormat ("%-3d ", ATTR_PROC_ID);
				mask.registerFormat ( (StringCustomFmt) format_owner,
									  ATTR_OWNER, "[????????????] " );
				mask.registerFormat(" ", "*bogus*", " ");  // force space
				mask.registerFormat ( (IntCustomFmt) format_q_date,
									  ATTR_Q_DATE, "[????????????]");
				mask.registerFormat(" ", "*bogus*", " ");  // force space
				mask.registerFormat ( (FloatCustomFmt) format_cpu_time,
									  ATTR_JOB_REMOTE_USER_CPU,
									  "[??????????]");
				if ( run ) {
					mask.registerFormat(" ", "*bogus*", " "); // force space
					// We send in ATTR_OWNER since we know it is always
					// defined, and we need to make sure
					// format_remote_host() is always called. We are
					// actually displaying ATTR_REMOTE_HOST if defined,
					// but we play some tricks if it isn't defined.
					mask.registerFormat ( (StringCustomFmt) format_remote_host,
										  ATTR_OWNER, "[????????????????]");
				} else {			// goodput
					mask.registerFormat ( (IntCustomFmt) format_goodput,
										  ATTR_JOB_STATUS,
										  " [?????]");
					mask.registerFormat ( (FloatCustomFmt) format_cpu_util,
										  ATTR_JOB_REMOTE_USER_CPU,
										  " [??????]");
					mask.registerFormat ( (FloatCustomFmt) format_mbps,
										  ATTR_BYTES_SENT,
										  " [????]");
				}
				mask.registerFormat("\n", "*bogus*", "\n");  // force newline
				setup_mask = true;
				usingPrintMask = true;
			}
			mask.display(stdout, &jobs);
		} else if( show_io ) {
			short_header();
			jobs.Open();
			while( (job=jobs.Next()) ) {
				io_display( job );
			}
			jobs.Close();
		} else {
			short_header();
			jobs.Open();
			while( (job=jobs.Next()) ) {
				displayJobShort( job );
			}
			jobs.Close();
		}

		if( summarize ) {
			printf( "\n%d jobs; "
					"%d idle, %d running, %d held",
					unexpanded+idle+running+held+malformed,
					idle,running,held);
			if (unexpanded>0) printf( ", %d unexpanded",unexpanded);
			if (malformed>0) printf( ", %d malformed",malformed);

            printf("\n");
		}
	}

	return true;
}


static void
setupAnalysis()
{
	CondorQuery	query(STARTD_AD);
	int			rval;
	char		buffer[64];
	char		*preq;
	ClassAd		*ad;
	char		remoteUser[128];
	int			index;

	ClassAdParser	parser;	// NAC

	// fetch startd ads
	if( pool ) {
		rval = query.fetchAds( startdAds , pool );
	} else {
		rval = query.fetchAds( startdAds );
	}
	if( rval != Q_OK ) {
		fprintf( stderr , "Error:  Could not fetch startd ads\n" );
		exit( 1 );
	}

	// fetch submittor prios
	fetchSubmittorPrios();

	// populate startd ads with remote user prios
	startdAds.Open();
	while( ( ad = startdAds.Next() ) ) {
		if( ad->EvaluateAttrString( ATTR_REMOTE_USER, remoteUser, 128 ) ) {
			if( ( index = findSubmittor( remoteUser ) ) != -1 ) {
				ad->InsertAttr( ATTR_REMOTE_USER_PRIO, 
								( double )( prioTable[index].prio ) ); // NAC
			}
		}
	}
	startdAds.Close();
	

	// setup condition expressions
	sprintf( buffer, "( ( MY.%s is true ) ? 1 : ( MY.%s is false ) ? 0 : MY.%s ) > MY.%s", ATTR_RANK, ATTR_RANK, ATTR_RANK, ATTR_CURRENT_RANK);	// NAC
	parser.ParseExpression( buffer, stdRankCondition );					// NAC
	
	sprintf( buffer, "( ( MY.%s is true ) ? 1 : ( MY.%s is false ) ? 0 : MY.%s ) >= MY.%s", ATTR_RANK, ATTR_RANK, ATTR_RANK, ATTR_CURRENT_RANK ); 	// NAC
	parser.ParseExpression( buffer, preemptRankCondition );				// NAC

	sprintf( buffer, "MY.%s > TARGET.%s + %f", ATTR_REMOTE_USER_PRIO, 
			ATTR_SUBMITTOR_PRIO, PriorityDelta );
	parser.ParseExpression( buffer, preemptPrioCondition );	// NAC

	// setup preemption requirements expression
	if( !( preq = param( "PREEMPTION_REQUIREMENTS" ) ) ) {
		fprintf( stderr, "\nWarning:  No PREEMPTION_REQUIREMENTS expression in"
					" config file --- assuming FALSE\n\n" );
		parser.ParseExpression( "FALSE", preemptionReq );	// NAC
	} else {
		if( !parser.ParseExpression( (string)preq, preemptionReq ) ) {	// NAC
		fprintf( stderr, "\nError:  Failed parse of "
				"PREEMPTION_REQUIREMENTS expression: \n\t%s\n", preq );
			exit( 1 );
		}
		free( preq );
	}

}


static void
fetchSubmittorPrios()
{
	ClassAd		ad;	// NAC
	char  	attrName[32], attrPrio[32];
  	char  	name[128];
  	float 	priority;
	int		i = 1;
	double 	priorityD;

		// Minor hack, if we're talking to a remote pool, assume the
		// negotiator is on the same host as the collector.
	Daemon	negotiator( DT_NEGOTIATOR, pool, pool );

	// connect to negotiator
	Sock* sock;

	if (!(sock = negotiator.startCommand( GET_PRIORITY, Stream::reli_sock, 0))) {
		fprintf( stderr, 
				 "(1) Error:  Could not get priorities from negotiator (%s)\n",
				 negotiator.fullHostname() );
		exit( 1 );
	}

	sock->eom();
	sock->decode();
	if( !getOldClassAdNoTypes(sock, ad) || !sock->end_of_message() ) {
		fprintf( stderr, 
				 "(2) Error:  Could not get priorities from negotiator (%s)\n",
				 negotiator.fullHostname() );
		exit( 1 );
	}
	sock->close();
	delete sock;


	i = 1;
	while( i ) {
    	sprintf( attrName , "Name%d", i );
    	sprintf( attrPrio , "Priority%d", i );

    	if( !ad.EvaluateAttrString( attrName, name, 128 ) || 
			!ad.EvaluateAttrReal( attrPrio, priorityD ) ) {
            break;
		}
		priority = (float)priorityD;

		prioTable[i-1].name = name;
		prioTable[i-1].prio = priority;
		i++;
	}

	if( i == 1 ) {
		printf( "Warning:  Found no submitters\n" );
	}
}


static void
doRunAnalysis( ClassAd *request )
{
	printf("%s", doRunAnalysisToBuffer( request) );
}

static char *
doRunAnalysisToBuffer( ClassAd *request )
{
	char	owner[128];
	char	remoteUser[128];
	char	buffer[128];
	int		index;
	ClassAd	*offer;
	ClassAd *root;			// NAC
	Value	result;			// NAC
	int		cluster, proc;
	int		jobState;
	int		niceUser;
	bool 	niceUserBool;	// NAC

	int 	fReqConstraint 	= 0;
	int		fOffConstraint 	= 0;
	int		fRankCond		= 0;
	int		fPreemptPrioCond= 0;
	int		fPreemptReqTest	= 0;
	int		available		= 0;
	int		totalMachines	= 0;

	bool 	match;			// NAC
	double	matchD;			// NAC
	bool 	boolValue; 		// NAC
	int 	intValue;  		// NAC
	Value	val;	   		// NAC

	return_buff[0]='\0';


	if( !request->EvaluateAttrString( ATTR_OWNER, owner, 128 ) ) {		// NAC
		return "Nothing here.\n";										// NAC
	}																	// NAC
	if( !request->EvaluateAttrInt( ATTR_NICE_USER, niceUser ) ) {		// NAC
		niceUser = 0;													// NAC
	}																	// NAC

	if( ( index = findSubmittor( fixSubmittorName( owner, niceUser ) ) ) < 0 ) 
		return "Nothing here.\n";

	request->InsertAttr( ATTR_SUBMITTOR_PRIO, ( double )( prioTable[index].prio ) ); // NAC

	request->EvaluateAttrInt( ATTR_CLUSTER_ID, cluster );
	request->EvaluateAttrInt( ATTR_PROC_ID, proc );
	request->EvaluateAttrInt( ATTR_JOB_STATUS, jobState );

	if( jobState == RUNNING ) {
		sprintf( return_buff,
			"---\n%03d.%03d:  Job is being serviced\n\n", cluster, 
			proc );
		return return_buff;
	}
	if( jobState == HELD ) {
		sprintf( return_buff,
			"---\n%03d.%03d:  Job is held.\n\n", cluster, 
			proc );
		return return_buff;
	}
	if( jobState == REMOVED ) {
		sprintf( return_buff,
			"---\n%03d.%03d:  Job is removed.\n\n", cluster, 
			proc );
		return return_buff;
	}

  	startdAds.Open();
	while( ( offer = startdAds.Next() ) ) {

		// 0.  info from machine
		remoteUser[0] = '\0';
		totalMachines++;
		offer->EvaluateAttrString( ATTR_NAME, buffer, 128 );		// NAC
		if( verbose ) sprintf( return_buff, "%-15.15s ", buffer );

		// 1. Request satisfied? 
		root = new ClassAd( );										// NAC
		root->Insert( "TARGET", offer );							// NAC
		request->SetParentScope(offer);								// NAC
		if( !request->EvaluateAttr( ATTR_REQUIREMENTS, val ) ) {	// NAC
               // there was a problem with the match				// NAC
			if( verbose ) {											// NAC
				sprintf( return_buff,								// NAC 
						 "%sError in matchmaking\n",				// NAC
						 return_buff );								// NAC
			}														// NAC
			request->SetParentScope( NULL );						// NAC
			offer->SetParentScope( NULL );							// NAC
			continue;												// NAC
		}															// NAC
		else if ( ( !val.IsBooleanValue() && !val.IsNumber() )	||	// NAC
				  ( val.IsBooleanValue( match ) && !match )		||	// NAC
				  ( val.IsNumber( matchD ) && !matchD ) ) {			// NAC

			if( verbose ) {
				sprintf( return_buff,
						 "%sFailed job constraint\n",
						 return_buff );

			}
			fReqConstraint++;
			request->SetParentScope( NULL );						// NAC
			offer->SetParentScope( NULL );							// NAC
			continue;
		}

			// 2. Offer satisfied? 
		root = new ClassAd( );										// NAC
		root->Insert( "TARGET", request );							// NAC
		offer->SetParentScope( request );							// NAC
		if( !offer->EvaluateAttr( ATTR_REQUIREMENTS, val ) ) {		// NAC
                // there was a problem with the match				// NAC
  			if( verbose ) {											// NAC
				sprintf( return_buff,								// NAC 
						 "%sError in matchmaking\n",				// NAC
						 return_buff );								// NAC
			}														// NAC
			offer->SetParentScope( NULL );							// NAC
			request->SetParentScope( NULL );						// NAC
			continue;												// NAC
		}															// NAC
		else if ( ( !val.IsBooleanValue() && !val.IsNumber() )	||	// NAC
				  ( val.IsBooleanValue( match ) && !match )		||	// NAC
				  ( val.IsNumber( matchD ) && !matchD ) ) {			// NAC
			
  			if( verbose ) { 
				strcat( return_buff, "Failed machine constraint\n");
			}  
			fOffConstraint++;
			offer->SetParentScope( NULL );							// NAC
			request->SetParentScope( NULL );						// NAC
			continue;
		}	
		offer->SetParentScope( NULL );								// NAC
		request->SetParentScope( NULL );							// NAC

		root = new ClassAd( );										// NAC
		root->Insert( "MY", offer );							// NAC
		root->Insert( "TARGET", request );
		request->SetParentScope( root );
		offer->SetParentScope( request );

		// 3. Is there a remote user?
		if( !offer->EvaluateAttrString( ATTR_REMOTE_USER, remoteUser, 128 ) ) {
			stdRankCondition->SetParentScope( offer );				// NAC
			offer->EvaluateExpr( stdRankCondition, result );		// NAC
			if( ( result.IsBooleanValue( boolValue ) && boolValue )	// NAC
				|| ( result.IsNumber( intValue ) && intValue ) ) {	// NAC
					// both sides satisfied and no remote user
				if( verbose ) sprintf( return_buff, "%sAvailable\n",
									   return_buff );
				available++;	
				continue;
			} else {
					// no remote user, but std rank condition failed

				fRankCond++;
				if( verbose ) {
					sprintf( return_buff,
							 "%sFailed rank condition: MY.Rank > MY.CurrentRank\n",
							 return_buff);
				}
				continue;
			}
		}

		// 4. Satisfies preemption priority condition?
		preemptPrioCondition->SetParentScope( offer );				// NAC
		offer->EvaluateExpr( preemptPrioCondition, result );		// NAC
		if( ( result.IsBooleanValue( boolValue ) && boolValue )		// NAC
			|| ( result.IsNumber( intValue ) && intValue ) ) {		// NAC

			// 5. Satisfies standard rank condition?
			stdRankCondition->SetParentScope( offer );				// NAC
			offer->EvaluateExpr( stdRankCondition, result );		// NAC
			if( ( result.IsBooleanValue( boolValue ) && boolValue )	// NAC
				|| ( result.IsNumber( intValue ) && intValue ) ) {	// NAC
				if( verbose ) {
					sprintf( return_buff, "%sAvailable\n", return_buff );
				}
				available++;
				continue;
			} else {

				// 6.  Satisfies preemption rank condition?
				preemptRankCondition->SetParentScope( offer );			// NAC
				offer->EvaluateExpr( preemptRankCondition, result );	// NAC
				if(	( result.IsBooleanValue( boolValue ) && boolValue )	// NAC
					|| ( result.IsNumber( intValue ) && intValue ) ) {	// NAC

					// 7.  Tripped on PREEMPTION_REQUIREMENTS?
					preemptionReq->SetParentScope( offer );				// NAC
					offer->EvaluateExpr( preemptionReq, result );		// NAC
					if( ( result.IsBooleanValue( boolValue ) 			// NAC
						  && !boolValue ) ||							// NAC
						( result.IsIntegerValue( intValue ) 			// NAC
						  && intValue == FALSE ) ) { 					// NAC
						fPreemptReqTest++;
						if( verbose ) {
							sprintf( return_buff,
									"%sCan preempt %s, but failed "
									"PREEMPTION_REQUIREMENTS test\n",
									return_buff,
									remoteUser);
						}
						continue;
					} else {
						// not held
						if( verbose ) {
							sprintf( return_buff,
								"%sAvailable (can preempt %s)\n",
								return_buff, remoteUser);
						}
						available++;
					}
				} else {
					// failed 6 and 5, but satisfies 4; so have priority
					// but not better or equally preferred than current
					// customer
					fRankCond++;
				}
			} 
		} else {
			// failed 4
			fPreemptPrioCond++;
			if( verbose ) {
				sprintf( return_buff,
					"%sInsufficient priority to preempt %s\n" , 
					return_buff, remoteUser );
			}
			continue;
		}
	}
	startdAds.Close();

	sprintf( return_buff,
			 "%s---\n%03d.%03d:  Run analysis summary.  Of %d machines,\n" 
			 "\t%5d were rejected by the job's requirements\n",
			 return_buff, cluster, proc, totalMachines,
			 fReqConstraint );
	
	if( fReqConstraint < totalMachines ) {
		sprintf( return_buff,
				 "%s\t%5d rejected the job\n"
				 "\t%5d are serving equal or higher priority customers%s\n" 
				 "\t%5d do not prefer this job\n"
				 "\t%5d cannot preempt because PREEMPTION_REQUIREMENTS are false\n"
				 "\t%5d are available to service your job\n",
				 return_buff,
				 fOffConstraint,
				 fPreemptPrioCond, niceUser ? "(*)" : "",
				 fRankCond,
				 fPreemptReqTest,
				 available );
	}

	int last_match_time=0, last_rej_match_time=0;
	request->EvaluateAttrInt(ATTR_LAST_MATCH_TIME, last_match_time);
	request->EvaluateAttrInt(ATTR_LAST_REJ_MATCH_TIME, last_rej_match_time);
	if (last_match_time) {
		time_t t = (time_t)last_match_time;
		sprintf( return_buff, "%s\tLast successful match: %s",
				 return_buff, ctime(&t) );
	} else if (last_rej_match_time) {
		strcat( return_buff, "\tNo successful match recorded.\n" );
	}
	if (last_rej_match_time > last_match_time) {
		time_t t = (time_t)last_rej_match_time;
		sprintf( return_buff, "%s\tLast failed match: %s",
				 return_buff, ctime(&t) );
        string buf;
		request->EvaluateAttrString( ATTR_LAST_REJ_MATCH_REASON, buf);
		if (buf.length() > 0) {
			sprintf( return_buff, "%s\tReason for last match failure: %s\n",
					 return_buff, buf.data() );
		}
	}

	if( niceUser ) {
		sprintf( return_buff, 
				 "%s\n\t(*)  Since this is a \"nice-user\" job, this job "
				 "has a\n\t     very low priority and is unlikely to preempt other "
				 "jobs.\n", return_buff );
	}
			

	if( fReqConstraint == totalMachines ) {
		strcat( return_buff, "\nWARNING:  Be advised:\n");
		strcat( return_buff, "   No machines matched job's requirements\n");
		strcat( return_buff, "\n" ); 	// NAC
	}

	string buffer_string = "";			// NAC
	char ana_buffer[2048];				// NAC

	if( fReqConstraint > 0 ) {
		analyzer.AnalyzeJobReqToBuffer( request, startdAds, buffer_string );
			// NAC
		strncpy( ana_buffer, buffer_string.c_str( ), 2048 );			// NAC
		strcat( return_buff, ana_buffer );	// NAC
	}

	if( fOffConstraint == totalMachines ) {
		sprintf( return_buff, "%s\nWARNING:  Be advised:", return_buff );
		sprintf( return_buff, "%s   Job %d.%d did not match any"
			"machine's requirements\n\n", return_buff, cluster, proc);
	}

	if( fOffConstraint > 0 ) { 			// NAC
		buffer_string = "";
		analyzer.AnalyzeJobAttrsToBuffer( request, startdAds, buffer_string );
		strncpy( ana_buffer, buffer_string.c_str( ), 2048 );			// NAC
		strcat( return_buff, ana_buffer );	// NAC
	}									// NAC

	return return_buff;
}


static int
findSubmittor( char *name ) 
{
	MyString 	sub(name);
	int			last = prioTable.getlast();
	int			i;
	
	for( i = 0 ; i <= last ; i++ ) {
		if( prioTable[i].name == sub ) return i;
	}

	prioTable[i].name = sub;
	prioTable[i].prio = 0.5;

	return i;
}


static char*
fixSubmittorName( char *name, int niceUser )
{
	static 	bool initialized = false;
	static	char * uid_domain = 0;
	static	char buffer[128];

	if( !initialized ) {
		uid_domain = param( "UID_DOMAIN" );
		if( !uid_domain ) {
			fprintf( stderr, "Error: UID_DOMAIN not found in config file\n" );
			exit( 1 );
		}
		initialized = true;
	}

    // potential buffer overflow! Hao
	if( strchr( name , '@' ) ) {
		sprintf( buffer, "%s%s%s", 
					niceUser ? NiceUserName : "",
					niceUser ? "." : "",
					name );
		return buffer;
	} else {
		sprintf( buffer, "%s%s%s@%s", 
					niceUser ? NiceUserName : "",
					niceUser ? "." : "",
					name, uid_domain );
		return buffer;
	}

	return NULL;
}
