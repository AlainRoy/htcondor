/* --------------------------------------------------------------------- */
/* This section is for helper utility functions and shared common rules and
	definitions. */

#define SET_GID_MODE		02775
#define EXECUTABLE_MODE		0755
#define OBJECT_MODE		0644
#define TEXT_MODE		OBJECT_MODE

.SUFFIXES: .C

.C.o:
	$(CPlusPlus) $(C_PLUS_FLAGS) -c $<

.f.o:
	$(Fortran) $(FFLAGS) -c $<

#if defined(Demangler)
DEMANGLE = 2>&1 | Demangler
#endif

/* Since the *_target macros use the objlist and libs variables BOTH
	for the link line AND the dependency list, we get screwed if we
	ever need to pass special flags or something in the libs variable
	via the *_target macro since those flags show up in the dependancy
	line and screw up make. So, these are the things we are going
	to allow to exist on the dependancy line for the program. */
#define DEP_FILTER %.o %.a %.so %.la

/* print out information about the function I'm translating. */
#define func(x)[Concat(FUNC_,x):__LINE__]

/* When I mangle certain tokens to have prefixes, what should they be? */
/* Add a 'condor_' prefix to whatever token I asked for */
#ifndef precon
#define precon(x)Concat(condor_,x)
#endif /* precon */

/* Add a 'strip_' prefix to whatever token I asked for */
#ifndef prestrip
#define prestrip(x)Concat(strip_,x)
#endif /* prestrip */

/* Add a 'static_' prefix to whatever token I asked for */
#ifndef prestatic
#define prestatic(x)Concat(static_,x)
#endif /* prestatic */

/* Add a '_dir' suffix to whatever token I asked for */
#ifndef sufdir
#define sufdir(x)Concat(x,_dir)
#endif /* sufdir */

/* --------------------------------------------------------------------- */
/* This section are all of the available rules for Imakefiles */

#define junkdir(daemon)Concat3(junk,_,daemon)
#define soapname(daemon)Concat(soap_,daemon)
#define gsoapname(daemon)Concat(gsoap_,daemon)

/*
** Set up to make all the objects in a particular directory.
*/

/* Create an object target */
#ifndef object_target
#define object_target(_name,obj_name)					@@\
XCOMM Begin translation of func(object_target) @@\
_name: obj_name					@@\
	cd obj_name; make $(SMP_FLAGS)			@@\
release:: obj_name					@@\
	cd obj_name; make release			@@\
stripped:: obj_name					@@\
	cd obj_name; make stripped			@@\
static:: obj_name					@@\
	cd obj_name; make static			@@\
depend:: obj_name					@@\
	cd obj_name; make depend			@@\
clean:: obj_name					@@\
	cd obj_name; make clean			@@\
docs:: obj_name					@@\
	cd obj_name; make html				@@\
makefiles:: obj_name obj_name/Makefile	@@\
obj_name/Makefile:					@@\
	cd obj_name; ../condor_imake 	@@\
object_dir_target(obj_name)		@@\
XCOMM End translation of func(object_target) 
#endif /* object_target */

/* Create an object target under the condor_* namespace.
 * Don't be tempted to redefine this rule in terms of the above
 * object_target() macro.  CPP does not allow directives inside a
 * macro argument.
 */
#ifndef condor_object_target
#define condor_object_target(obj_name)					@@\
XCOMM Begin translation of func(condor_object_target) @@\
obj_name: precon(obj_name)					@@\
	cd precon(obj_name); make $(SMP_FLAGS)			@@\
release:: precon(obj_name)					@@\
	cd precon(obj_name); make release			@@\
stripped:: precon(obj_name)					@@\
	cd precon(obj_name); make stripped			@@\
static:: precon(obj_name)					@@\
	cd precon(obj_name); make static			@@\
depend:: precon(obj_name)					@@\
	cd precon(obj_name); make depend			@@\
clean:: precon(obj_name)					@@\
	cd precon(obj_name); make clean			@@\
docs:: precon(obj_name)					@@\
	cd precon(obj_name); make html				@@\
makefiles:: precon(obj_name) precon(obj_name)/Makefile	@@\
precon(obj_name)/Makefile:					@@\
	cd precon(obj_name); ../condor_imake 	@@\
object_dir_target(precon(obj_name))		@@\
XCOMM End translation of func(condor_object_target) 
#endif /* condor_object_target */

/*
** List everything which should be built in this object tree.
*/
#define all_target(targetlist)				@@\
XCOMM Begin translation of func(all_target) @@\
all:: targetlist @@\
XCOMM End translation of func(all_target)

/*
** Just build a given thing from a given directory.
*/
#define single_target(dir,target)			@@\
XCOMM Begin translation of func(single_target) @@\
dir/target: dir							@@\
	cd dir; make $(SMP_FLAGS) target	@@\
XCOMM End translation of func(single_target)



/***********************************************************************
** building targets
**
** These rules are used for building various aspects of Condor.
** Primarily, binaries and libraries.  Binaries be dymanically
** linked, include debugging info, and not be stripped.
***********************************************************************/

/*
** Build a library from .o files.
*/
#ifndef library_target
#define library_target(libname,objlist)		@@\
XCOMM Begin translation of func(library_target) @@\
libname: objlist					@@\
	rm -f libname					@@\
	AR_REPLACE(libname,objlist)			@@\
clean::							@@\
	rm -f libname objlist		@@\
XCOMM End translation of func(library_target)
#endif /* library_target */


/*
** Build a C program from .o files and libraries.
*/
#if NEEDS_PRELINKER

/* under AIX, we need a special prelink phase which links the GNU CC generated
	.o files with GNU ld, but then uses the vendor linker the compiler should
	have been installed to use to link the prelinked object and the system
	libraries. */
#ifndef program_target
#define	program_target(program,objlist,libs)		@@\
XCOMM Begin translation of func(program_target) @@\
program: $(filter DEP_FILTER,objlist libs)						@@\
	$(PRELINK_C) $(PRELINK_C_FLAGS) -o __prelink__.o objlist libs @@\
	$(C_LINK) $(CFLAGS) -o program __prelink__.o $(ALL_LDFLAGS)	@@\
	rm -f __prelink__.o @@\
clean::								@@\
	rm -f program objlist			@@\
XCOMM End translation of func(program_target)
#endif /* program_target */

#else

/* everyone else gets a normal link rule */
#ifndef program_target
#define	program_target(program,objlist,libs)		@@\
XCOMM Begin translation of func(program_target) @@\
program: $(filter DEP_FILTER,objlist libs)						@@\
	$(C_LINK) $(CFLAGS) -o program objlist libs $(ALL_LDFLAGS)	@@\
clean::								@@\
	rm -f program objlist			@@\
XCOMM End translation of func(program_target)
#endif /* program_target */

#endif


/*
** Build a C program from .o files and libraries supplying the compile time
** and link time flags. For building utilites with special flags.
*/
#if NEEDS_PRELINKER

#ifndef program_target_complex
#define	program_target_complex(program,objlist,comflags,linkflags,libs)	@@\
XCOMM Begin translation of func(program_target_complex) @@\
program: $(filter DEP_FILTER,objlist libs)						@@\
	$(PRELINK_C) $(PRELINK_C_FLAGS) comflags -o __prelink__.o \
		objlist libs @@\
	$(C_LINK) comflags -o program __prelink__.o linkflags	@@\
	rm -f __prelink__.o @@\
clean::								@@\
	rm -f program objlist		@@\
XCOMM End translation of func(program_target_complex)
#endif  /* program_target_complex */

#else

#ifndef program_target_complex
#define	program_target_complex(program,objlist,comflags,linkflags,libs)	@@\
XCOMM Begin translation of func(program_target_complex) @@\
program: $(filter DEP_FILTER,objlist libs)						@@\
	$(C_LINK) comflags -o program objlist libs linkflags	@@\
clean::								@@\
	rm -f program objlist			@@\
XCOMM End translation of func(program_target_complex)
#endif  /* program_target_complex */

#endif

/*
** Build a C++ program from .o files and libraries.
*/
#if NEEDS_PRELINKER

#ifndef c_plus_target
#define	c_plus_target(program,objlist,libs)			@@\
XCOMM Begin translation of func(c_plus_target) @@\
program: $(filter DEP_FILTER,objlist libs)						@@\
	$(PRELINK_CPP) $(PRELINK_CPP_FLAGS) -o __prelink__.o objlist libs @@\
	$(CC_LINK) $(C_PLUS_FLAGS) -o program __prelink__.o \
		$(ALL_LDFLAGS) $(DEMANGLE)			@@\
	rm -f __prelink__.o @@\
clean::								@@\
	rm -f program objlist @@\
XCOMM End translation of func(c_plus_target)
#endif  /* c_plus_target */


#ifndef c_plus_nowrap_target
#define	c_plus_nowrap_target(program,objlist,libs)		@@\
XCOMM Begin translation of func(c_plus_target)			@@\
program: $(filter DEP_FILTER,objlist libs)			@@\
	$(PRELINK_CPP) $(PRELINK_CPP_FLAGS) -o __prelink__.o objlist libs @@\
	$(CC_LINK) $(C_PLUS_FLAGS) -o program __prelink__.o \
		$(NOWRAP_LDFLAGS) $(DEMANGLE)			@@\
	rm -f __prelink__.o					@@\
clean::								@@\
	rm -f program objlist					@@\
XCOMM End translation of func(c_plus_nowrap_target)
#endif  /* c_plus_nowarp_target */


#else  /* ! NEEDS_PRELINKER */


#ifndef c_plus_target
#define	c_plus_target(program,objlist,libs)			@@\
XCOMM Begin translation of func(c_plus_target) @@\
program: $(filter DEP_FILTER,objlist libs)						@@\
	$(CC_LINK) $(C_PLUS_FLAGS) -o program objlist libs \
		$(ALL_LDFLAGS) $(DEMANGLE)			@@\
clean::								@@\
	rm -f program objlist			@@\
XCOMM End translation of func(c_plus_target)
#endif  /* c_plus_target */


#ifndef c_plus_nowrap_target
#define	c_plus_nowrap_target(program,objlist,libs)		@@\
XCOMM Begin translation of func(c_plus_target)			@@\
program: $(filter DEP_FILTER,objlist libs)			@@\
	$(CC_LINK) $(C_PLUS_FLAGS) -o program objlist libs \
		$(NOWRAP_LDFLAGS) $(DEMANGLE)			@@\
clean::								@@\
	rm -f program objlist			@@\
XCOMM End translation of func(c_plus_nowrap_target)
#endif  /* c_plus_nowarp_target */


#endif  /* NEEDS_PRELINKER */


/*
** Build a C++ program from .o files and libraries supplying the compile and
** link flags. For building utility programs with special flags.
*/
#if NEEDS_PRELINKER

#ifndef c_plus_target_complex
#define	c_plus_target_complex(program,objlist,comflags,linkflags,libs)	@@\
XCOMM Begin translation of func(c_plus_target_complex) @@\
program: $(filter DEP_FILTER,objlist libs)						@@\
	$(PRELINK_CPP) $(PRELINK_CPP_FLAGS) comflags -o __prelink__.o \
		objlist libs @@\
	$(CC_LINK) comflags -o program __prelink__.o linkflags $(DEMANGLE)	@@\
	rm -f __prelink__.o @@\
clean::								@@\
	rm -f program objlist			@@\
XCOMM End translation of func(c_plus_target_complex)
#endif  /* c_plus_target_complex */

#else

#ifndef c_plus_target_complex
#define	c_plus_target_complex(program,objlist,comflags,linkflags,libs)	@@\
XCOMM Begin translation of func(c_plus_target_complex) @@\
program: $(filter DEP_FILTER,objlist libs)						@@\
	$(CC_LINK) comflags -o program objlist libs linkflags $(DEMANGLE)	@@\
clean::								@@\
	rm -f program objlist			@@\
XCOMM End translation of func(c_plus_target_complex)
#endif  /* c_plus_target_complex */

#endif

/*
** Build a template instantiation object
*/
#ifndef template_inst
#define template_inst(srcfile,objfile)               @@\
XCOMM Begin translation of func(template_inst) @@\
objfile: srcfile                                        @@\
	 $(CPlusPlus) $(INST_C_PLUS_FLAGS) -c srcfile -o objfile @@\
XCOMM End translation of func(template_inst)
#endif /* template_inst_obj */

/*
** Build a Java class from a .java file.
**
*/

#ifndef java_target
#define java_target(classfile,sourcefile,cpath)        @@\
XCOMM Begin translation of func(java_target) @@\
classfile: sourcefile                                      @@\
	$(JAVAC) $(JAVACFLAGS) -classpath cpath sourcefile @@\
clean::                                                    @@\
	rm -f classfile										@@\
XCOMM End translation of func(java_target)
#endif

/*
** Build a JAR file from several .java files.
**
*/

#ifndef jar_target
#define jar_target(jarfile,sourcefiles,classroot) @@\
XCOMM Begin translation of func(jar_target) @@\
jarfile: sourcefiles                                  @@\
	$(JAVAC) $(JAVACFLAGS) -d . sourcefiles       @@\
	$(JAR) $(JARFLAGS) cf $@ classroot            @@\
clean::                                               @@\
	rm -rf jarfile classroot						@@\
XCOMM End translation of func(jar_target)
#endif

/***********************************************************************
** Auto generated file rules
**
** These rules are for building autogenerated files by various
** mechanisms.
***********************************************************************/

/* given the name of the daemon, produce a list of object files for the
	generated sources from soapcpp2 
*/
#define soapobjs(daemon) @@\
SOAP_OBJS = Concat(soapname(daemon),C).o Concat(soapname(daemon),Server).o Concat(soapname(daemon),Stub).o @@\
SOAP_SRC = Concat(soapname(daemon),C).C Concat(soapname(daemon),Server).C Concat(soapname(daemon),H).h Concat(soapname(daemon),Stub).h

/* given a daemon name, and a service, use the soap compiler to produce a 
	set of interface files in a temporary directory and then copy the files
	to the current working directory, and also copy the generated
	wsdl files into the proper release directories if requestred.
*/
#define gen_soapfiles(daemon,service) @@\
soapfiles:: gsoapname(daemon).h @@\
	/bin/rm -rf junkdir(daemon) @@\
	/bin/mkdir junkdir(daemon) @@\
	$(SOAPCPP2) -I ../condor_daemon_core.V6 -d junkdir(daemon) -p soapname(daemon) gsoapname(daemon).h @@\
	cp junkdir(daemon)/Concat(soapname(daemon),C).cpp Concat(soapname(daemon),C).C @@\
	cp junkdir(daemon)/Concat(soapname(daemon),Server).cpp Concat(soapname(daemon),Server).C @@\
	cp junkdir(daemon)/service.nsmap . @@\
	cp junkdir(daemon)/Concat(soapname(daemon),H).h . @@\
	cp junkdir(daemon)/Concat(soapname(daemon),Stub).h . @@\
	cp junkdir(daemon)/service.wsdl . @@\
	/bin/rm -rf junkdir(daemon) @@\
	touch soapfiles @@\
	@@\
release_copy_target(service.wsdl,lib/webservice,service.wsdl,TEXT_MODE) @@\
strip_copy_target(service.wsdl,lib/webservice,service.wsdl,TEXT_MODE) @@\
static_copy_target(service.wsdl,lib/webservice,service.wsdl,TEXT_MODE) @@\
	@@\
clean:: @@\
	/bin/rm -f service.nsmap Concat(soapname(daemon),H).h Concat(soapname(daemon),Stub).h service.wsdl Concat(soapname(daemon),C).C Concat(soapname(daemon),Server).C soapfiles @@\
XCOMM Specifically add a dependancy from the generated .C files to the @@\
XCOMM .o files. Otherwise, the suffix rules do not get the dependencies @@\
XCOMM right. @@\
$(SOAP_OBJS): $(SOAP_SRC) @@\
$(SOAP_SRC): soapfiles

/***********************************************************************
** release targets
**
** These rules are used for copying files that have already been built
** into the release_dir, which is unstripped, for use at our pool.
** All directories need to support a "release" rule.
***********************************************************************/

/*
** Copy the given file to the specified directory, with the given mode.
*/
#ifndef release_target
#define release_target(file,dir,mode)		@@\
XCOMM Begin translation of func(release_target) @@\
$(RELEASE_DIR)/dir/file: file			@@\
	/bin/rm -f $(RELEASE_DIR)/dir/file	@@\
	cp file $(RELEASE_DIR)/dir			@@\
	chmod mode $(RELEASE_DIR)/dir/file	@@\
release:: $(RELEASE_DIR)/dir/file			@@\
XCOMM End translation of func(release_target)
#endif /* release_target */

/*
** Copy the given library to the specified directory, and run ranlib.
*/
#ifndef release_library
#define release_library(lib,dir) 			@@\
XCOMM Begin translation of func(release_library) @@\
$(RELEASE_DIR)/dir/lib: lib					@@\
	COPY_LIBRARY(lib,$(RELEASE_DIR)/dir/lib)		@@\
	RANLIB_TOUCH($(RELEASE_DIR)/dir/lib)			@@\
release:: $(RELEASE_DIR)/dir/lib	@@\
XCOMM End translation of func(release_library)
#endif  /* release_library */


/*
** Target is released by creating a symbolic link to another.
*/
#ifndef release_symlink_target
#define release_symlink_target(src,dir,dest)	@@\
XCOMM Begin translation of func(release_symlink_target) @@\
release:: $(RELEASE_DIR)/dir/dest			@@\
							@@\
$(RELEASE_DIR)/dir/dest: 			@@\
	/bin/rm -f $(RELEASE_DIR)/dir/dest	@@\
	ln -s src $(RELEASE_DIR)/dir/dest			@@\
XCOMM End translation of func(release_symlink_target)
#endif /* release_symlink_target */

/*
** Just create a symlink. We need this for the test suite 
*/
#ifndef release_plain_symlink_target
#define release_plain_symlink_target(src,dest)		@@\
XCOMM Begin translation of func(release_plain_symlink_target) @@\
release:: dest					@@\
dest: 						@@\
	/bin/rm -f dest				@@\
	ln -s src dest				@@\
clean::						@@\
	/bin/rm -f dest		@@\
XCOMM End translation of func(release_plain_symlink_target)
#endif /* release_plain_symlink_target */

/*
** Target is released by creating a hard link to another.
*/
#ifndef release_link_target
#define release_link_target(src,dir,dest)		@@\
XCOMM Begin translation of func(release_link_target) @@\
release:: $(RELEASE_DIR)/dir/dest		@@\
							@@\
$(RELEASE_DIR)/dir/dest: src			@@\
	/bin/rm -f $(RELEASE_DIR)/dir/dest	@@\
	ln src $(RELEASE_DIR)/dir/dest		@@\
XCOMM End translation of func(release_link_target)
#endif /* release_link_target */


/*
** Target is released by copying
*/
#ifndef release_copy_target
#define release_copy_target(src,dir,dest,mode)	@@\
XCOMM Begin translation of func(release_copy_target) @@\
release:: $(RELEASE_DIR)/dir/dest		@@\
							@@\
$(RELEASE_DIR)/dir/dest: src			@@\
	/bin/rm -f $(RELEASE_DIR)/dir/dest	@@\
	cp src $(RELEASE_DIR)/dir/dest		@@\
	chmod mode $(RELEASE_DIR)/dir/dest	@@\
XCOMM End translation of func(release_copy_target)
#endif /* release_copy_target */



/*
** Target is released by recursive copying
*/
#ifndef release_recursive_copy_target
#define release_recursive_copy_target(src, dest )	@@\
XCOMM Begin translation of func(release_recursive_copy_target) @@\
release:: $(RELEASE_DIR)/dest	       			@@\
							@@\
$(RELEASE_DIR)/dest: src				@@\
	/bin/rm -rf $(RELEASE_DIR)/dest		@@\
	$(CP_CMD) src $(RELEASE_DIR)/dest	@@\
XCOMM End translation of func(release_recursive_copy_target)
#endif /* release_recursive_copy_target */

/***********************************************************************
** strip targets
**
** These rules are used for copying files that have already been built
** into the strip_dir, then stripping them if they're binaries, for
** distribution to the world.  All directories need to support a
** "stripped" rule. 
***********************************************************************/

/*
** Copy a given file to the specified directory, with the given mode,
** and strip the binary.
*/
#ifndef strip_target
#define strip_target(file,dir,mode)			@@\
XCOMM Begin translation of func(strip_target) @@\
$(STRIP_DIR)/dir/file: file			@@\
	/bin/rm -f $(STRIP_DIR)/dir/file		@@\
	cp file $(STRIP_DIR)/dir			@@\
	$(STRIP) $(STRIP_DIR)/dir/file		@@\
	chmod mode $(STRIP_DIR)/dir/file		@@\
stripped:: $(STRIP_DIR)/dir/file @@\
XCOMM End translation of func(strip_target) 
#endif  /* strip_target */


/*
** Copy the given library to the specified directory, and run ranlib.
*/
#ifndef strip_library
#define strip_library(lib,dir)			@@\
XCOMM Begin translation of func(strip_library) @@\
$(STRIP_DIR)/dir/lib: lib				@@\
	COPY_LIBRARY(lib,$(STRIP_DIR)/dir/lib)	@@\
	RANLIB_TOUCH($(STRIP_DIR)/dir/lib)	@@\
	chmod OBJECT_MODE $(STRIP_DIR)/dir/lib	@@\
stripped:: $(STRIP_DIR)/dir/lib		@@\
XCOMM End translation of func(strip_library)
#endif  /* strip_library */


/* 
** Stripped target is released just by copying
*/
#ifndef strip_copy_target
#define strip_copy_target(src,dir,file,mode)	@@\
XCOMM Begin translation of func(strip_copy_target) @@\
$(STRIP_DIR)/dir/file: src			@@\
	/bin/rm -f $(STRIP_DIR)/dir/file		@@\
	cp src $(STRIP_DIR)/dir/file		@@\
	chmod mode $(STRIP_DIR)/dir/file		@@\
stripped:: $(STRIP_DIR)/dir/file		@@\
XCOMM End translation of func(strip_copy_target)
#endif /* strip_copy_target */


/*
** Stripped target is released by recursive copying
*/
#ifndef strip_recursive_copy_target
#define strip_recursive_copy_target(src,dest)			@@\
XCOMM Begin translation of func(strip_recursive_copy_target)	@@\
stripped:: $(STRIP_DIR)/dest					@@\
								@@\
$(STRIP_DIR)/dest: src						@@\
	/bin/rm -rf $(STRIP_DIR)/dest				@@\
	$(CP_CMD) src $(STRIP_DIR)/dest				@@\
XCOMM End translation of func(strip_recursive_copy_target)
#endif /* strip_recursive_copy_target */


/*
** Stripped target is released by creating a hard link to another. 
*/
#ifndef strip_link_target
#define strip_link_target(src,dir,dest)		@@\
XCOMM Begin translation of func(strip_link_target) @@\
stripped:: $(STRIP_DIR)/dir/dest		@@\
							@@\
$(STRIP_DIR)/dir/dest: src			@@\
	/bin/rm -f $(STRIP_DIR)/dir/dest		@@\
	ln src $(STRIP_DIR)/dir/dest		@@\
XCOMM End translation of func(strip_link_target)
#endif /* strip_link_target */



/*
** Stripped target is released by creating a symbolic link to another.
*/
#ifndef strip_symlink_target
#define strip_symlink_target(src,dir,dest)	@@\
XCOMM Begin translation of func(strip_symlink_target) @@\
stripped:: $(STRIP_DIR)/dir/dest		@@\
							@@\
$(STRIP_DIR)/dir/dest: 			@@\
	/bin/rm -f $(STRIP_DIR)/dir/dest		@@\
	ln -s src $(STRIP_DIR)/dir/dest		@@\
XCOMM End translation of func(strip_symlink_target)
#endif /* strip_symlink_target */



/***********************************************************************
** static targets
**
** These rules are used for creating the statically linked, stripped
** binary distribution for distribution to the world.  Any binary
** will be statically linked, then stripped, then copied into the
** given directory.  Other files should be put in the appropriate
** places for a full binary distribution (e.g. scripts, example files,
** libraries, etc).  All directories need to support a "static" rule. 
***********************************************************************/

/*
** Target to build a statically linked, stripped binary, placed in the
** specified directory.
*/
#if NEEDS_PRELINKER 

#ifndef	static_target
#if HAS_STATIC
#define	static_target(program,objlist,libs,dir)		@@\
XCOMM Begin translation of func(static_target) @@\
dir/program: program.static				@@\
	/bin/rm -f dir/program				@@\
	cp program.static dir/program			@@\
	chmod EXECUTABLE_MODE dir/program			@@\
	$(STRIP) dir/program				@@\
program.static: $(filter DEP_FILTER,objlist libs)					@@\
	$(PRELINK_CPP) $(PRELINK_CPP_FLAGS) -o __prelink__.o objlist libs @@\
	$(CC_LINK) $(STATIC)  $(C_PLUS_FLAGS) -o program.static __prelink__.o $(ALL_LDFLAGS) $(DEMANGLE) @@\
	rm -f __prelink__.o @@\
clean:: 							@@\
	rm -f program.static objlist				@@\
static:: dir/program			@@\
XCOMM End translation of func(static_target)
#else  /* ! HAS_STATIC */
#define	static_target(program,objlist,libs,dir)		@@\
XCOMM Begin translation of func(static_target) @@\
static::				       @@\
XCOMM End translation of func(static_target)
#endif  /* HAS_STATIC */
#endif  /* static_target */

#else  /* ! NEEDS_PRELINKER */

#ifndef	static_target
#if HAS_STATIC
#define	static_target(program,objlist,libs,dir)		@@\
XCOMM Begin translation of func(static_target) @@\
dir/program: program.static				@@\
	/bin/rm -f dir/program				@@\
	cp program.static dir/program			@@\
	chmod EXECUTABLE_MODE dir/program			@@\
	$(STRIP) dir/program				@@\
program.static: $(filter DEP_FILTER,objlist libs) 				@@\
	$(CC_LINK) $(STATIC)  $(C_PLUS_FLAGS) -o program.static objlist libs $(ALL_LDFLAGS) $(DEMANGLE) @@\
clean:: 							@@\
	rm -f program.static objlist				@@\
static:: dir/program			@@\
XCOMM End translation of func(static_target)
#else  /* ! HAS_STATIC */
#define	static_target(program,objlist,libs,dir)	@@\
XCOMM Begin translation of func(static_target)	@@\
static::					@@\
XCOMM End translation of func(static_target)
#endif  /* HAS_STATIC */
#endif  /* static_target */

#endif  /* NEEDS_PRELINKER */


/*
** Copy the given library to the specified directory, and run ranlib.
*/
#ifndef static_library
#if HAS_STATIC
#define static_library(lib,dir)			@@\
XCOMM Begin translation of func(static_library) @@\
$(STATIC_DIR)/dir/lib: lib			@@\
	COPY_LIBRARY(lib,$(STATIC_DIR)/dir/lib) @@\
	RANLIB_TOUCH($(STATIC_DIR)/dir/lib)	@@\
	chmod OBJECT_MODE $(STATIC_DIR)/dir/lib	@@\
static:: $(STATIC_DIR)/dir/lib			@@\
XCOMM End translation of func(static_library)
#else  /* ! HAS_STATIC */
#define static_library(lib,dir)			@@\
XCOMM Begin translation of func(static_library) @@\
static::					@@\
XCOMM End translation of func(static_library)
#endif  /* HAS_STATIC */
#endif  /* static_library */



/* 
** Static target is released just by copying
*/
#ifndef static_copy_target
#if HAS_STATIC
#define static_copy_target(src,dir,file,mode)	@@\
XCOMM Begin translation of func(static_copy_target) @@\
$(STATIC_DIR)/dir/file: src			@@\
	/bin/rm -f $(STATIC_DIR)/dir/file	@@\
	cp src $(STATIC_DIR)/dir/file		@@\
	chmod mode $(STATIC_DIR)/dir/file	@@\
static:: $(STATIC_DIR)/dir/file			@@\
XCOMM End translation of func(static_copy_target)
#else  /* ! HAS_STATIC */
#define static_copy_target(src,dir,file,mode)	@@\
XCOMM Begin translation of func(static_copy_target) @@\
static::					@@\
XCOMM End translation of func(static_copy_target)
#endif  /* HAS_STATIC */
#endif /* static_copy_target */


/*
** Static target is released by recursive copying
*/
#ifndef static_recursive_copy_target
#if HAS_STATIC
#define static_recursive_copy_target(src,dest)			@@\
XCOMM Begin translation of func(static_recursive_copy_target)	@@\
static:: $(STATIC_DIR)/dest					@@\
$(STATIC_DIR)/dest: src						@@\
	/bin/rm -rf $(STATIC_DIR)/dest				@@\
	$(CP_CMD) src $(STATIC_DIR)/dest			@@\
XCOMM End translation of func(static_recursive_copy_target)
#else  /* ! HAS_STATIC */
#define static_recursive_copy_target(src,dest)			@@\
XCOMM Begin translation of func(static_recursive_copy_target)	@@\
static::							@@\
XCOMM End translation of func(static_recursive_copy_target)
#endif  /* HAS_STATIC */
#endif /* static_recursive_copy_target */


/*
** Static target is released by creating a hard link to another. 
*/
#ifndef static_link_target
#if HAS_STATIC
#define static_link_target(src,dir,dest)	@@\
XCOMM Begin translation of func(static_link_target) @@\
static:: $(STATIC_DIR)/dir/dest			@@\
						@@\
$(STATIC_DIR)/dir/dest: src			@@\
	/bin/rm -f $(STATIC_DIR)/dir/dest	@@\
	ln src $(STATIC_DIR)/dir/dest		@@\
XCOMM End translation of func(static_link_target)
#else  /* ! HAS_STATIC */
#define static_link_target(src,dir,dest)	@@\
XCOMM Begin translation of func(static_link_target) @@\
static::					@@\
XCOMM End translation of func(static_link_target)
#endif  /* HAS_STATIC */
#endif /* static_link_target */

/*
** Static target is released by creating a symbolic link to another.
*/
#ifndef static_symlink_target
#if HAS_STATIC
#define static_symlink_target(src,dir,dest)	@@\
XCOMM Begin translation of func(static_symlink_target) @@\
static:: $(STATIC_DIR)/dir/dest			@@\
$(STATIC_DIR)/dir/dest: 			@@\
	/bin/rm -f $(STATIC_DIR)/dir/dest	@@\
	ln -s src $(STATIC_DIR)/dir/dest	@@\
XCOMM End translation of func(static_symlink_target)
#else  /* ! HAS_STATIC */
#define static_symlink_target(src,dir,dest)	@@\
XCOMM Begin translation of func(static_symlink_target) @@\
static::					@@\
XCOMM End translation of func(static_symlink_target)
#endif  /* HAS_STATIC */
#endif /* static_symlink_target */


/***********************************************************************
** Misc link-related targets
**
** These rules are used for creating hard and soft links for various
** make targets.
**
***********************************************************************/


/*
** The all* targets make the links when you do a "make all".  They
** only take two args, a src and a dest, since they assume you want
** the links in the current directory.
*/
#ifndef all_link_target
#define all_link_target(src,dest)		@@\
XCOMM Begin translation of func(all_link_target) @@\
all:: dest					@@\
dest: src					@@\
	/bin/rm -f dest				@@\
	ln src dest				@@\
clean::						@@\
	/bin/rm -f dest			@@\
XCOMM End translation of func(all_link_target)
#endif /* all_link_target */


#ifndef all_symlink_target
#define all_symlink_target(src,dest)		@@\
XCOMM Begin translation of func(all_symlink_target) @@\
all:: dest					@@\
dest: src					@@\
	/bin/rm -f dest				@@\
	ln -s src dest				@@\
clean::						@@\
	/bin/rm -f dest			@@\
XCOMM End translation of func(all_symlink_target)
#endif /* all_symlink_target */


#ifndef all_copy_target
#define all_copy_target(src,dest)		@@\
XCOMM Begin translation of func(all_copy_target) @@\
all:: dest					@@\
dest: src					@@\
	/bin/rm -f dest				@@\
	cp src dest				@@\
clean::						@@\
	/bin/rm -f dest			@@\
XCOMM End translation of func(all_copy_target)
#endif /* all_copy_target */

/***********************************************************************
** tarball targets
**
** These rules are used for creating the contrib and release tarballs.
**
** The "both_tarball" is made with the first list of files from the
** regular, main directory, and the second list of contrib files that
** are copied in from the appropriate contrib directory, included in
** the tarball, then removed.
**
***********************************************************************/
#ifndef contrib_tarball
#define contrib_tarball(name,files)		@@\
XCOMM Begin translation of func(contrib_tarball) @@\
full_tarball(name,files,contrib)	@@\
move_contrib_tarballs(name)			@@\
XCOMM End translation of func(contrib_tarball)
#endif /* contrib_tarball */


#ifndef move_contrib_tarballs
#if HAS_STATIC
#define move_contrib_tarballs(name)			@@\
XCOMM Begin translation of func(move_contrib_tarball) @@\
name:: strip_contrib/name static_contrib/name	@@\
	mv strip_contrib/name strip_dir/name	@@\
	mv static_contrib/name static_dir/name	@@\
XCOMM End translation of func(move_contrib_tarball)
#else /* ! HAS_STATIC */
#define move_contrib_tarballs(name)			@@\
XCOMM Begin translation of func(move_contrib_tarball) @@\
name:: strip_contrib/name				@@\
	mv strip_contrib/name strip_dir/name @@\
XCOMM End translation of func(move_contrib_tarball)
#endif /* HAS_STATIC */
#endif /* move_contrib_tarballs */


#ifndef release_tarball
#define release_tarball(name,files)	@@\
XCOMM Begin translation of func(release_tarball) @@\
full_tarball(name,files,dir)		@@\
XCOMM End translation of func(release_tarball)
#endif /* release_tarball */


#ifndef full_tarball
#define full_tarball(name,files,type)		@@\
XCOMM Begin translation of func(full_tarball) @@\
strip_full_tarball(name,files,type)	@@\
static_full_tarball(name,files,type)	@@\
XCOMM End translation of func(full_tarball)
#endif /* full_tarball */


#ifndef strip_full_tarball
#define strip_full_tarball(name,files,type)		@@\
XCOMM Begin translation of func(strip_full_tarball) @@\
name:: prestrip(type)/name			@@\
							@@\
prestrip(type)/name: stripped			@@\
	/bin/rm -f prestrip(type)/name		@@\
	cd prestrip(type); $(TAR_CMD) -cvf name files	@@\
XCOMM End translation of func(strip_full_tarball)
#endif /* strip_full_tarball */


#ifndef static_full_tarball
#if HAS_STATIC
#define static_full_tarball(name,files,type)	@@\
XCOMM Begin translation of func(static_full_tarball) @@\
name:: prestatic(type)/name			@@\
							@@\
prestatic(type)/name: static			@@\
	/bin/rm -f prestatic(type)/name		@@\
	cd prestatic(type); $(TAR_CMD) -cvf name files	@@\
XCOMM End translation of func(static_full_tarball)
#else 
#define static_full_tarball(name,files,type) /* NULL MACRO */ @@\
XCOMM Begin translation of func(static_full_tarball)	@@\
XCOMM NULL BODY									@@\
XCOMM End translation of func(static_full_tarball)
#endif /* HAS_STATIC */
#endif /* static_full_tarball */



#ifndef both_tarball
#define both_tarball(name,files,contribfiles)		@@\
XCOMM Begin translation of func(both_tarball) @@\
strip_both_tarball(name,files,contribfiles)	@@\
static_both_tarball(name,files,contribfiles)	@@\
XCOMM End translation of func(both_tarball)
#endif /* both_tarball */


#ifndef strip_both_tarball
#define strip_both_tarball(name,files,contribfiles)		@@\
XCOMM Begin translation of func(strip_both_tarball) @@\
name:: strip_dir/name		@@\
							@@\
strip_dir/name: stripped	@@\
	perl condor_scripts/make_both_tarball -cmd "$(TAR_CMD)" strip, name, files, contribfiles	@@\
XCOMM End translation of func(strip_both_tarball)
#endif /* strip_both_tarball */


#ifndef static_both_tarball
#if HAS_STATIC
#define static_both_tarball(name,files,contribfiles)	@@\
XCOMM Begin translation of func(static_both_tarball) @@\
name:: static_dir/name					@@\
								@@\
static_dir/name: static					@@\
	perl condor_scripts/make_both_tarball -cmd "$(TAR_CMD)" static, name, files, contribfiles	@@\
XCOMM End translation of func(static_both_tarball)
#else 
#define static_both_tarball(name,files,contribfiles) /* NULL MACRO */ @@\
XCOMM Begin translation of func(static_both_tarball)	@@\
XCOMM NULL BODY									@@\
XCOMM End translation of func(static_both_tarball)
#endif /* HAS_STATIC */
#endif /* static_both_tarball */

/***********************************************************************
** PureSoftware targets
**
** These rules are used for creating special debugging binaries built
** for either purify, purecoverage, or both.
***********************************************************************/

#if HAS_PURIFY

#ifndef pure_c_plus_target
#define	pure_c_plus_target(program,objlist,libs)	@@\
XCOMM Begin translation of func(pure_c_plus_target)	@@\
program: $(filter DEP_FILTER,objlist libs)					@@\
	purify -g++=yes -inuse-at-exit=yes -chain-length=50 -cache-dir=$(PURE_CACHE_DIR) purecov -g++=yes $(CC_LINK) $(C_PLUS_FLAGS) -o program objlist libs $(PURIFY_LDFLAGS)	@@\
clean::							@@\
	rm -f program objlist		@@\
XCOMM End translation of func(pure_c_plus_target)
#endif /* pure_c_plus_target */

#ifndef purify_c_plus_target
#define	purify_c_plus_target(program,objlist,libs)	@@\
XCOMM Begin translation of func(purify_c_plus_target)	@@\
program: $(filter DEP_FILTER,objlist libs)					@@\
	purify -g++=yes -inuse-at-exit=yes -chain-length=50 PureCollector $(CC_LINK) $(C_PLUS_FLAGS) -o program objlist libs $(PURIFY_LDFLAGS)	@@\
clean::							@@\
	rm -f program objlist		@@\
XCOMM End translation of func(purify_c_plus_target)
#endif /* purify_c_plus_target */


#ifndef purecov_c_plus_target
#define	purecov_c_plus_target(program,objlist,libs)	@@\
XCOMM Begin translation of func(purecov_c_plus_target)	@@\
program: $(filter DEP_FILTER,objlist libs)					@@\
	purecov -g++=yes -cache-dir=$(PURE_CACHE_DIR) $(CC_LINK) $(C_PLUS_FLAGS) -o program objlist libs $(PURIFY_LDFLAGS)	@@\
clean:: 						@@\
	rm -f program objlist		@@\
XCOMM End translation of func(purecov_c_plus_target)
#endif /* purecov_c_plus_target */


#ifndef quantify_c_plus_target
#define	quantify_c_plus_target(program,objlist,libs)	@@\
XCOMM Begin translation of func(quantify_c_plus_target)	@@\
program: $(filter DEP_FILTER,objlist libs)						@@\
	quantify -g++=yes -cache-dir=$(PURE_CACHE_DIR) $(CC_LINK) $(C_PLUS_FLAGS) -o program objlist libs $(PURIFY_LDFLAGS)     @@\
clean::		 						@@\
	rm -f program objlist			@@\
XCOMM End translation of func(quantify_c_plus_target)
#endif /* quantify_c_plus_target */


#ifndef pure_target
#define	pure_target(dir,program)				@@\
XCOMM Begin translation of func(pure_target)	@@\
$(PURE_DIR)/program: $(PURE_DIR) dir/program		@@\
	cp dir/program $(PURE_DIR)/program		@@\
dir/program: dir						@@\
	cd dir; make program					@@\
pure:: $(PURE_DIR)/program				@@\
XCOMM End translation of func(pure_target)
#endif /* pure_target */


#else

#ifndef pure_target
#define	pure_target(dir,program)			/* NULL MACRO */ @@\
XCOMM Begin translation of func(pure_target) @@\
XCOMM NULL BODY! @@\
XCOMM End translation of func(pure_target)
#endif /* pure_target */


#ifndef pure_c_plus_target
#define	pure_c_plus_target(program,objlist,libs)	/* NULL MACRO */ @@\
XCOMM Begin translation of func(pure_c_plus_target) @@\
XCOMM NULL BODY! @@\
XCOMM End translation of func(pure_c_plus_target)
#endif /* pure_c_plus_target */


#ifndef purify_c_plus_target
#define	purify_c_plus_target(program,objlist,libs)	/* NULL MACRO */ @@\
XCOMM Begin translation of func(purify_c_plus_target) @@\
XCOMM NULL BODY! @@\
XCOMM End translation of func(purify_c_plus_target)
#endif /* purify_c_plus_target */


#ifndef purecov_c_plus_target
#define	purecov_c_plus_target(program,objlist,libs)	/* NULL MACRO */ @@\
XCOMM Begin translation of func(purecov_c_plus_target) @@\
XCOMM NULL BODY! @@\
XCOMM End translation of func(purecov_c_plus_target)
#endif /* purecov_c_plus_target */


#ifndef quantify_c_plus_target
#define	quantify_c_plus_target(program,objlist,libs) /* NULL MACRO */ @@\
XCOMM Begin translation of func(quantify_c_plus_target) @@\
XCOMM NULL BODY! @@\
XCOMM End translation of func(quantify_c_plus_target)
#endif /* quantify_c_plus_target */

#endif	/* HAS_PURIFY */

/* Build public super target.
 * Build a program from C++ source, as well as the most common
 * dependent public release targets.
 */
#ifndef c_plus_public_target
#define c_plus_public_target(program,dir,objlist,libs) @@\
XCOMM Begin translation of func(c_plus_public_target) @@\
all_target(program) @@\
c_plus_target(program,objlist,libs) @@\
release_target(program,dir,EXECUTABLE_MODE) @@\
strip_target(program,dir,EXECUTABLE_MODE) @@\
static_target(program,objlist,libs,$(STATIC_DIR)/dir) @@\
pure_c_plus_target(program,objlist,libs) @@\
purecov_c_plus_target(program,objlist,libs) @@\
XCOMM End translation of func(c_plus_public_target)
#endif /* c_plus_public_target */


/* Build public super target without any --wrap flags
 * Build a program from C++ source, as well as the most common
 * dependent public release targets.
 */
#ifndef c_plus_public_nowrap_target
#define c_plus_public_nowrap_target(program,dir,objlist,libs) @@\
XCOMM Begin translation of func(c_plus_public_nowrap_target) @@\
all_target(program) @@\
c_plus_nowrap_target(program,objlist,libs) @@\
release_target(program,dir,EXECUTABLE_MODE) @@\
strip_target(program,dir,EXECUTABLE_MODE) @@\
static_target(program,objlist,libs,$(STATIC_DIR)/dir) @@\
pure_c_plus_target(program,objlist,libs) @@\
purecov_c_plus_target(program,objlist,libs) @@\
XCOMM End translation of func(c_plus_public_target)
#endif /* c_plus_public_target */



/***********************************************************************
** condor_compile rules
**
** Rules to link programs with the Condor libraries using
** condor_compile.  These are used primarily in the test suites. 
***********************************************************************/

/* This is a little weird, but if "FLAGS_MACRO_NAME" is defined, we're
   in a compiler-specific subdirectory of the test suite.  If it's
   not, we're at the top-level, so how we find condor_compile and
   condor_arch link are different...
*/
#ifdef FLAGS_MACRO_NAME
CONDOR_COMPILE = ../../condor_scripts/condor_compile
CONDOR_ARCH_LINK = perl ../../condor_scripts/condor_arch_link
PRE_BUILT_RELEASE = ../../release_dir
#else
CONDOR_COMPILE = ../condor_scripts/condor_compile
CONDOR_ARCH_LINK = perl ../condor_scripts/condor_arch_link
PRE_BUILT_RELEASE = ../release_dir
#endif

/*
** Link a program with Condor libraries for the standard universe
*/
#ifndef CLINK
#if IS_CLIPPED
#define CLINK(compiler,name,obj)	/* */ @@\
XCOMM Begin translation of func(CLINK)		@@\
XCOMM NULL BODY!				@@\
XCOMM End translation of func(CLINK)
#else
#define CLINK(compiler,name,obj)		@@\
XCOMM Begin translation of func(CLINK)		@@\
all:: name.cndr.exe				@@\
name:: name.cndr.exe				@@\
       @$(TRUE)					@@\
name.cndr.exe: $(CONDOR_COMPILE) $(PRE_BUILT_RELEASE)/lib obj	@@\
	$(CONDOR_COMPILE) $(CONDOR_COMPILE_FLAGS) compiler -o name.cndr.exe obj $(TEST_LDFLAGS) @@\
	$(CONDOR_ARCH_LINK) name.cndr.exe		@@\
clean::						@@\
	rm -f name.cndr.exe obj			@@\
XCOMM End translation of func(CLINK)
#endif /* IS_CLIPPED */
#endif /* CLINK */


/*
** Link a program to run normally intended for the standard universe
** without libraries at all
*/
#ifndef CLINK_NOSTD
#define CLINK_NOSTD(compiler,name,obj)		@@\
XCOMM Begin translation of func(CLINK_NOSTD)	@@\
all:: name.exe					@@\
name:: name.exe					@@\
       @$(TRUE)					@@\
name.exe: obj x_fake_ckpt.o			@@\
	compiler -o name.exe obj x_fake_ckpt.o $(TEST_LDFLAGS)	@@\
clean::						@@\
	rm -f name.exe obj			@@\
XCOMM End translation of func(CLINK_NOSTD)
#endif /* CLINK_NOSTD */



/*
** Link a program to run normally (no condor libraries at all)
*/
#ifndef LINK
#define LINK(compiler,name,obj)			@@\
XCOMM Begin translation of func(LINK)		@@\
LINK_LIB(compiler,name,obj,)			@@\
XCOMM End translation of func(LINK)
#endif /* LINK */

/*
** Link a program to run normally (no condor libraries at all)
** This takes a final argument for libraries to link with which 
** we do NOT attempt to remove in make clean...
*/
#ifndef LINK_LIB
#define LINK_LIB(compiler,name,obj,lib)		@@\
XCOMM Begin translation of func(LINK_LIB)	@@\
all:: name.exe					@@\
name:: name.exe					@@\
       @$(TRUE)					@@\
name.exe: obj					@@\
	compiler -o name.exe obj lib $(TEST_LDFLAGS)  @@\
clean::						@@\
	rm -f name.exe obj			@@\
XCOMM End translation of func(LINK_LIB)
#endif /* LINK_LIB */


/***********************************************************************
** DEPRECATED condor_compile rules
***********************************************************************/

/*
** Link a program for running remotely
** This rule is deprecated, in favor of using CLINK 
*/
#ifndef RLINK
#if IS_CLIPPED
#define RLINK(compiler,name,obj)	/* */ @@\
XCOMM Begin translation of func(RLINK)		@@\
XCOMM NULL BODY!				@@\
XCOMM End translation of func(RLINK)
#else
#define RLINK(compiler,name,obj)		@@\
XCOMM Begin translation of func(RLINK)		@@\
all:: name.remote				@@\
name:: name.remote				@@\
       @$(TRUE)					@@\
name.remote: obj				@@\
	$(CONDOR_COMPILE) $(CONDOR_COMPILE_FLAGS) compiler -o name.remote obj $(TEST_LDFLAGS) @@\
	$(CONDOR_ARCH_LINK) name.remote		@@\
clean::						@@\
	rm -f name.remote obj			@@\
XCOMM End translation of func(RLINK)
#endif /* IS_CLIPPED */
#endif /* RLINK */


/*
** Link a program to run normally (no condor at all)
** This rule is deprecated in favor of using LINK
*/
#ifndef VLINK
#define VLINK(compiler,name,obj)		@@\
XCOMM Begin translation of func(VLINK)		@@\
all:: name.vanilla				@@\
name:: name.vanilla				@@\
       @$(TRUE)					@@\
name.vanilla: obj fake_ckpt.o			@@\
	compiler -o name.vanilla obj fake_ckpt.o $(TEST_LDFLAGS)	@@\
clean::						@@\
	rm -f name.vanilla obj			@@\
XCOMM End translation of func(VLINK)
#endif /* VLINK */



/***********************************************************************
** test suite rules
**
** Rules to build, submit, and verify the test suite
***********************************************************************/

/*
** Make directory and Makefile for a compiler in the test suite.
*/

#ifndef C_COMPILER_TARGET
#define C_COMPILER_TARGET(compiledir,compiler,flags_macro_name) @@\
XCOMM Begin translation of func(C_COMPILER_TARGET)		@@\
all:: compiledir compiledir/Makefile				@@\
	cd compiledir; $(MAKE)					@@\
								@@\
compiledir: 							@@\
	mkdir compiledir					@@\
								@@\
compiledir/Imakefile:	CImakefile				@@\
	cd compiledir; /bin/rm -f Imakefile			@@\
	cd compiledir; ln -s ../CImakefile Imakefile		@@\
								@@\
compiledir/Makefile: compiledir compiledir/Imakefile		@@\
	cd compiledir; ../../condor_imake -I../../../config \	@@\
	   -I.. -DC_COMPILER=compiler \				@@\
	   -DFLAGS_MACRO_NAME=flags_macro_name			@@\
								@@\
clean::								@@\
	rm -rf compiledir compiler_list				@@\
								@@\
compiler_list:: compiler_list_compiledir			@@\
								@@\
compiler_list_compiledir:: safe_append.pl			@@\
	@perl safe_append.pl -v -f compiler_list -a compiledir	@@\
XCOMM End translation of func(C_COMPILER_TARGET)
#endif /* C_COMPILER_TARGET */


#ifndef CPP_COMPILER_TARGET
#define CPP_COMPILER_TARGET(compiledir,compiler,flags_macro_name)	@@\
XCOMM Begin translation of func(CPP_COMPILER_TARGET)		@@\
all:: compiledir compiledir/Makefile				@@\
	cd compiledir; $(MAKE)					@@\
								@@\
compiledir: 							@@\
	mkdir compiledir					@@\
								@@\
compiledir/Imakefile: CPPImakefile				@@\
	cd compiledir; /bin/rm -f Imakefile			@@\
	cd compiledir; ln -s ../CPPImakefile Imakefile		@@\
								@@\
compiledir/Makefile: compiledir compiledir/Imakefile		@@\
	cd compiledir; ../../condor_imake -I../../../config \	@@\
	   -I.. -DCPP_COMPILER=compiler \			@@\
	   -DFLAGS_MACRO_NAME=flags_macro_name			@@\
								@@\
clean::								@@\
	rm -rf compiledir compiler_list				@@\
								@@\
compiler_list:: compiler_list_compiledir			@@\
								@@\
compiler_list_compiledir:: safe_append.pl			@@\
	@perl safe_append.pl -v -f compiler_list -a compiledir	@@\
XCOMM End translation of func(CPP_COMPILER_TARGET)
#endif /* CPP_COMPILER_TARGET */


#ifndef F_COMPILER_TARGET
#define F_COMPILER_TARGET(compiledir,compiler,flags_macro_name,has_recursion) @@\
XCOMM Begin translation of func(F_COMPILER_TARGET) @@\
all:: compiledir compiledir/Makefile				@@\
	cd compiledir; $(MAKE)					@@\
								@@\
compiledir:							@@\
	mkdir compiledir					@@\
								@@\
compiledir/Imakefile: FImakefile				@@\
	cd compiledir; /bin/rm -f Imakefile			@@\
	cd compiledir; ln -s ../FImakefile Imakefile		@@\
								@@\
compiledir/Makefile: compiledir compiledir/Imakefile	@@\
	cd compiledir; ../../condor_imake -I../../../config \	@@\
		-I.. -DFORTRAN_HAS_RECURSION=has_recursion \	@@\
		-DF_COMPILER=compiler	\			@@\
		-DFLAGS_MACRO_NAME=flags_macro_name		@@\
								@@\
clean::								@@\
	rm -rf compiledir compiler_list				@@\
								@@\
compiler_list:: Concat(compiler_list_,compiledir)		@@\
								@@\
Concat(compiler_list_,compiledir):: safe_append.pl		@@\
	@perl safe_append.pl -v -f compiler_list -a compiledir	@@\
XCOMM End translation of func(F_COMPILER_TARGET)
#endif /* F_COMPILER_TARGET */


/***********************************************************************
** Rules for building, describing, and declaring tests
***********************************************************************/

#ifndef BUILD
#define BUILD(cmplr,name,ext)		@@\
XCOMM Begin translation of func(BUILD)	@@\
DEP_SYMLINK_EXT(name,ext)		@@\
LINK(cmplr,name,name.o)			@@\
XCOMM End translation of func(BUILD)
#endif /* BUILD */

#ifndef BUILD_DEP
#define BUILD_DEP(cmplr,name,ext,dep)	@@\
XCOMM Begin translation of func(BUILD_DEP) @@\
DEP_SYMLINK_EXT(name,ext)		@@\
LINK(cmplr,name,name.o dep)		@@\
XCOMM End translation of func(BUILD_DEP)
#endif /* BUILD_DEP */

#ifndef BUILD_DEP_LIB
#define BUILD_DEP_LIB(cmplr,name,ext,dep,lib)	@@\
XCOMM Begin translation of func(BUILD_DEP_LIB)	@@\
DEP_SYMLINK_EXT(name,ext)			@@\
LINK_LIB(cmplr,name,name.o dep,lib)		@@\
XCOMM End translation of func(BUILD_DEP_LIB)
#endif /* BUILD_DEP_LIB */

#ifndef CBUILD
#define CBUILD(cmplr,name,ext)		@@\
XCOMM Begin translation of func(CBUILD) @@\
DEP_SYMLINK_EXT(name,ext)		@@\
CLINK(cmplr,name,name.o)		@@\
CLINK_NOSTD(cmplr,name,name.o)		@@\
XCOMM End translation of func(CBUILD)
#endif /* CBUILD */

#ifndef CBUILD_DEP
#define CBUILD_DEP(cmplr,name,ext,dep)	@@\
XCOMM Begin translation of func(CBUILD_DEP) @@\
DEP_SYMLINK_EXT(name,ext)		@@\
CLINK(cmplr,name,name.o dep)		@@\
CLINK_NOSTD(cmplr,name,name.o dep)	@@\
XCOMM End translation of func(CBUILD_DEP)
#endif /* CBUILD_DEP */

#ifndef DEP_SYMLINK
#ifdef FLAGS_MACRO_NAME
#define DEP_SYMLINK(name,file)		@@\
XCOMM Begin translation of func(DEP_SYMLINK) @@\
name:: file				@@\
       @$(TRUE)				@@\
all:: file				@@\
file::					@@\
	/bin/rm -f file 		@@\
	ln -s ../file file		@@\
XCOMM End translation of func(DEP_SYMLINK)
#else /* ! defined(FLAGS_MACRO_NAME) */
#define DEP_SYMLINK(name,file)		@@\
XCOMM Begin translation of func(DEP_SYMLINK) @@\
XCOMM NULL BODY				@@\
XCOMM End translation of func(DEP_SYMLINK)
#endif /* defined(FLAGS_MACRO_NAME) */
#endif /* DEP_SYMLINK */

#ifndef DEP_SYMLINK_EXT
#define DEP_SYMLINK_EXT(name,ext)		@@\
XCOMM Begin translation of func(DEP_SYMLINK_EXT) @@\
DEP_SYMLINK(name,name.ext)			@@\
XCOMM End translation of func(DEP_SYMLINK_EXT)
#endif /* DEP_SYMLINK_EXT */


#ifndef DEPS
#define DEPS(name,deps)				@@\
XCOMM Begin translation of func(DEPS)		@@\
all:: deps					@@\
name:: deps					@@\
       @$(TRUE)					@@\
XCOMM End translation of func(DEPS)
#endif /* DEPS */


#ifndef RUN
#define RUN(name)				@@\
XCOMM Begin translation of func(RUN)		@@\
DEP_SYMLINK_EXT(name,run)			@@\
DEPS(name,Condor.pm CondorTest.pm)		@@\
list_all:: Concat(list_all__,name)		@@\
Concat(list_all__,name):: safe_append.pl name.run	@@\
	@perl safe_append.pl -v -f list_all -a name	@@\
XCOMM End translation of func(RUN)
#endif /* RUN */


/*
   TESTCLASS_DECL() is used to declare a new testclass in the test
   suite.  However, exactly what it has to do depends on if it's in
   the top-level Imakefile or in the compiler specific subdirs.  In
   the compiler specific subdirs, it just has to define a dummy rule
   for the given testclass so that "make [testclass]" will have at
   least 1 target, and will work, even if there are no tests to build
   for that class.  In the top-level, it has to find all the compiler
   subdirectories (by depending on the compiler_list), and for each
   one in the list, cd into the corresponding subdirectory and invoke
   "make [testclass]".

   There are some things this rule will do in common, regardless of if
   it's in the top-level or a compiler subdirectory.  These tasks are
   put in a common rule, TESTCLASS_DECL_BASE(), so they can be shared.
*/
#ifndef TESTCLASS_DECL
#ifdef FLAGS_MACRO_NAME
#define TESTCLASS_DECL(classname)		@@\
XCOMM Begin translation of func(TESTCLASS_DECL)	@@\
TESTCLASS_DECL_BASE(classname)			@@\
classname::					@@\
	@$(TRUE)				@@\
XCOMM End translation of func(TESTCLASS_DECL)
#else /* ! FLAGS_MACRO_NAME */
#define TESTCLASS_DECL(classname)		@@\
XCOMM Begin translation of func(TESTCLASS_DECL)	@@\
TESTCLASS_DECL_BASE(classname)			@@\
classname:: compiler_list			@@\
	for X in `cat compiler_list` ; do \	@@\
	    make $$X/Makefile; \		@@\
	     cd $$X; make classname; cd ..; \	@@\
	done					@@\
XCOMM End translation of func(TESTCLASS_DECL)
#endif /* FLAGS_MACRO_NAME */
#endif /* TESTCLASS_DECL */

/*
   This rule contains common stuff for both versions of
   TESTCLASS_DECL().  See the comment above for why there are two.
   This rule handles all the testclass list related work.  In
   particular, it ensures that the "all_lists" target depends on
   making a list for this class, it adds this class to the master list
   of all testclasses ("list_testclass"), it initializes the list for
   this specific testclass ("list_[classname]"), and cleans up all of
   the above on "make clean".
*/
#ifndef TESTCLASS_DECL_BASE
#define TESTCLASS_DECL_BASE(classname)		@@\
XCOMM Begin translation of func(TESTCLASS_DECL_BASE) @@\
all_lists:: Concat(list_,classname)		@@\
list_testclass:: Concat(list_testclass_,classname)	@@\
Concat(list_testclass_,classname):: safe_append.pl	@@\
	@perl safe_append.pl -v -f list_testclass -a classname	@@\
Concat(list_,classname):: list_testclass	@@\
	touch Concat(list_,classname)		@@\
clean::						@@\
	rm -f list_testclass Concat(list_,classname) @@\
XCOMM End translation of func(TESTCLASS_DECL_BASE)
#endif /* TESTCLASS_DECL_BASE */


/*
   This rule is how a given test is added to a specific testclass.
   It ensures that the "all_lists" target depends on this testclass's
   list, which helps us catch errors early in the build process.  It
   also ensures that the classname itself depends on this test
   (e.g. "TESTCLASS(foo,bar)" will ensure that "make bar" will build
   test foo), and it verifies that this testclass has been properly
   declared with a TESTCLASS_DECL() rule.  It does this final step by
   depending on the master list of testclasses (which is only created
   and populated by TESTCLASS_DECL() rules), and it greps through that
   list to find the given testclass this rule is envoked with.  If
   this rule is being called with a testclass not in the master list,
   make will fail with a verbose error message.  If it's being called
   with a valid testclass, it appends the given testname into the list
   for the given classname.
*/
#ifndef TESTCLASS
#define TESTCLASS(testname,classname)		@@\
XCOMM Begin translation of func(TESTCLASS)	@@\
all:: Concat(list_,classname)			@@\
all_lists:: Concat(list_,classname)		@@\
classname:: Concat4(list_,classname,__,testname)	@@\
classname:: testname				@@\
Concat(list_,classname):: Concat4(list_,classname,__,testname)	@@\
Concat4(list_,classname,__,testname):: list_testclass safe_append.pl	@@\
	@grep classname list_testclass > /dev/null; \	@@\
	if test $$? -ne 0 ; then \		@@\
	   CLASSNAME=str(classname); \		@@\
	   TESTNAME=str(testname); \		@@\
	   echo "ERROR: testclass \"$$CLASSNAME\" is not declared!"; \ @@\
	   echo "ERROR: test \"$$TESTNAME\" is in this testclass!"; \ @@\
	   echo "A) add a TESTCLASS_DECL() rule for \"$$CLASSNAME\", or"; \ @@\
	   echo "B) put \"$$TESTNAME\" in a different testclass"; \ @@\
	   exit 1; \				@@\
	fi					@@\
	@perl safe_append.pl -v -f Concat(list_,classname) -a testname  @@\
XCOMM End translation of func(TESTCLASS)
#endif /* TESTCLASS */


#ifndef DESC
#define DESC(name,description)	@@\
XCOMM Begin translation of func(DESC)		@@\
desc:: Concat(name,_desc)			@@\
	@$(TRUE)				@@\
Concat(name,_desc):				@@\
	@echo description > name.desc		@@\
XCOMM End translation of func(DESC)
#endif /* DESC */



/***********************************************************************
** DEPRECATED (OWO) rules for building and linking a given test program
***********************************************************************/

#ifndef OWO_BUILD
#define OWO_BUILD(cmplr,name,ext)		@@\
XCOMM Begin translation of func(OWO_BUILD)	@@\
OWO_BUILD_FILES(name,ext)			@@\
RLINK(cmplr,name,name.o)		@@\
VLINK(cmplr,name,name.o)		@@\
XCOMM End translation of func(OWO_BUILD)
#endif /* OWO_BUILD */

#ifndef OWO_BUILD_EXTRA
#define OWO_BUILD_EXTRA(cmplr,name,ext,obj)	@@\
XCOMM Begin translation of func(OWO_BUILD_EXTRA) @@\
OWO_BUILD_FILES(name,ext)			@@\
RLINK(cmplr,name,obj name.o)	@@\
VLINK(cmplr,name,obj name.o) @@\
XCOMM End translation of func(OWO_BUILD_EXTRA)
#endif /* OWO_BUILD_EXTRA */

#ifndef OWOW_OWO_RBUILD
#define OWO_RBUILD(cmplr,name,ext)		@@\
XCOMM Begin translation of func(OWO_RBUILD) @@\
OWO_BUILD_FILES(name,ext)		@@\
RLINK(cmplr,name,name.o)	@@\
XCOMM End translation of func(OWO_RBUILD)
#endif /* OWO_RBUILD */


#ifndef OWO_BUILD_FILES
#define OWO_BUILD_FILES(name,ext)		@@\
XCOMM Begin translation of func(OWO_BUILD_FILES) @@\
name:: name.ext					@@\
       @$(TRUE)					@@\
all:: name.ext					@@\
name.ext:					@@\
	ln -s ../name.ext .			@@\
clean::						@@\
	rm -f name.ext				@@\
XCOMM End translation of func(OWO_BUILD_FILES)
#endif /* OWO_BUILD_FILES */


#ifndef OWO_RUN
#define OWO_RUN(name)	@@\
XCOMM Begin translation of func(OWO_RUN)	@@\
all:: name.run name.cmd				@@\
name:: name.run name.cmd			@@\
       @$(TRUE)					@@\
name.run: Condor.pm CondorTest.pm		@@\
	rm -f name.run				@@\
	ln -s ../name.run .			@@\
name.cmd:					@@\
	rm -f name.cmd				@@\
	ln -s ../name.cmd .			@@\
clean::						@@\
	rm -f name.run name.cmd run_list	@@\
run_list:: Concat(run_list_,name)		@@\
Concat(run_list_,name):: safe_append.pl name.run	@@\
	@perl safe_append.pl -v -f run_list -a name	@@\
XCOMM End translation of func(OWO_RUN)
#endif /* OWO_RUN */


#ifndef OWO_BUILD_DEPS
#define OWO_BUILD_DEPS(name,deps)	@@\
XCOMM Begin translation of func(OWO_BUILD_DEPS)	@@\
all:: deps					@@\
name:: deps					@@\
       @$(TRUE)					@@\
clean::						@@\
	rm -f deps				@@\
XCOMM End translation of func(OWO_BUILD_DEPS)
#endif /* OWO_BUILD_DEPS */


/***********************************************************************
** Doc++ rules  
***********************************************************************/


/* This can't be called doc++_target b/c Imake doesn't like "+" */
#ifndef html_target
#define html_target(files)					@@\
XCOMM Begin translation of func(html_target) @@\
html: files							@@\
	/bin/rm -rf html					@@\
	DocCompiler -H -d html -u -g -l -j -p       \           @@\
		-m -f -B ../html/condor_banner.html \		@@\
		files @@\
XCOMM End translation of func(html_target)
#endif /* html_target */


/***********************************************************************
** misc rules
**
** Everything else.
***********************************************************************/

/*

** These macros are used to convert a string into a Makefile variable
** reference, by "dollar-paren-ifying" it.  We need to do this with
** two macros like this to get around weirdness caused by the
** pre-processor not doing the proper substitutions all at once.  See
** the comment in src/condor_c++_util/condor_version.C for more
** details.  -Derek Wright <wright@cs.wisc.edu> 1/25/00
*/ 
#define x_dollar_paren(a) $(a)
#define dollar_paren(a) x_dollar_paren(a)


/*
** These special object files are created by extracting a
** standard routine from a system library and changing the
** name by conversion to uppercase.
*/
#ifndef uppercase_target
#define uppercase_target(libname,objname,newname,old_string,new_string)	@@\
XCOMM Begin translation of func(uppercase_target) @@\
newname: libname ToUpper						@@\
	cd $(TMP_DIR); AR_EXTRACT(libname,objname);			@@\
	./ToUpper $(TMP_DIR)/objname newname old_string new_string 	@@\
	rm -f $(TMP_DIR)/objname	@@\
XCOMM End translation of func(uppercase_target)
#endif /* uppercase_target */


#ifndef obj_extract
#define obj_extract(libname,objname)			@@\
XCOMM Begin translation of func(obj_extract) @@\
objname: libname					@@\
	AR_EXTRACT(libname,objname);			@@\
clean:: 						@@\
	rm -f objname				@@\
XCOMM End translation of func(obj_extract)
#endif /* obj_extract */


/*
** Build a file using an awk program
*/
#ifndef awk_target
#define awk_target(targ,input,prog)			@@\
XCOMM Begin translation of func(awk_target) @@\
targ:	input prog					@@\
	awk -f prog input > targ			@@\
clean::							@@\
	rm -f targ		@@\
XCOMM End translation of func(awk_target)
#endif /* awk_target */

/*
** Import ".o" files from another directory as symbolic links.  Uses
** Make macro "IMPORT_LINKS" which must be initialized to the
** "import_links" shell script in this directory.
*/
#ifndef import
#define import(dir,obj)			@@\
XCOMM Begin translation of func(import) @@\
obj:						@@\
	$(IMPORT_LINKS) dir obj			@@\
clean::						@@\
	rm -f obj	@@\
XCOMM End translation of func(import)
#endif /* import */


/*
** Just make a simple directory.
*/
#ifndef simple_dir_target
#define simple_dir_target(dirname)			@@\
XCOMM Begin translation of func(simple_dir_target) @@\
dirname:						@@\
	mkdir dirname					@@\
XCOMM End translation of func(simple_dir_target)
#endif  /* simple_dir_target */


/*
** Build an object directory with symbolic links back into the
** source directory.  Making it appear as though all the source
** files are in the directory where we want to build the objects
** will simplify the Makefiles.
** The really-clean rule is for blowing away a whole build workspace
** and starting over from scratch.  However, since that's totally
** overkill and dangerous for a source workspace, if we see a "CVS"
** directory, we print a message and exit.  Notice that we use "@if"
** to tell make to pass this directly to the shell.  That way, it
** doesn't echo this test for every directory, but instead just prints
** the error and bails out if it finds the directory.
*/

#ifndef object_dir_target
#define object_dir_target(dir_name)					@@\
XCOMM Begin translation of func(object_dir_target) @@\
dir_name:								@@\
	perl $(SRC_TREE)/condor_scripts/make_dir_tree dir_name $(SRC_TREE) @@\
really-clean::								@@\
	@if [ -d CVS ]; then echo "You definitely do NOT want to do this in your source repository." ; echo "Try doing it in a build directory, instead."; exit 1; fi @@\
	rm -rf dir_name		@@\
XCOMM End translation of func(object_dir_target)
#endif /* object_dir_target */


/*
** Build a skeleton object tree for a particular platform.
*/
#ifndef platform_target
#define platform_target(platform)			@@\
XCOMM Begin translation of func(platform_target) @@\
platform.init: platform ALWAYS				@@\
	cp GENERIC/CheckPlatformType.c platform		@@\
	cp Imakefile.platform_skel platform/Imakefile	@@\
	cd platform; ../condor_imake 		@@\
	cd platform; make directories; make depend	@@\
platform: 						@@\
	mkdir platform				@@\
XCOMM End translation of func(platform_target)
#endif  /* platform_target */


/*
** Check to make sure we are running on the correct kind of machine
** and operating system to make object files for this platform.
*/
#ifndef check_platform_target
#define check_platform_target				@@\
XCOMM Begin translation of func(check_platform_target) @@\
CheckPlatformType:					@@\
	rm -f CheckPlatformType				@@\
	cc $(CFLAGS) -o CheckPlatformType ../GENERIC/CheckPlatformType.c	@@\
	./CheckPlatformType				@@\
	rm -f CheckPlatformType			@@\
XCOMM End translation of func(check_platform_target)
#endif  /* check_platform_target */


/*
** Build Makefile dependencies for an object tree.
**
** We could just make one rule that takes a list of the source
** files. Because we have a lot of Imakefiles, and it's a pain to 
** list the source files, I have made a few different methods:
** 1) A target that takes a list of source files.
** 2) A target that takes a list of C++ objects and derives the
**    the list of C++ files. Note that you use it like:
**           depend_target_cplus_objects(OBJ)
**    That is, you don't have $OBJ, just OBJ.
** 3) A target that takes a list of C objects and derives the
**    list of C files. It is used like number #2.
**
** Also note that you can only use one of these in an Imakefile. 
** If you can't use #2 xor #3 for convenience, you have to list
** list out the sources to use for #1. 
*/

#ifndef depend_source_target
#define depend_source_target(source_list)  @@\
XCOMM Begin translation of func(depend_source_target) @@\
sinclude dependencies                      @@\
                                           @@\
depend:	ALWAYS                             @@\
	$(CPlusPlus) $(C_PLUS_FLAGS) -MM source_list > dependencies @@\
XCOMM End translation of func(depend_source_target)
#endif /* depend_source_target */


#ifndef depend_cplus_objects_target
#define depend_cplus_objects_target(obj_list)   @@\
XCOMM Begin translation of func(depend_cplus_objects_target) @@\
sinclude dependencies                           @@\
DEPEND_CPLUS_SRC := $(obj_list:.o=.C)       @@\
                                                @@\
depend:	ALWAYS				                    @@\
	$(CPlusPlus) $(C_PLUS_FLAGS) -MM $(DEPEND_CPLUS_SRC) > dependencies @@\
XCOMM End translation of func(depend_cplus_objects_target)
#endif /* depend_cplus_objects_target */


#ifndef depend_c_objects_target
#define depend_c_objects_target(obj_list)  @@\
XCOMM Begin translation of func(depend_c_objects_target) @@\
sinclude dependencies                      @@\
DEPEND_C_SRC := $(obj_list:.o=.c)      @@\
                                           @@\
depend:	ALWAYS				               @@\
	$(CPlusPlus) $(CFLAGS) -MM $(DEPEND_C_SRC) > dependencies	@@\
XCOMM End translation of func(depend_c_objects_target)
#endif /* depend_c_objects_target */

#ifndef man_full_target
#define man_full_target(name,type)				@@\
XCOMM BEGIN translation of func(man_full_target)		@@\
manpages:: sufdir(type)/man/man1/name				@@\
sufdir(type)/man/man1/name: $(EXT_TRIGGER)/man-current		@@\
	/bin/rm -f sufdir(type)/man/man1/name			@@\
	cp $(MAN_DIR)/man1/name sufdir(type)/man/man1/name	@@\
	chmod 0644 sufdir(type)/man/man1/name			@@\
XCOMM End translation of func(man_full_target)
#endif /* ifndef man_full_target */


#ifndef man_target
#if HAS_STATIC
#define man_target(name)				@@\
XCOMM BEGIN translation of func(man_target)		@@\
man_full_target(name,strip)				@@\
man_full_target(name,static)				@@\
man_full_target(name,release)				@@\
XCOMM End translation of func(man_target)
#else /* HAS_STATIC */
#define man_target(name)				@@\
XCOMM BEGIN translation of func(man_target)		@@\
man_full_target(name,strip)				@@\
man_full_target(name,release)				@@\
XCOMM End translation of func(man_target)
#endif /* HAS_STATIC */
#endif /* ifndef man_target */


/*
** Externals build rule
*/

#ifndef ext_target
#define ext_target(package_id,ext_dep)				@@\
XCOMM Begin translation of func(ext_target) @@\
ext_nodep_target(package_id,ext_dep)	@@\
externals:: $(EXT_TRIGGER)/$(package_id)	@@\
XCOMM End translation of func(ext_target)
#endif

#ifndef ext_nodep_target
#define ext_nodep_target(package_id,ext_dep)	@@\
XCOMM Begin translation of func(ext_nodep_target) @@\
$(EXT_TRIGGER)/$(package_id): ext_dep			@@\
        $(EXT_ROOT)/build_external --extern_dir=$(EXT_ROOT) --package_name=$(package_id) --extern_config=$(EXT_CONFIG_SH) @@\
XCOMM End translation of func(ext_nodep_target)
#endif

