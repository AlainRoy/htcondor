/*
** Set up some shared, common rules and defininitions
*/
.SUFFIXES: .C

.C.o:
	$(CPlusPlus) $(NON_INST_C_PLUS_FLAGS) -c $<

.f.o:
	$(Fortran) $(FFLAGS) -c $<
	
#define SET_GID_MODE		02775
#define EXECUTABLE_MODE		0755
#define OBJECT_MODE		0644

#if defined(Demangler)
DEMANGLE = 2>&1 | Demangler
#endif


/*
** Set up to make all the objects in a particular directory.
*/
#ifndef object_target
#define object_target(obj_name)					@@\
##obj_name##: condor_##obj_name					@@\
	cd condor_##obj_name; make $(SMP_FLAGS)			@@\
release:: condor_##obj_name					@@\
	cd condor_##obj_name; make release			@@\
stripped:: condor_##obj_name					@@\
	cd condor_##obj_name; make stripped			@@\
static:: condor_##obj_name					@@\
	cd condor_##obj_name; make static			@@\
clean:: condor_##obj_name					@@\
	cd condor_##obj_name; make clean			@@\
docs:: condor_##obj_name					@@\
	cd condor_##obj_name; make html				@@\
makefiles:: condor_##obj_name condor_##obj_name##/Makefile	@@\
condor_##obj_name##/Makefile:					@@\
	cd condor_##obj_name ; imake IMAKE_FLAGS		@@\
object_dir_target(condor_##obj_name)		
#endif /* object_target */

/*
** List everything which should be built in this object tree.
*/
#define all_target(targetlist)				@@\
all: targetlist

/*
** Just build a given thing from a given directory.
*/
#define single_target(dir, target)			@@\
##dir##/##target##: dir					@@\
	cd dir; make target


/***********************************************************************
** building targets
**
** These rules are used for building various aspects of Condor.
** Primarily, binaries and libraries.  Binaries be dymanically
** linked, include debugging info, and not be stripped.
***********************************************************************/

/*
** Build a library from .o files.
*/
#ifndef library_target
#define library_target( libname, objlist )		@@\
libname: objlist					@@\
	rm -f libname					@@\
	AR_REPLACE( libname, objlist )	@@\
clean::							@@\
	rm -f libname 
#endif /* library_target */


/*
** Build a C program from .o files and libraries.
*/
#ifndef program_target
#define	program_target( program, objlist, libs )		@@\
program: objlist libs						@@\
	$(CC) $(CFLAGS) -o program objlist libs $(LDFLAGS) $(SITE_LDFLAGS) @@\
clean::								@@\
	rm -f program 
#endif  /* program_target */


/*
** Build a C++ program from .o files and libraries.
*/
#ifndef c_plus_target
#define	c_plus_target( program, objlist, libs )			@@\
program: objlist libs						@@\
	$(CPlusPlus) $(NON_INST_C_PLUS_FLAGS) -o program objlist libs \
		$(LDFLAGS) $(SITE_LDFLAGS) $(DEMANGLE)		@@\
clean::								@@\
	rm -f program 
#endif  /* c_plus_target */


/*
** Build a template instantiation object
*/
#ifndef template_inst
#define template_inst( srcfile, objfile ) 		@@\
objfile: srcfile								@@\
	$(CPlusPlus) $(INST_C_PLUS_FLAGS) -c srcfile -o objfile
#endif /* template_inst_obj */


/***********************************************************************
** release targets
**
** These rules are used for copying files that have already been built
** into the release_dir, which is unstripped, for use at our pool.
** All directories need to support a "release" rule.
***********************************************************************/

/*
** Copy the given file to the specified directory, with the given mode.
*/
#ifndef release_target
#define release_target( file, dir, mode )		@@\
dir##/##file: file					@@\
	/bin/rm -f dir##/##file				@@\
	cp file dir					@@\
	chmod mode dir##/##file				@@\
release:: dir##/##file
#endif  /* release_target */


/*
** Copy the given library to the specified directory, and run ranlib.
*/
#ifndef release_library
#define release_library( lib, dir ) 			@@\
dir##/##lib: lib					@@\
	COPY_LIBRARY( lib, dir##/##lib )		@@\
	RANLIB_TOUCH( dir##/##lib )			@@\
release:: dir##/##lib
#endif  release_library


/*
** Target is released by creating a symbolic link to another.
*/
#ifndef release_symlink_target
#define release_symlink_target( src, dir, dest )	@@\
release:: $(RELEASE_DIR)/##dir##/##dest			@@\
							@@\
$(RELEASE_DIR)/##dir##/##dest##: src			@@\
	/bin/rm -f $(RELEASE_DIR)/##dir##/##dest	@@\
	ln -s src $(RELEASE_DIR)/##dir##/##dest			
#endif /* release_symlink_target */


/*
** Target is released by creating a hard link to another.
*/
#ifndef release_link_target
#define release_link_target( src, dir, dest )		@@\
release:: $(RELEASE_DIR)/##dir##/##dest##		@@\
							@@\
$(RELEASE_DIR)/##dir##/##dest##: src			@@\
	/bin/rm -f $(RELEASE_DIR)/##dir##/##dest	@@\
	ln src $(RELEASE_DIR)/##dir##/##dest		
#endif /* release_link_target */


/*
** Target is released by copying
*/
#ifndef release_copy_target
#define release_copy_target( src, dir, dest, mode )	@@\
release:: $(RELEASE_DIR)/##dir##/##dest##		@@\
							@@\
$(RELEASE_DIR)/##dir##/##dest##: src			@@\
	/bin/rm -f $(RELEASE_DIR)/##dir##/##dest	@@\
	cp src $(RELEASE_DIR)/##dir##/##dest		@@\
	chmod mode $(RELEASE_DIR)/##dir##/##dest
#endif /* release_copy_target */


/***********************************************************************
** strip targets
**
** These rules are used for copying files that have already been built
** into the strip_dir, then stripping them if they're binaries, for
** distribution to the world.  All directories need to support a
** "stripped" rule. 
***********************************************************************/

/*
** Copy a given file to the specified directory, with the given mode,
** and strip the binary.
*/
#ifndef strip_target
#define strip_target( file, dir, mode )			@@\
##dir##/##file##: file					@@\
	/bin/rm -f dir##/##file				@@\
	cp file dir					@@\
	strip dir##/##file				@@\
	chmod mode dir##/##file				@@\
stripped:: dir##/##file
#endif  strip_target


/*
** Copy the given library to the specified directory, and run ranlib.
*/
#ifndef strip_library
#define strip_library( lib, dir )			@@\
dir##/##lib: lib					@@\
	COPY_LIBRARY( lib, dir##/##lib )		@@\
	RANLIB_TOUCH( dir##/##lib )			@@\
	chmod OBJECT_MODE dir##/##lib			@@\
stripped:: dir##/##lib
#endif  strip_library


/* 
** Stripped target is released just by copying
*/
#ifndef strip_copy_target
#define strip_copy_target( src, dir, file, mode )	@@\
dir##/##file: src					@@\
	/bin/rm -f dir##/##file				@@\
	cp src dir##/##file				@@\
	chmod mode dir##/##file				@@\
stripped:: dir##/##file
#endif /* strip_copy_target */


/*
** Stripped target is released by creating a hard link to another. 
*/
#ifndef strip_link_target
#define strip_link_target( src, dir, dest )		@@\
stripped:: $(STRIP_DIR)/##dir##/##dest##		@@\
							@@\
$(STRIP_DIR)/##dir##/##dest##: src			@@\
	/bin/rm -f $(STRIP_DIR)/##dir##/##dest		@@\
	ln src $(STRIP_DIR)/##dir##/##dest		
#endif /* strip_link_target */


/*
** Stripped target is released by creating a symbolic link to another.
*/
#ifndef strip_symlink_target
#define strip_symlink_target( src, dir, dest )	@@\
stripped:: $(STRIP_DIR)/##dir##/##dest##		@@\
							@@\
$(STRIP_DIR)/##dir##/##dest##: src			@@\
	/bin/rm -f $(STRIP_DIR)/##dir##/##dest		@@\
	ln -s src $(STRIP_DIR)/##dir##/##dest
#endif /* strip_symlink_target */



/***********************************************************************
** static targets
**
** These rules are used for creating the statically linked, stripped
** binary distribution for distribution to the world.  Any binary
** will be statically linked, then stripped, then copied into the
** given directory.  Other files should be put in the appropriate
** places for a full binary distribution (e.g. scripts, example files,
** libraries, etc).  All directories need to support a "static" rule. 
***********************************************************************/

/*
** Target to build a statically linked, stripped binary, placed in the
** specified directory.
*/
#ifndef	static_target
#define	static_target( program, objlist, libs, dir )		@@\
dir##/##program: objlist libs					@@\
	$(CPlusPlus) $(STATIC)  $(NON_INST_C_PLUS_FLAGS) -o program##.static objlist libs $(LDFLAGS) $(SITE_LDFLAGS) $(DEMANGLE) @@\
	strip program##.static					@@\
	/bin/rm -f dir##/##program				@@\
	cp program##.static dir##/##program			@@\
	chmod EXECUTABLE_MODE dir##/##program			@@\
clean:: 							@@\
	rm -f program##.static objlist				@@\
static:: dir##/##program
#endif  /* static_target */


/*
** Copy the given library to the specified directory, and run ranlib.
*/
#ifndef static_library
#define static_library( lib, dir )			@@\
dir##/##lib: lib					@@\
	COPY_LIBRARY( lib, dir##/##lib )		@@\
	RANLIB_TOUCH( dir##/##lib )			@@\
	chmod OBJECT_MODE dir##/##lib			@@\
static:: dir##/##lib
#endif  static_library


/* 
** Static target is released just by copying
*/
#ifndef static_copy_target
#define static_copy_target( src, dir, file, mode )	@@\
dir##/##file: src					@@\
	/bin/rm -f dir##/##file				@@\
	cp src dir##/##file				@@\
	chmod mode dir##/##file				@@\
static:: dir##/##file
#endif static_copy_target


/*
** Static target is released by creating a hard link to another. 
*/
#ifndef static_link_target
#define static_link_target( src, dir, dest )		@@\
static:: $(STATIC_DIR)/##dir##/##dest##			@@\
							@@\
$(STATIC_DIR)/##dir##/##dest##: src			@@\
	/bin/rm -f $(STATIC_DIR)/##dir##/##dest		@@\
	ln src $(STATIC_DIR)/##dir##/##dest		
#endif /* static_link_target */


/*
** Static target is released by creating a symbolic link to another.
*/
#ifndef static_symlink_target
#define static_symlink_target( src, dir, dest )	@@\
static:: $(STATIC_DIR)/##dir##/##dest##			@@\
							@@\
$(STATIC_DIR)/##dir##/##dest##: src			@@\
	/bin/rm -f $(STATIC_DIR)/##dir##/##dest		@@\
	ln -s src $(STATIC_DIR)/##dir##/##dest
#endif /* static_symlink_target */


/***********************************************************************
** tarball targets
**
** These rules are used for creating the contrib and release tarballs.
**
** The "both_tarball" is made with the first list of files from the
** regular, main directory, and the second list of contrib files that
** are copied in from the appropriate contrib directory, included in
** the tarball, then removed.
**
***********************************************************************/
#ifndef contrib_tarball
#define contrib_tarball( name, files )		@@\
	full_tarball( name, files, contrib )	@@\
	move_contrib_tarballs( name )
#endif /* contrib_tarball */

#ifndef move_contrib_tarballs
#if HAS_STATIC
#define move_contrib_tarballs( name )			@@\
##name##:: strip_contrib/##name static_contrib/##name	@@\
	mv strip_contrib/##name strip_dir/##name	@@\
	mv static_contrib/##name static_dir/##name
#else /* ! HAS_STATIC */
#define move_contrib_tarballs( name )			@@\
##name##:: strip_contrib/##name				@@\
	mv strip_contrib/##name strip_dir/##name
#endif /* HAS_STATIC */
#endif /* move_contrib_tarballs */

#ifndef release_tarball
#define release_tarball( name, files )	@@\
	full_tarball( name, files, dir )
#endif /* release_tarball */

#ifndef full_tarball
#define full_tarball( name, files, type )		@@\
	strip_full_tarball(  name, files, type )	@@\
	static_full_tarball( name, files, type )
#endif /* full_tarball */

#ifndef strip_full_tarball
#define strip_full_tarball( name, files, type )		@@\
##name##:: strip_##type##/##name			@@\
							@@\
afs_##name##:: strip_##type##/##name			@@\
	cp strip_##type##/##name $(PUBLIC_D_TARGET)	@@\
							@@\
strip_##type##/##name##: stripped			@@\
	/bin/rm -f strip_##type##/##name		@@\
	cd strip_##type##; tar -cvf name files
#endif /* strip_full_tarball */

#ifndef static_full_tarball
#if HAS_STATIC
#define static_full_tarball( name, files, type )	@@\
##name##:: static_##type##/##name			@@\
							@@\
afs_##name##:: static_##type##/##name			@@\
	cp static_##type##/##name $(PUBLIC_S_TARGET)	@@\
							@@\
static_##type##/##name##: static			@@\
	/bin/rm -f static_##type##/##name		@@\
	cd static_##type##; tar -cvf name files
#else 
#define static_full_tarball( name, files, type ) /* NULL MACRO */
#endif /* HAS_STATIC */
#endif /* static_full_tarball */


#ifndef both_tarball
#define both_tarball( name, files, contribfiles )		@@\
	strip_both_tarball(  name, files, contribfiles )	@@\
	static_both_tarball( name, files, contribfiles )
#endif /* both_tarball */

#ifndef strip_both_tarball
#define strip_both_tarball( name, files, contribfiles )		@@\
##name##:: strip_dir/##name					@@\
								@@\
afs_##name##:: strip_dir/##name					@@\
	cp strip_dir/##name $(PUBLIC_D_TARGET)			@@\
								@@\
strip_dir/##name##: stripped					@@\
	perl condor_scripts/make_both_tarball strip##, name##, files##, contribfiles
#endif /* strip_both_tarball */

#ifndef static_both_tarball
#if HAS_STATIC
#define static_both_tarball( name, files, contribfiles )	@@\
##name##:: static_dir/##name					@@\
								@@\
afs_##name##:: static_dir/##name				@@\
	cp static_dir/##name $(PUBLIC_S_TARGET)			@@\
								@@\
static_dir/##name##: static					@@\
	perl condor_scripts/make_both_tarball static##, name##, files##, contribfiles
#else 
#define static_both_tarball( name, files, contribfiles ) /* NULL MACRO */
#endif /* HAS_STATIC */
#endif /* static_both_tarball */


/***********************************************************************
** PureSoftware targets
**
** These rules are used for creating special debugging binaries built
** for either purify, or purecoverage.
***********************************************************************/

#if IS_SUN4X

#define PureCollector concat3(-collector=,CrtLibPath,/ld)

#define	pure_c_plus_target( program, objlist, libs )	@@\
##program: objlist libs					@@\
	purify -g++=yes -collector=PureCollector $(CPlusPlus) $(NON_INST_C_PLUS_FLAGS) -o program objlist libs $(LDFLAGS)	@@\
clean::							@@\
	rm -f program objlist

#define	purecov_c_plus_target( program, objlist, libs )	@@\
##program: objlist libs					@@\
	purecov -g++=yes -collector=PureCollector $(CPlusPlus) $(NON_INST_C_PLUS_FLAGS) -o program objlist libs $(LDFLAGS)						@@\
clean:: 						@@\
	rm -f program objlist


#define	quantify_c_plus_target( program, objlist, libs )	@@\
##program: objlist libs						@@\
	quantify -g++=yes -collector=PureCollector $(CPlusPlus) $(NON_INST_C_PLUS_FLAGS) -o program objlist libs $(LDFLAGS)	                                 @@\
clean::		 						@@\
	rm -f program objlist

#else 

#define	pure_c_plus_target( program, objlist, libs )	/* NULL MACRO */
#define	purecov_c_plus_target( program, objlist, libs )	/* NULL MACRO */
#define	quantify_c_plus_target( program, objlist, libs ) /* NULL MACRO */

#endif	/* IS_SUN4M_SOLARIS251 */


/***********************************************************************
** condor_compile rules
**
** Rules to link programs with the Condor libraries using
** condor_compile.  These are used primarily in the test suites. 
***********************************************************************/

CONDOR_COMPILE = ../../condor_scripts/condor_compile

/*
** Link all three types of binaries
*/
#define LINK( compiler, remotetarg, vanillatarg, standalonetarg, obj ) @@\
all::						@@\
	RLINK( compiler, remotetarg, obj );	@@\
	VLINK( compiler, vanillatarg, obj );		@@\
	SLINK( compiler, standalonetarg, obj );

/*
** Link a program for running remotely
*/
#define RLINK( compiler, remotetarg, obj )	@@\
remotetarg: obj					@@\
	$(CONDOR_COMPILE) $(CONDOR_COMPILE_FLAGS) compiler -o remotetarg obj @@\
clean::						@@\
	rm -f remotetarg obj			@@\
all:: remotetarg


/*
** Link a program standalone (runs outside condor, but will still checkpoint)
*/
#define SLINK( compiler, standalonetarg, obj )		@@\
standalonetarg: obj					@@\
	$(CONDOR_COMPILE) $(CONDOR_COMPILE_FLAGS) $(STAND_ALONE_FLAG) compiler -o standalonetarg obj @@\
							@@\
clean::							@@\
	rm -f standalonetarg obj			@@\
all:: standalonetarg

/*
** Link a program to run normally (no condor at all)
*/
#define VLINK( compiler, vanillatarg, obj )			@@\
vanillatarg: obj fake_ckpt.o					@@\
	compiler -o vanillatarg obj fake_ckpt.o			@@\
								@@\
clean::								@@\
	rm -f vanillatarg obj					@@\
all:: vanillatarg


/***********************************************************************
** Doc++ rules  
***********************************************************************/

/* This can't be called doc++_target b/c Imake doesn't like "+" */
#ifndef html_target
#define html_target( files )					@@\
html: files							@@\
	/bin/rm -rf html					@@\
	/unsup/doc++/bin/doc++ -H -d html -u -g -l -j \		@@\
		-m -f -B ../html/condor_banner.html \		@@\
		files
#endif /* html_target */


/***********************************************************************
** misc rules
**
** Everything else.
***********************************************************************/

/*
** These special object files are created by extracting a
** standard routine from a system library and changing the
** name by conversion to uppercase.
*/
#ifndef uppercase_target
#define uppercase_target( libname, objname, newname, old_string, new_string )	@@\
newname: libname ToUpper						@@\
	cd $(TMP_DIR); AR_EXTRACT( libname, objname );			@@\
	./ToUpper $(TMP_DIR)/##objname newname old_string new_string 	@@\
	rm -f $(TMP_DIR)/##objname
#endif


/*
** Build a file using an awk program
*/
#ifndef awk_target
#define awk_target( targ, input, prog )			@@\
targ:	input prog					@@\
	awk -f prog input > targ			@@\
clean::							@@\
	rm -f targ
#endif


/*
** Import ".o" files from another directory as symbolic links.  Uses
** Make macro "IMPORT_LINKS" which must be initialized to the
** "import_links" shell script in this directory.
*/
#ifndef import
#define import( dir, obj )			@@\
obj:						@@\
	$(IMPORT_LINKS) dir obj			@@\
clean::						@@\
	rm -f obj
#endif /* import */


/*
** Just make a simple directory.
*/
#ifndef simple_dir_target
#define simple_dir_target(dirname)			@@\
##dirname##:						@@\
	mkdir dirname
#endif  simple_dir_target


/*
** Build an object directory with symbolic links back into the
** source directory.  Making it appear as though all the source
** files are in the directory where we want to build the objects
** will simplify the Makefiles.
*/
#ifndef object_dir_target
#define object_dir_target(dir_name)					@@\
## dir_name##:								@@\
	rm -rf dir_name							@@\
	mkdir dir_name							@@\
	cd dir_name##; for file in `ls $(SRC_TREE)/##dir_name##`; \	@@\
		do ln -s $(SRC_TREE)/##dir_name##/$$file .; done;	@@\
	rm -f dir_name##/CVS						@@\
really-clean::								@@\
	rm -rf dir_name
#endif /* object_dir_target */


/*
** Build a skeleton object tree for a particular platform.
*/
#ifndef platform_target
#define platform_target(platform)			@@\
platform.init: platform ALWAYS				@@\
	cp GENERIC/CheckPlatformType.c platform		@@\
	cp Imakefile.platform_skel platform/Imakefile	@@\
	cd platform ; imake IMAKE_FLAGS			@@\
	cd platform ; make directories; make depend	@@\
platform: 						@@\
	mkdir platform
#endif  platform_target

/*
** Check to make sure we are running on the correct kind of machine
** and operating system to make object files for this platform.
*/
#ifndef check_platform_target
#define check_platform_target				@@\
CheckPlatformType:					@@\
	rm -f CheckPlatformType				@@\
	cc $(CFLAGS) -o CheckPlatformType ../GENERIC/CheckPlatformType.c	@@\
	./CheckPlatformType				@@\
	rm -f CheckPlatformType
#endif  check_platform_target


/*
** Build Makefile dependencies for an object tree.
*/
#ifndef depend_target
#define depend_target( src_list )			@@\
depend: ALWAYS						@@\
	$(MKDEPEND) $(CFLAGS) src_list
#endif


/*
** Build a tags file for a source directory.
*/
#ifndef tags_target
#define tags_target( c_files, libdirs )			@@\
tags: ALWAYS						@@\
	condor_ctags c_files -l libdirs			@@\
clean::							@@\
	rm -f tags
#endif 

/*
** Build directory strucuture for a compiler in the test suite.
*/
#ifndef C_COMPILER_TARGET
#define C_COMPILER_TARGET(compiler) 				@@\
all:: compiler							@@\
								@@\
all:: 								@@\
	cd compiler; $(MAKE)					@@\
								@@\
compiler##: 							@@\
	mkdir compiler						@@\
	cd compiler; ln -s ../CImakefile Imakefile		@@\
	cd compiler; imake IMAKE_FLAGS	-I../../../config -DC_COMPILER=##compiler	@@\
								@@\
clean::								@@\
	rm -rf compiler						
#endif

#ifndef CPP_COMPILER_TARGET
#define CPP_COMPILER_TARGET(compiler) 				@@\
all:: compiler							@@\
								@@\
all:: 								@@\
	cd compiler; $(MAKE)					@@\
								@@\
compiler##: 							@@\
	mkdir compiler						@@\
	cd compiler; ln -s ../CPPImakefile Imakefile		@@\
	cd compiler; imake IMAKE_FLAGS -I../../../config -DCPP_COMPILER=##compiler	@@\
								@@\
clean::								@@\
	rm -rf compiler						
#endif

#ifndef F_COMPILER_TARGET
#define F_COMPILER_TARGET(compiler)			@@\
all:: compiler						@@\
							@@\
all::							@@\
	cd compiler; $(MAKE)				@@\
							@@\
compiler##:						@@\
	mkdir compiler					@@\
	cd compiler; ln -s ../FImakefile Imakefile	@@\
	cd compiler; imake IMAKE_FLAGS -I../../../config -DF_COMPILER=##compiler @@\
							@@\
clean::							@@\
	rm -rf compiler					
#endif
