/*
** Set up some shared, common rules and defininitions
*/
.SUFFIXES: .C

.C.o:
	$(CPlusPlus) $(C_PLUS_FLAGS) -c $<

.f.o:
	$(Fortran) $(FFLAGS) -c $<

#define SET_GID_MODE		02775
#define EXECUTABLE_MODE		0755
#define OBJECT_MODE		0644
#define TEXT_MODE		OBJECT_MODE

#if defined(Demangler)
DEMANGLE = 2>&1 | Demangler
#endif

#define junkdir(daemon)concat3(junk,_,daemon)
#define soapname(daemon)concat(soap_,daemon)
#define gsoapname(daemon)concat(gsoap_,daemon)

/*
** Set up to make all the objects in a particular directory.
*/
#ifndef object_target
#define object_target(obj_name)					@@\
##obj_name##: condor_##obj_name					@@\
	cd condor_##obj_name; make $(SMP_FLAGS)			@@\
release:: condor_##obj_name					@@\
	cd condor_##obj_name; make release			@@\
stripped:: condor_##obj_name					@@\
	cd condor_##obj_name; make stripped			@@\
static:: condor_##obj_name					@@\
	cd condor_##obj_name; make static			@@\
depend:: condor_##obj_name					@@\
	cd condor_##obj_name; make depend			@@\
clean:: condor_##obj_name					@@\
	cd condor_##obj_name; make clean			@@\
docs:: condor_##obj_name					@@\
	cd condor_##obj_name; make html				@@\
makefiles:: condor_##obj_name condor_##obj_name##/Makefile	@@\
condor_##obj_name##/Makefile:					@@\
	cd condor_##obj_name ; ../condor_imake 	@@\
object_dir_target(condor_##obj_name)		
#endif /* object_target */

/*
** List everything which should be built in this object tree.
*/
#define all_target(targetlist)				@@\
all:: targetlist

/*
** Just build a given thing from a given directory.
*/
#define single_target(dir, target)			@@\
##dir##/##target##: dir					@@\
	cd dir; make $(SMP_FLAGS) target



/***********************************************************************
** building targets
**
** These rules are used for building various aspects of Condor.
** Primarily, binaries and libraries.  Binaries be dymanically
** linked, include debugging info, and not be stripped.
***********************************************************************/

/*
** Build a library from .o files.
*/
#ifndef library_target
#define library_target( libname, objlist )		@@\
libname: objlist					@@\
	rm -f libname					@@\
	AR_REPLACE( libname, objlist )			@@\
clean::							@@\
	rm -f libname objlist
#endif /* library_target */


/*
** Build a C program from .o files and libraries.
*/
#if NEEDS_PRELINKER

/* under AIX, we need a special prelink phase which links the GNU CC generated
	.o files with GNU ld, but then uses the vendor linker the compiler should
	have been installed to use to link the prelinked object and the system
	libraries. */
#ifndef program_target
#define	program_target( program, objlist, libs )		@@\
program: objlist						@@\
	$(PRELINK_C) $(PRELINK_C_FLAGS) -o __prelink__.o objlist libs @@\
	$(C_LINK) $(CFLAGS) -o program __prelink__.o $(ALL_LDFLAGS)	@@\
	rm -f __prelink__.o @@\
clean::								@@\
	rm -f program objlist
#endif /* program_target */

#else

/* everyone else gets a normal link rule */
#ifndef program_target
#define	program_target( program, objlist, libs )		@@\
program: objlist						@@\
	$(C_LINK) $(CFLAGS) -o program objlist libs $(ALL_LDFLAGS)	@@\
clean::								@@\
	rm -f program objlist
#endif /* program_target */

#endif

/*
** Build a C program from .o files and libraries supplying the compile time
** and link time flags. For building utilites with special flags.
*/
#if NEEDS_PRELINKER

#ifndef program_target_complex
#define	program_target_complex( program, objlist, comflags, linkflags, libs )		@@\
program: objlist						@@\
	$(PRELINK_C) $(PRELINK_C_FLAGS) comflags -o __prelink__.o \
		objlist libs @@\
	$(C_LINK) comflags -o program __prelink__.o linkflags	@@\
	rm -f __prelink__.o @@\
clean::								@@\
	rm -f program objlist
#endif  /* program_target_complex */

#else

#ifndef program_target_complex
#define	program_target_complex( program, objlist, comflags, linkflags, libs )		@@\
program: objlist						@@\
	$(C_LINK) comflags -o program objlist libs linkflags	@@\
clean::								@@\
	rm -f program objlist
#endif  /* program_target_complex */

#endif


/*
** Build a C++ program from .o files and libraries.
*/
#if NEEDS_PRELINKER

#ifndef c_plus_target
#define	c_plus_target( program, objlist, libs )			@@\
program: objlist						@@\
	$(PRELINK_CPP) $(PRELINK_CPP_FLAGS) -o __prelink__.o objlist libs @@\
	$(CC_LINK) $(C_PLUS_FLAGS) -o program __prelink__.o \
		$(ALL_LDFLAGS) $(DEMANGLE)			@@\
	rm -f __prelink__.o @@\
clean::								@@\
	rm -f program objlist
#endif  /* c_plus_target */

#else

#ifndef c_plus_target
#define	c_plus_target( program, objlist, libs )			@@\
program: objlist						@@\
	$(CC_LINK) $(C_PLUS_FLAGS) -o program objlist libs \
		$(ALL_LDFLAGS) $(DEMANGLE)			@@\
clean::								@@\
	rm -f program objlist
#endif  /* c_plus_target */

#endif

/*
** Build a C++ program from .o files and libraries supplying the compile and
** link flags. For building utility programs with special flags.
*/
#if NEEDS_PRELINKER

#ifndef c_plus_target_complex
#define	c_plus_target_complex( program, objlist, comflags, linkflags, libs )	@@\
program: objlist						@@\
	$(PRELINK_CPP) $(PRELINK_CPP_FLAGS) comflags -o __prelink__.o \
		objlist libs @@\
	$(CC_LINK) comflags -o program __prelink__.o linkflags $(DEMANGLE)	@@\
	rm -f __prelink__.o @@\
clean::								@@\
	rm -f program objlist
#endif  /* c_plus_target_complex */

#else

#ifndef c_plus_target_complex
#define	c_plus_target_complex( program, objlist, comflags, linkflags, libs )	@@\
program: objlist						@@\
	$(CC_LINK) comflags -o program objlist libs linkflags $(DEMANGLE)	@@\
clean::								@@\
	rm -f program objlist
#endif  /* c_plus_target_complex */

#endif

/*
** Build a template instantiation object
*/
#ifndef template_inst
#define template_inst( srcfile, objfile )               @@\
objfile: srcfile                                        @@\
	 $(CPlusPlus) $(INST_C_PLUS_FLAGS) -c srcfile -o objfile
#endif /* template_inst_obj */

/*
** Build a Java class from a .java file.
**
*/

#ifndef java_target
#define java_target( classfile, sourcefile, cpath )        @@\
classfile: sourcefile                                      @@\
	$(JAVAC) $(JAVACFLAGS) -classpath cpath sourcefile @@\
clean::                                                    @@\
	rm -f classfile
#endif

/*
** Build a JAR file from several .java files.
**
*/

#ifndef jar_target
#define jar_target( jarfile, sourcefiles, classroot ) @@\
jarfile: sourcefiles                                  @@\
	$(JAVAC) $(JAVACFLAGS) -d . sourcefiles       @@\
	$(JAR) $(JARFLAGS) cf $@ classroot            @@\
clean::                                               @@\
	rm -rf jarfile classroot
#endif

/***********************************************************************
** Auto generated file rules
**
** These rules are for building autogenerated files by various
** mechanisms.
***********************************************************************/

/* given the name of the daemon, produce a list of object files for the
	generated sources from soapcpp2 
*/
#define soapobjs(daemon) @@\
SOAP_OBJS = concat(soapname(daemon),C).o concat(soapname(daemon),Server).o \
	concat(soapname(daemon),Stub).o @@\
SOAP_SRC = concat(soapname(daemon),C).C concat(soapname(daemon),Server).C \
	concat(soapname(daemon),H).h concat(soapname(daemon),Stub).h

/* given a daemon name, and a service, use the soap compiler to produce a 
	set of interface files in a temporary directory and then copy the files
	to the current working directory.  
*/
#define gen_soapfiles(daemon,service) @@\
soapfiles:: gsoapname(daemon).h @@\
	/bin/rm -rf junkdir(daemon) @@\
	/bin/mkdir junkdir(daemon) @@\
	$(SOAPCPP2) -I ../condor_daemon_core.V6 -d junkdir(daemon) -p soapname(daemon) gsoapname(daemon).h @@\
	cp junkdir(daemon)/concat(soapname(daemon),C).cpp concat(soapname(daemon),C).C @@\
	cp junkdir(daemon)/concat(soapname(daemon),Server).cpp concat(soapname(daemon),Server).C @@\
	cp junkdir(daemon)/service.nsmap . @@\
	cp junkdir(daemon)/concat(soapname(daemon),H).h . @@\
	cp junkdir(daemon)/concat(soapname(daemon),Stub).h . @@\
	cp junkdir(daemon)/service.wsdl . @@\
	/bin/rm -rf junkdir(daemon) @@\
	touch soapfiles @@\
clean:: @@\
	/bin/rm -f service.nsmap concat(soapname(daemon),H).h concat(soapname(daemon),Stub).h service.wsdl concat(soapname(daemon),C).C concat(soapname(daemon),Server).C soapfiles @@\
XCOMM Specifically add a dependancy from the generated .C files to the @@\
XCOMM .o files. Otherwise, the suffix rules do not get the dependencies @@\
XCOMM right. @@\ 
$(SOAP_OBJS): $(SOAP_SRC) @@\
$(SOAP_SRC): soapfiles

/***********************************************************************
** release targets
**
** These rules are used for copying files that have already been built
** into the release_dir, which is unstripped, for use at our pool.
** All directories need to support a "release" rule.
***********************************************************************/

/*
** Copy the given file to the specified directory, with the given mode.
*/
#ifndef release_target
#define release_target( file, dir, mode )		@@\
$(RELEASE_DIR)/##dir##/##file: file			@@\
	/bin/rm -f $(RELEASE_DIR)/##dir##/##file	@@\
	cp file $(RELEASE_DIR)/##dir			@@\
	chmod mode $(RELEASE_DIR)/##dir##/##file	@@\
release:: $(RELEASE_DIR)/##dir##/##file
#endif /* release_target */

/*
** Copy the given library to the specified directory, and run ranlib.
*/
#ifndef release_library
#define release_library( lib, dir ) 			@@\
$(RELEASE_DIR)/##dir##/##lib: lib					@@\
	COPY_LIBRARY( lib, $(RELEASE_DIR)/##dir##/##lib )		@@\
	RANLIB_TOUCH( $(RELEASE_DIR)/##dir##/##lib )			@@\
release:: $(RELEASE_DIR)/##dir##/##lib
#endif  /* release_library */


/*
** Target is released by creating a symbolic link to another.
*/
#ifndef release_symlink_target
#define release_symlink_target( src, dir, dest )	@@\
release:: $(RELEASE_DIR)/##dir##/##dest			@@\
							@@\
$(RELEASE_DIR)/##dir##/##dest##: 			@@\
	/bin/rm -f $(RELEASE_DIR)/##dir##/##dest	@@\
	ln -s src $(RELEASE_DIR)/##dir##/##dest			
#endif /* release_symlink_target */

/*
** Just create a symlink. We need this for the test suite 
*/
#ifndef release_plain_symlink_target
#define release_plain_symlink_target( src, dest )		@@\
release:: dest					@@\
dest: 						@@\
	/bin/rm -f dest				@@\
	ln -s src dest				@@\
clean::						@@\
	/bin/rm -f dest
#endif /* release_plain_symlink_target */

/*
** Target is released by creating a hard link to another.
*/
#ifndef release_link_target
#define release_link_target( src, dir, dest )		@@\
release:: $(RELEASE_DIR)/##dir##/##dest##		@@\
							@@\
$(RELEASE_DIR)/##dir##/##dest##: src			@@\
	/bin/rm -f $(RELEASE_DIR)/##dir##/##dest	@@\
	ln src $(RELEASE_DIR)/##dir##/##dest		
#endif /* release_link_target */


/*
** Target is released by copying
*/
#ifndef release_copy_target
#define release_copy_target( src, dir, dest, mode )	@@\
release:: $(RELEASE_DIR)/##dir##/##dest##		@@\
							@@\
$(RELEASE_DIR)/##dir##/##dest##: src			@@\
	/bin/rm -f $(RELEASE_DIR)/##dir##/##dest	@@\
	cp src $(RELEASE_DIR)/##dir##/##dest		@@\
	chmod mode $(RELEASE_DIR)/##dir##/##dest
#endif /* release_copy_target */



/*
** Target is released by recursive copying
*/
#ifndef release_recursive_copy_target
#define release_recursive_copy_target( src, dest )	@@\
release:: $(RELEASE_DIR)/##dest	       			@@\
							@@\
$(RELEASE_DIR)/##dest##: src				@@\
	/bin/rm -rf $(RELEASE_DIR)/##dest		@@\
	$(CP_CMD) src $(RELEASE_DIR)/##dest
#endif /* release_recursive_copy_target */


/***********************************************************************
** strip targets
**
** These rules are used for copying files that have already been built
** into the strip_dir, then stripping them if they're binaries, for
** distribution to the world.  All directories need to support a
** "stripped" rule. 
***********************************************************************/

/*
** Copy a given file to the specified directory, with the given mode,
** and strip the binary.
*/
#ifndef strip_target
#define strip_target( file, dir, mode )			@@\
$(STRIP_DIR)/##dir##/##file##: file			@@\
	/bin/rm -f $(STRIP_DIR)/##dir##/##file		@@\
	cp file $(STRIP_DIR)/##dir			@@\
	$(STRIP) $(STRIP_DIR)/##dir##/##file		@@\
	chmod mode $(STRIP_DIR)/##dir##/##file		@@\
stripped:: $(STRIP_DIR)/##dir##/##file
#endif  /* strip_target */


/*
** Copy the given library to the specified directory, and run ranlib.
*/
#ifndef strip_library
#define strip_library( lib, dir )			@@\
$(STRIP_DIR)/##dir##/##lib: lib				@@\
	COPY_LIBRARY( lib, $(STRIP_DIR)/##dir##/##lib )	@@\
	RANLIB_TOUCH( $(STRIP_DIR)/##dir##/##lib )	@@\
	chmod OBJECT_MODE $(STRIP_DIR)/##dir##/##lib	@@\
stripped:: $(STRIP_DIR)/##dir##/##lib
#endif  /* strip_library */


/* 
** Stripped target is released just by copying
*/
#ifndef strip_copy_target
#define strip_copy_target( src, dir, file, mode )	@@\
$(STRIP_DIR)/##dir##/##file: src			@@\
	/bin/rm -f $(STRIP_DIR)/##dir##/##file		@@\
	cp src $(STRIP_DIR)/##dir##/##file		@@\
	chmod mode $(STRIP_DIR)/##dir##/##file		@@\
stripped:: $(STRIP_DIR)/##dir##/##file
#endif /* strip_copy_target */


/*
** Stripped target is released by recursive copying
*/
#ifndef strip_recursive_copy_target
#define strip_recursive_copy_target( src, dest )	@@\
stripped:: $(STRIP_DIR)/##dest	     			@@\
							@@\
$(STRIP_DIR)/##dest##: src				@@\
	/bin/rm -rf $(STRIP_DIR)/##dest			@@\
	$(CP_CMD) src $(STRIP_DIR)/##dest
#endif /* strip_recursive_copy_target */


/*
** Stripped target is released by creating a hard link to another. 
*/
#ifndef strip_link_target
#define strip_link_target( src, dir, dest )		@@\
stripped:: $(STRIP_DIR)/##dir##/##dest##		@@\
							@@\
$(STRIP_DIR)/##dir##/##dest##: src			@@\
	/bin/rm -f $(STRIP_DIR)/##dir##/##dest		@@\
	ln src $(STRIP_DIR)/##dir##/##dest		
#endif /* strip_link_target */


/*
** Stripped target is released by creating a symbolic link to another.
*/
#ifndef strip_symlink_target
#define strip_symlink_target( src, dir, dest )	@@\
stripped:: $(STRIP_DIR)/##dir##/##dest##		@@\
							@@\
$(STRIP_DIR)/##dir##/##dest##: 			@@\
	/bin/rm -f $(STRIP_DIR)/##dir##/##dest		@@\
	ln -s src $(STRIP_DIR)/##dir##/##dest
#endif /* strip_symlink_target */



/***********************************************************************
** static targets
**
** These rules are used for creating the statically linked, stripped
** binary distribution for distribution to the world.  Any binary
** will be statically linked, then stripped, then copied into the
** given directory.  Other files should be put in the appropriate
** places for a full binary distribution (e.g. scripts, example files,
** libraries, etc).  All directories need to support a "static" rule. 
***********************************************************************/

/*
** Target to build a statically linked, stripped binary, placed in the
** specified directory.
*/
#if NEEDS_PRELINKER 

#ifndef	static_target
#define	static_target( program, objlist, libs, dir )		@@\
dir##/##program: program##.static				@@\
	/bin/rm -f dir##/##program				@@\
	cp program##.static dir##/##program			@@\
	chmod EXECUTABLE_MODE dir##/##program			@@\
	$(STRIP) dir##/##program				@@\
program##.static: objlist					@@\
	$(PRELINK_CPP) $(PRELINK_CPP_FLAGS) -o __prelink__.o objlist libs @@\
	$(CC_LINK) $(STATIC)  $(C_PLUS_FLAGS) -o program##.static __prelink__.o $(ALL_LDFLAGS) $(DEMANGLE) @@\
	rm -f __prelink__.o @@\
clean:: 							@@\
	rm -f program##.static objlist				@@\
static:: dir##/##program
#endif  /* static_target */

#else

#ifndef	static_target
#define	static_target( program, objlist, libs, dir )		@@\
dir##/##program: program##.static				@@\
	/bin/rm -f dir##/##program				@@\
	cp program##.static dir##/##program			@@\
	chmod EXECUTABLE_MODE dir##/##program			@@\
	$(STRIP) dir##/##program				@@\
program##.static: objlist					@@\
	$(CC_LINK) $(STATIC)  $(C_PLUS_FLAGS) -o program##.static objlist libs $(ALL_LDFLAGS) $(DEMANGLE) @@\
clean:: 							@@\
	rm -f program##.static objlist				@@\
static:: dir##/##program
#endif  /* static_target */

#endif


/*
** Copy the given library to the specified directory, and run ranlib.
*/
#ifndef static_library
#define static_library( lib, dir )			@@\
$(STATIC_DIR)/##dir##/##lib: lib			@@\
	COPY_LIBRARY( lib, $(STATIC_DIR)/##dir##/##lib ) @@\
	RANLIB_TOUCH( $(STATIC_DIR)/##dir##/##lib )	@@\
	chmod OBJECT_MODE $(STATIC_DIR)/##dir##/##lib	@@\
static:: $(STATIC_DIR)/##dir##/##lib
#endif  /* static_library */


/* 
** Static target is released just by copying
*/
#ifndef static_copy_target
#define static_copy_target( src, dir, file, mode )	@@\
$(STATIC_DIR)/##dir##/##file: src			@@\
	/bin/rm -f $(STATIC_DIR)/##dir##/##file		@@\
	cp src $(STATIC_DIR)/##dir##/##file		@@\
	chmod mode $(STATIC_DIR)/##dir##/##file		@@\
static:: $(STATIC_DIR)/##dir##/##file
#endif /* static_copy_target */


/*
** Static target is released by recursive copying
*/
#ifndef static_recursive_copy_target
#define static_recursive_copy_target( src, dest )	@@\
static:: $(STATIC_DIR)/##dest	      			@@\
							@@\
$(STATIC_DIR)/##dest##: src				@@\
	/bin/rm -rf $(STATIC_DIR)/##dest		@@\
	$(CP_CMD) src $(STATIC_DIR)/##dest
#endif /* static_recursive_copy_target */


/*
** Static target is released by creating a hard link to another. 
*/
#ifndef static_link_target
#define static_link_target( src, dir, dest )		@@\
static:: $(STATIC_DIR)/##dir##/##dest##			@@\
							@@\
$(STATIC_DIR)/##dir##/##dest##: src			@@\
	/bin/rm -f $(STATIC_DIR)/##dir##/##dest		@@\
	ln src $(STATIC_DIR)/##dir##/##dest		
#endif /* static_link_target */


/*
** Static target is released by creating a symbolic link to another.
*/
#ifndef static_symlink_target
#define static_symlink_target( src, dir, dest )	@@\
static:: $(STATIC_DIR)/##dir##/##dest##			@@\
							@@\
$(STATIC_DIR)/##dir##/##dest##: 			@@\
	/bin/rm -f $(STATIC_DIR)/##dir##/##dest		@@\
	ln -s src $(STATIC_DIR)/##dir##/##dest
#endif /* static_symlink_target */


/***********************************************************************
** Misc link-related targets
**
** These rules are used for creating hard and soft links for various
** make targets.
**
***********************************************************************/


/*
** The all* targets make the links when you do a "make all".  They
** only take two args, a src and a dest, since they assume you want
** the links in the current directory.
*/
#ifndef all_link_target
#define all_link_target( src, dest )		@@\
all:: dest					@@\
dest: src					@@\
	/bin/rm -f dest				@@\
	ln src dest				@@\
clean::						@@\
	/bin/rm -f dest
#endif /* all_link_target */

#ifndef all_symlink_target
#define all_symlink_target( src, dest )		@@\
all:: dest					@@\
dest: src					@@\
	/bin/rm -f dest				@@\
	ln -s src dest				@@\
clean::						@@\
	/bin/rm -f dest
#endif /* all_symlink_target */



/***********************************************************************
** tarball targets
**
** These rules are used for creating the contrib and release tarballs.
**
** The "both_tarball" is made with the first list of files from the
** regular, main directory, and the second list of contrib files that
** are copied in from the appropriate contrib directory, included in
** the tarball, then removed.
**
***********************************************************************/
#ifndef contrib_tarball
#define contrib_tarball( name, files )		@@\
	full_tarball( name, files, contrib )	@@\
	move_contrib_tarballs( name )
#endif /* contrib_tarball */

#ifndef move_contrib_tarballs
#if HAS_STATIC
#define move_contrib_tarballs( name )			@@\
##name##:: strip_contrib/##name static_contrib/##name	@@\
	mv strip_contrib/##name strip_dir/##name	@@\
	mv static_contrib/##name static_dir/##name
#else /* ! HAS_STATIC */
#define move_contrib_tarballs( name )			@@\
##name##:: strip_contrib/##name				@@\
	mv strip_contrib/##name strip_dir/##name
#endif /* HAS_STATIC */
#endif /* move_contrib_tarballs */

#ifndef release_tarball
#define release_tarball( name, files )	@@\
	full_tarball( name, files, dir )
#endif /* release_tarball */

#ifndef full_tarball
#define full_tarball( name, files, type )		@@\
	strip_full_tarball(  name, files, type )	@@\
	static_full_tarball( name, files, type )
#endif /* full_tarball */

#ifndef strip_full_tarball
#define strip_full_tarball( name, files, type )		@@\
##name##:: strip_##type##/##name			@@\
							@@\
strip_##type##/##name##: stripped			@@\
	/bin/rm -f strip_##type##/##name		@@\
	cd strip_##type##; $(TAR_CMD) -cvf name files
#endif /* strip_full_tarball */

#ifndef static_full_tarball
#if HAS_STATIC
#define static_full_tarball( name, files, type )	@@\
##name##:: static_##type##/##name			@@\
							@@\
static_##type##/##name##: static			@@\
	/bin/rm -f static_##type##/##name		@@\
	cd static_##type##; $(TAR_CMD) -cvf name files
#else 
#define static_full_tarball( name, files, type ) /* NULL MACRO */
#endif /* HAS_STATIC */
#endif /* static_full_tarball */


#ifndef both_tarball
#define both_tarball( name, files, contribfiles )		@@\
	strip_both_tarball(  name, files, contribfiles )	@@\
	static_both_tarball( name, files, contribfiles )
#endif /* both_tarball */

#ifndef strip_both_tarball
#define strip_both_tarball( name, files, contribfiles )		@@\
##name##:: strip_dir/##name					@@\
								@@\
strip_dir/##name##: stripped					@@\
	perl condor_scripts/make_both_tarball -cmd "$(TAR_CMD)" strip##, name##, files##, contribfiles
#endif /* strip_both_tarball */

#ifndef static_both_tarball
#if HAS_STATIC
#define static_both_tarball( name, files, contribfiles )	@@\
##name##:: static_dir/##name					@@\
								@@\
static_dir/##name##: static					@@\
	perl condor_scripts/make_both_tarball -cmd "$(TAR_CMD)" static##, name##, files##, contribfiles
#else 
#define static_both_tarball( name, files, contribfiles ) /* NULL MACRO */
#endif /* HAS_STATIC */
#endif /* static_both_tarball */


/***********************************************************************
** PureSoftware targets
**
** These rules are used for creating special debugging binaries built
** for either purify, purecoverage, or both.
***********************************************************************/

#if HAS_PURIFY

#define	pure_c_plus_target( program, objlist, libs )	@@\
##program: objlist					@@\
	purify -g++=yes -chain-length=50 -cache-dir=$(PURE_CACHE_DIR) purecov -g++=yes $(CC_LINK) $(C_PLUS_FLAGS) -o program objlist libs $(PURIFY_LDFLAGS)	@@\
clean::							@@\
	rm -f program objlist

#define	purify_c_plus_target( program, objlist, libs )	@@\
##program: objlist					@@\
	purify -g++=yes -chain-length=50 PureCollector $(CC_LINK) $(C_PLUS_FLAGS) -o program objlist libs $(PURIFY_LDFLAGS)	@@\
clean::							@@\
	rm -f program objlist

#define	purecov_c_plus_target( program, objlist, libs )	@@\
##program: objlist					@@\
	purecov -g++=yes -cache-dir=$(PURE_CACHE_DIR) $(CC_LINK) $(C_PLUS_FLAGS) -o program objlist libs $(PURIFY_LDFLAGS)	@@\
clean::							@@\
	rm -f program objlist

#define	quantify_c_plus_target( program, objlist, libs )	@@\
##program: objlist						@@\
	quantify -g++=yes -cache-dir=$(PURE_CACHE_DIR) $(CC_LINK) $(C_PLUS_FLAGS) -o program objlist libs $(PURIFY_LDFLAGS)     @@\
clean::							@@\
	rm -f program objlist

#define	pure_target( dir, program )				@@\
$(PURE_DIR)/##program: $(PURE_DIR) dir##/##program		@@\
	cp dir##/##program $(PURE_DIR)/##program		@@\
dir##/##program: dir						@@\
	cd dir; make program					@@\
pure:: $(PURE_DIR)/##program

#else 

#define	pure_target( dir, program )			/* NULL MACRO */
#define	pure_c_plus_target( program, objlist, libs )	/* NULL MACRO */
#define	purify_c_plus_target( program, objlist, libs )	/* NULL MACRO */
#define	purecov_c_plus_target( program, objlist, libs )	/* NULL MACRO */
#define	quantify_c_plus_target( program, objlist, libs ) /* NULL MACRO */

#endif	/* HAS_PURIFY */


/***********************************************************************
** condor_compile rules
**
** Rules to link programs with the Condor libraries using
** condor_compile.  These are used primarily in the test suites. 
***********************************************************************/

CONDOR_COMPILE = ../../condor_scripts/condor_compile
CONDOR_ARCH_LINK = perl ../../condor_scripts/condor_arch_link

/*
** Link all three types of binaries
*/
#define LINK( compiler, remotetarg, vanillatarg, obj )	@@\
RLINK( compiler, remotetarg, obj );			@@\
VLINK( compiler, vanillatarg, obj );

/*
** Link a program for running remotely
*/
#if IS_CLIPPED
#define RLINK( compiler, remotetarg, obj )	/* */
#else
#define RLINK( compiler, remotetarg, obj )	@@\
remotetarg: obj					@@\
	$(CONDOR_COMPILE) $(CONDOR_COMPILE_FLAGS) compiler -o remotetarg obj $(TEST_LDFLAGS) @@\
	$(CONDOR_ARCH_LINK) remotetarg		@@\
clean::						@@\
	rm -f remotetarg obj			@@\
all:: remotetarg
#endif


/*
** Link a program to run normally (no condor at all)
*/
#define VLINK( compiler, vanillatarg, obj )			@@\
vanillatarg: obj fake_ckpt.o					@@\
	compiler -o vanillatarg obj fake_ckpt.o	$(TEST_LDFLAGS)	@@\
								@@\
clean::								@@\
	rm -f vanillatarg obj					@@\
all:: vanillatarg


/***********************************************************************
** test suite rules
**
** Rules to build, submit, and verify the test suite
***********************************************************************/


/*
** Make directory and Makefile for a compiler in the test suite.
*/

#define C_COMPILER_TARGET(compiledir, compiler, flags_macro_name) @@\
all:: compiledir compiledir##/Makefile				@@\
	cd compiledir; $(MAKE)					@@\
								@@\
compiledir##: 							@@\
	mkdir compiledir					@@\
								@@\
compiledir##/Imakefile:	CImakefile				@@\
	cd compiledir; /bin/rm -f Imakefile			@@\
	cd compiledir; ln -s ../CImakefile Imakefile		@@\
								@@\
compiledir##/Makefile: compiledir compiledir##/Imakefile	@@\
	cd compiledir; ../../condor_imake -I../../../config \	@@\
	   -DC_COMPILER=##compiler \				@@\
	   -DFLAGS_MACRO_NAME=##flags_macro_name		@@\
								@@\
clean::								@@\
	rm -rf compiledir						


#define CPP_COMPILER_TARGET(compiledir, compiler, flags_macro_name)	@@\
all:: compiledir compiledir##/Makefile				@@\
	cd compiledir; $(MAKE)					@@\
								@@\
compiledir##: 							@@\
	mkdir compiledir					@@\
								@@\
compiledir##/Imakefile: CPPImakefile				@@\
	cd compiledir; /bin/rm -f Imakefile			@@\
	cd compiledir; ln -s ../CPPImakefile Imakefile		@@\
								@@\
compiledir##/Makefile: compiledir compiledir##/Imakefile	@@\
	cd compiledir; ../../condor_imake -I../../../config \	@@\
	   -DCPP_COMPILER=##compiler \				@@\
	   -DFLAGS_MACRO_NAME=##flags_macro_name		@@\
								@@\
clean::								@@\
	rm -rf compiledir						


#define F_COMPILER_TARGET(compiledir, compiler, flags_macro_name, has_recursion) @@\
all:: compiledir compiledir##/Makefile				@@\
	cd compiledir; $(MAKE)					@@\
								@@\
compiledir##:							@@\
	mkdir compiledir					@@\
								@@\
compiledir##/Imakefile: FImakefile				@@\
	cd compiledir; /bin/rm -f Imakefile			@@\
	cd compiledir; ln -s ../FImakefile Imakefile		@@\
								@@\
compiledir##/Makefile: compiledir compiledir##/Imakefile	@@\
	cd compiledir; ../../condor_imake -I../../../config \	@@\
		-DFORTRAN_HAS_RECURSION=##has_recursion \	@@\
		-DF_COMPILER=##compiler	\			@@\
		-DFLAGS_MACRO_NAME=##flags_macro_name		@@\
								@@\
clean::								@@\
	rm -rf compiledir					


/*
** Rule for building and linking a given test program
*/
#define BUILD( cmplr, name, ext )		@@\
BUILD_FILES( name, ext )			@@\
RLINK( cmplr, name##.remote, name##.o )		@@\
VLINK( cmplr, name##.vanilla, name##.o )

#define BUILD_EXTRA( cmplr, name, ext, obj)	@@\
BUILD_FILES( name, ext )			@@\
RLINK( cmplr, name##.remote, obj name##.o)	@@\
VLINK( cmplr, name##.vanilla, obj name##.o)


#define BUILD_SPECIFIC_VANILLA(compiler, progname, objfiles, cmdfile, runfile, ext) @@\
BUILD_FILES_SPECIFIC(progname, cmdfile, runfile, ext) @@\
VLINK(compiler, progname##.vanilla, objfiles)

#define BUILD_SPECIFIC_STANDARD(compiler, progname, objfiles, cmdfile, runfile, ext) @@\
BUILD_FILES_SPECIFIC(progname, cmdfile, runfile, ext) @@\
RLINK(compiler, progname##.remote, objfiles)

#define RBUILD( cmplr, name, ext )		@@\
BUILD_FILES( name, ext )			@@\
RLINK( cmplr, name##.remote, name##.o )

#define BUILD_FILES( name, ext )		@@\
all:: name##.##ext name##.cmd name##.run	@@\
name##.##ext##:					@@\
	ln -s ../##name##.##ext .		@@\
name##.cmd:					@@\
	ln -s ../##name##.cmd .			@@\
name##.run:					@@\
	ln -s ../##name##.run .			@@\
clean::						@@\
	rm -f name##.##ext name##.cmd name##.run

#define BUILD_FILES_SPECIFIC( progname, cmdfile, runfile, ext )		@@\
all:: progname##.##ext cmdfile##.cmd runfile##.run	@@\
progname##.##ext##:					@@\
	ln -s ../##progname##.##ext .		@@\
cmdfile##.cmd:					@@\
	ln -s ../##cmdfile##.cmd .			@@\
runfile##.run:					@@\
	ln -s ../##runfile##.run .			@@\
clean::						@@\
	rm -f progname##.##ext cmdfile##.cmd runfile##.run

/***********************************************************************
** Doc++ rules  
***********************************************************************/

/* This can't be called doc++_target b/c Imake doesn't like "+" */
#ifndef html_target
#define html_target( files )					@@\
html: files							@@\
	/bin/rm -rf html					@@\
	DocCompiler -H -d html -u -g -l -j -p       \           @@\
		-m -f -B ../html/condor_banner.html \		@@\
		files
#endif /* html_target */

/***********************************************************************
** misc rules
**
** Everything else.
***********************************************************************/

/*

** These macros are used to convert a string into a Makefile variable
** reference, by "dollar-paren-ifying" it.  We need to do this with
** two macros like this to get around weirdness caused by the
** pre-processor not doing the proper substitutions all at once.  See
** the comment in src/condor_c++_util/condor_version.C for more
** details.  -Derek Wright <wright@cs.wisc.edu> 1/25/00
*/ 
#define x_dollar_paren(a) $(##a##)
#define dollar_paren(a) x_dollar_paren(a)


/*
** These special object files are created by extracting a
** standard routine from a system library and changing the
** name by conversion to uppercase.
*/
#ifndef uppercase_target
#define uppercase_target( libname, objname, newname, old_string, new_string )	@@\
newname: libname ToUpper						@@\
	cd $(TMP_DIR); AR_EXTRACT( libname, objname );			@@\
	./ToUpper $(TMP_DIR)/##objname newname old_string new_string 	@@\
	rm -f $(TMP_DIR)/##objname
#endif


#ifndef obj_extract
#define obj_extract( libname, objname )			@@\
objname: libname					@@\
	AR_EXTRACT( libname, objname );			@@\
clean:: 						@@\
	rm -f objname
#endif


/*
** Build a file using an awk program
*/
#ifndef awk_target
#define awk_target( targ, input, prog )			@@\
targ:	input prog					@@\
	awk -f prog input > targ			@@\
clean::							@@\
	rm -f targ
#endif


/*
** Import ".o" files from another directory as symbolic links.  Uses
** Make macro "IMPORT_LINKS" which must be initialized to the
** "import_links" shell script in this directory.
*/
#ifndef import
#define import( dir, obj )			@@\
obj:						@@\
	$(IMPORT_LINKS) dir obj			@@\
clean::						@@\
	rm -f obj
#endif /* import */


/*
** Just make a simple directory.
*/
#ifndef simple_dir_target
#define simple_dir_target(dirname)			@@\
##dirname##:						@@\
	mkdir dirname
#endif  /* simple_dir_target */


/*
** Build an object directory with symbolic links back into the
** source directory.  Making it appear as though all the source
** files are in the directory where we want to build the objects
** will simplify the Makefiles.
** The really-clean rule is for blowing away a whole build workspace
** and starting over from scratch.  However, since that's totally
** overkill and dangerous for a source workspace, if we see a "CVS"
** directory, we print a message and exit.  Notice that we use "@if"
** to tell make to pass this directly to the shell.  That way, it
** doesn't echo this test for every directory, but instead just prints
** the error and bails out if it finds the directory.
*/

#ifndef object_dir_target
#define object_dir_target(dir_name)					@@\
##dir_name##:								@@\
	perl $(SRC_TREE)/condor_scripts/make_dir_tree dir_name $(SRC_TREE) @@\
really-clean::								@@\
	@if [ -d CVS ]; then echo "You definitely do NOT want to do this in your source repository." ; echo "Try doing it in a build directory, instead."; exit 1; fi @@\
	rm -rf dir_name
#endif /* object_dir_target */


/*
** Build a skeleton object tree for a particular platform.
*/
#ifndef platform_target
#define platform_target(platform)			@@\
platform.init: platform ALWAYS				@@\
	cp GENERIC/CheckPlatformType.c platform		@@\
	cp Imakefile.platform_skel platform/Imakefile	@@\
	cd platform ; ../condor_imake 		@@\
	cd platform ; make directories; make depend	@@\
platform: 						@@\
	mkdir platform
#endif  /* platform_target */

/*
** Check to make sure we are running on the correct kind of machine
** and operating system to make object files for this platform.
*/
#ifndef check_platform_target
#define check_platform_target				@@\
CheckPlatformType:					@@\
	rm -f CheckPlatformType				@@\
	cc $(CFLAGS) -o CheckPlatformType ../GENERIC/CheckPlatformType.c	@@\
	./CheckPlatformType				@@\
	rm -f CheckPlatformType
#endif  /* check_platform_target */


/*
** Build Makefile dependencies for an object tree.
**
** We could just make one rule that takes a list of the source
** files. Because we have a lot of Imakefiles, and it's a pain to 
** list the source files, I have made a few different methods:
** 1) A target that takes a list of source files.
** 2) A target that takes a list of C++ objects and derives the
**    the list of C++ files. Note that you use it like:
**           depend_target_cplus_objects(OBJ)
**    That is, you don't have $OBJ, just OBJ.
** 3) A target that takes a list of C objects and derives the
**    list of C files. It is used like number #2.
**
** Also note that you can only use one of these in an Imakefile. 
** If you can't use #2 xor #3 for convenience, you have to list
** list out the sources to use for #1. 
*/

#ifndef depend_source_target
#define depend_source_target(source_list)  @@\
sinclude dependencies                      @@\
                                           @@\
depend:	ALWAYS                             @@\
	$(CPlusPlus) $(C_PLUS_FLAGS) -MM source_list > dependencies
#endif

#ifndef depend_cplus_objects_target
#define depend_cplus_objects_target(obj_list)   @@\
sinclude dependencies                           @@\
DEPEND_CPLUS_SRC := $(##obj_list##:.o=.C)       @@\
                                                @@\
depend:	ALWAYS				                    @@\
	$(CPlusPlus) $(C_PLUS_FLAGS) -MM $(DEPEND_CPLUS_SRC) > dependencies
#endif

#ifndef depend_c_objects_target
#define depend_c_objects_target(obj_list)  @@\
sinclude dependencies                      @@\
DEPEND_C_SRC := $(##obj_list##:.o=.c)      @@\
                                           @@\
depend:	ALWAYS				               @@\
	$(CPlusPlus) $(CFLAGS) -MM $(DEPEND_C_SRC) > dependencies
#endif


/*
** Build rule for copying man pages into the right place
*/
#ifndef man_target
#if HAS_STATIC
#define man_target(name)					@@\
man_full_target(name,strip)					@@\
man_full_target(name,static)					@@\
man_full_target(name,release)
#else /* HAS_STATIC */
#define man_target(name)					@@\
man_full_target(name,strip)					@@\
man_full_target(name,release)
#endif /* HAS_STATIC */
#endif /* ifndef man_target */

#ifndef man_full_target
#define man_full_target(name,type)				@@\
manpages:: type##_dir/man/man1/##name				@@\
type##_dir/man/man1/##name: $(EXT_TRIGGER)/man-current		@@\
	/bin/rm -f type##_dir/man/man1/##name			@@\
	cp $(MAN_DIR)/man1/##name type##_dir/man/man1/##name	@@\
	chmod 0644 type##_dir/man/man1/##name
#endif

/*
** Externals build rule
*/

#ifndef ext_target
#define ext_target(package_id,ext_dep)				@@\
ext_nodep_target(package_id,ext_dep)				@@\
externals:: $(EXT_TRIGGER)/$(##package_id##)
#endif

#ifndef ext_nodep_target
#define ext_nodep_target(package_id,ext_dep)			@@\
$(EXT_TRIGGER)/$(##package_id##): ext_dep			@@\
	$(EXT_ROOT)/build_external --extern_dir=$(EXT_ROOT) --package_name=$(##package_id##) --extern_config=$(EXT_CONFIG_SH)
#endif

