%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\label{sec:Quill}Quill}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\index{Quill|(}

The following section provides an overview of the installation, deployment
and use of quill and also a description of various aspects of quill that
are significant to deployment.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\label{sec:Quill-TOE}Theory of Operation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Quill consists of three components: 

\begin{enumerate}
\item The \Condor{quill} server which maintains the job queue and history
		tables in the database.

\item A modified \Condor{q} tool which can be used to query the database
		tables.

\item A modified \Condor{history} tool.

\end{enumerate}

As part of the official condor release, these two modified query tools
(\Condor{q} and \Condor{quill}) may replace their traditional counterparts
as in addition to querying the database, these modified tools allows
users access to the old features of querying the schedd and the history
file respectively.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\label{sec:Quill-Installation}Installing and Configuring Quill}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Here is an overview of the steps needed to install and use quill and then
a description of each step.

\begin{enumerate}
\item Install postgres server and client libraries if they aren't already
\item Configure postgres to suit quill
\item Unpack and build the quill server and client tools
\item Modify \Condor{config} with quill related options
\item Invoke the quill daemon and start querying it
\item Miscellaneous issues (database schema, security, etc.)
\end{enumerate}

The rest of the document simply elaborates on each step:

\begin{enumerate}
\item The Postgress Server

Quill uses the postgres server as its backend and the postgres client
library, libpq to talk to the server. While the 8.0 version of postgres
will be included as part of condor externals, quill has also been tested
with earlier versions of postgres (specifically 7.4).

In addition, one can obtain the postgres source from:

http://www.postgresql.org/ftp/source/

Installation instructions are detailed in:
http://www.postgresql.org/docs/8.0/static/installation.html

\item Configuration of Postgress

The following steps need to be taken after postgres is installed.  These
are done only once; quill takes care of all other database creation and
maintenance tasks.

\begin{enumerate}
\item The quill daemon and client tools connect to the database as
users 'quillreader' and 'quillwriter' respectively.  We're talking
about database users and not operating system users (two completely
different things).  So if those users dont already exist, they need to
be added using the 'createuser' command in the postgres bin directory.
Moreover they need to be assigned appropriate passwords; these passwords
will be used by the quill tools to connect to the database in a secure
way.  User quillreader should not be allowed to create more databases
nor create more users.  User quillwriter should also not be allowed to
create more users however it should be allowed to create more databases.
The following commands creates the two users with the appropriate
permissions (be ready to enter the corresponding passwords when prompted):

/path/to/postgres/bin/directory/createuser quillreader --no-createdb --no-adduser --pwprompt

/path/to/postgres/bin/directory/createuser quillwriter --createdb --no-adduser --pwprompt

\item Postgres should be configured to accept tcp/ip connections.  In version
7, this was done by setting tcpip\_socket=true in the postgresql.conf file.
In version 8, this has changed.  Look at the listen\_addresses variable
in the same file.  Set yours appropriately, e.g. listen\_addresses = '*'
(here, '*' means any ip interface)

\item Postgres needs to be configured to accept tcp/ip connections from
certain hosts.  This also enables remote connections.  This is done in
the pg\_hba.conf file which usually resides in the postgres server's
data directory.  While the particular syntax and semantics for host
based configuration can vary from site to site, basically one needs
to allow access to any hosts that will access this database server,
either by way of the quill daemon itself writing to the server, or by
way of the \Condor{q} tool querying this server.  For example, in order
to give database users 'quillreader' and 'quillwriter' password-enabled
access to all databases on current machine from any other machine in
the network add the following:

host    all       quillreader       128.105.0.0       255.255.0.0    password
host    all       quillwriter       128.105.0.0       255.255.0.0    password

Note that in addition to the database specified by DATABASE\_NAME in the
\File{condor\_config} file, the quill daemon also needs access to the database
'template1'.  This is because in order to create the former database in
the first place, it needs to connect to the latter.

\end{enumerate}

Once the server is up and running and the client libraries are installed, 
we can now go ahead and install quill.  

\item Compiling and linking Quill

Quill has been fully integrated into the condor build system.  This means
that condor\_quill appears as a directory under the top level src/
directory in the condor source and building the condor source will also
automatically build quill and both of its query tools.

\item Modifying \File{condor\_config}

Now that we have built and installed quill, its time to tweak the 
\File{condor\_config} file to include quill related options.

The following variables need to either be modified or added:

The first one is DAEMON\_LIST.  Add QUILL to this list as shown below:
\begin{verbatim}
DAEMON_LIST                     = MASTER, etc. etc.,  QUILL
\end{verbatim}

Add .quillwritepassword to the VALID\_SPOOL\_FILES variable, since we 
DONT want \Condor{preen} to delete this file thinking its junk
\begin{verbatim}
VALID_SPOOL_FILES	= job_queue.log, etc. etc., .quillwritepassword
\end{verbatim}

We need to tell it where it resides and what are its start-up arguments:
\begin{verbatim}
QUILL                           = $(SBIN)/condor_quill
QUILL_ARGS                      = -f
\end{verbatim}

Quill writes to its own log just as the other daemons.  This log can be 
checked to see quill's run-time behavior and any malfunctions.
\begin{verbatim}
QUILL_LOG       = $(LOG)/QuillLog
\end{verbatim}

The following options go in the daemon-specific (in this case, quill) 
section with appropriately modified values to suit the local environment:

\begin{verbatim}
QUILL_NAME              = some-unique-quill-name.cs.wisc.edu
DATABASE_NAME           = database-for-some-unique-quill-name
# The <> in the following config file entry are required
DATABASE_IPADDRESS      = <databaseipaddress:port>
# the following parameter's units is in seconds
QUILL_POLLING_PERIOD    = 10
# the following parameter's units is in hours
QUILL_HISTORY_CLEANING_INTERVAL = 24
# the following parameter's units is in days
QUILL_HISTORY_DURATION 	= 30
QUILL_IS_REMOTELY_QUERYABLE = 1
QUILL_QUERY_PASSWORD 	=  password-for-database-user-quillreader
QUILL_ADDRESS_FILE      = $(LOG)/.quill_address
\end{verbatim}

Following is a description on each.  Skip to the next section for a brief 
overview on how to query quill:

\begin{itemize}
\item QUILL\_NAME: 
This is the name of this quill server.  Each quill server sends an ad to
the collector containing its name.  As such its important that the name of
a quill server should not conflict with that of any other quill server,
or for that matter, any schedd.  The latter is because each quill sends
a SCHEDD\_AD to the collector, and as such, from the perspective of the
collector, a quill is just another schedd. It might be convenient to
simply name the quill server, quill-machinename.fully.qualified.address

\item DATABASE\_NAME and DATABASE\_IPADDRESS
These two variables are used to determine the location of the database
server that this quill would talk to, and the name of the database that
it creates.  More than one quill server can talk to the same database
server.  This can be done by simply letting all the DATABASE\_IPADDRESS
point to the same database server.

IMPORTANT:  If more than one quill server are sharing the same database 
server, then the DATABASE\_NAME variable for all of them should be unique.  
Otherwise, there would be all kinds of bizarre overwriting.

\item QUILL\_POLLING\_PERIOD
This controls the frequency with which quill polls the job\_queue.log file.
By default, it is 10 seconds.  Since quill works by periodically sniffing
the log file for updates and then sending those updates to the database,
this variable controls the tradeoff between the currency of query results
and quill's load on the system - usually negligible.

\item QUILL\_HISTORY\_CLEANING\_INTERVAL and QUILL\_HISTORY\_DURATION 

These two variables control the deletion of historical jobs from
the database.  QUILL\_HISTORY\_DURATION is the number of days after
completion that a given job will stay in the database.  So all jobs beyond
QUILL\_HISTORY\_DURATION will be deleted.  Now, scanning the entire
database for old jobs can get pretty expensive, so the other variable
QUILL\_HISTORY\_CLEANING\_INTERVAL is the number of hours between two
successive scans.  By default, QUILL\_HISTORY\_DURATION is set to 180
days and QUILL\_HISTORY\_CLEANING\_INTERVAL is set to 24 hours.

\item QUILL\_IS\_REMOTELY\_QUERYABLE
Thanks to postgres one can now remotely query both the job queue and the
history tables. This variable controls whether this remote querying 
feature should be enabled.  By default it is 1 (true).  Note that even if 
this is 0 (false), one can still query a remote schedd using 
\begin{verbatim}
	condor_q -name remote-schedd-name
\end{verbatim}
This variable only controls whether the database tables controlled by this 
particular quill server is remotely queryable via
\begin{verbatim}
	condor_q -name remote-quill-name
\end{verbatim}

\item QUILL\_QUERY\_PASSWORD
In order for the query tools to connect to a database, it needs to
provide the password that is assigned to database user 'quillreader' in
step 2c) above. This variable is then advertised by the quill daemon to
the collector.  This facility enables remote querying: remote condor\_q++
query tools first ask the collector for the password associated with a
particular quill database and then query that database.  Users who do
not have access to the collector cannot view the password and as such
cannot query the database.  Again, this password just provides 'read'
access to the database.

\item QUILL\_ADDRESS\_FILE

\begin{verbatim}
QUILL_ADDRESS_FILE      = $(LOG)/.quill\_address
\end{verbatim}

When quill starts up, it can place it's address (IP and port)
into a file.  This way, tools running on the local machine don't
need to query the central manager to find quill.  This 
feature can be turned off by commenting out the variable.

\end{itemize}

\item Invoking the quill daemon and querying it.

Once the \File{condor\_config} file is updated with the above arguments,
the quill daemon can be started by either restarting condor using
\Condor{restart} or just starting it using \Condor{master}.  All the daemons
in the DAEMON\_LIST variable, as updated above, are started and managed
by the master accordingly.

The \Condor{quill} daemon is responsible for maintaining a database
mirror of the \File{job\_queue} and history logs.  One can query those two
using \Condor{q} and \Condor{history} respectively.  Both these two
tools retain all their old functionality, i.e. \Condor{q} can be used
to query the schedd and \Condor{history} can be used to query the
history file

Moreover, they retain all their old options plus some more thanks to
database technology.  For example, as before, we can query both using
the job id (cluster.proc), owner, dags, io, cputime, etc.  Orthogonally,
just as how we could query remote schedds, we can also query remote quill
databases for job queue and historical information.  The latter is new
functionality thanks to the remote querying functionality in Postgres.

The -help option can be used to look at all the options supported by
both tools.
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\label{sec:Quill-Example}Examples}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{enumerate}
\item Query a remote quill daemon on regular.cs.wisc.edu for all the jobs in 
the queue
\begin{verbatim}
	condor_q -name quill-regular.cs.wisc.edu
\end{verbatim}
Note that the parameter after -name is the same as that specified for
the QUILL\_NAME variable in part 3) above.  Also, the ip address and port
of the database server hosting the data of this particular remote quill
daemon can be figured out by the DATABASE\_IPADDRESS and DATABASE\_NAME
variables specified in the SCHEDD\_AD sent by the quill daemon to the
collector.


\item Query a remote quill daemon on regular.cs.wisc.edu for all historical 
jobs belonging to owner 'akini'.
\begin{verbatim}
	condor_history -name quill-regular.cs.wisc.edu akini
\end{verbatim}

\item Query the local quill daemon for the average time spent in the queue 
for all non-completed jobs. 
\begin{verbatim}
	condor_q -avgqueuetime 
\end{verbatim}
This is a new query.  -avgqueuetime is defined as the average of 
(currenttime - jobsubmissiontime) over all jobs which are neither 
completed (JobStatus == 4) or removed (JobStatus == 3).

\item Query the local quill daemon for all historical jobs completed since 
Apr 1, 2005 at 13h 00m.
\begin{verbatim}
	condor_history -completedsince '04/01/2005 13:00'
\end{verbatim}
This is also a new query.  It fetches all jobs
which got into the 'Completed' state on or after the
specified timestamp.  We follow Postgres's date/time
syntax rules as it encompasses most format options.  See
http://www.postgresql.org/docs/8.0/static/datatype-datetime.html\#AEN4516
for the various timestamp formats.

\item Query the local schedd for all the jobs in the queue submitted by akini
\begin{verbatim}
	condor_q -name akini@karadi.cs.wisc.edu
\end{verbatim}
This is using the old way of querying the schedd.  Since now, the default
is to query the database, we need to explicitly tell \Condor{q} to query
the local schedd by using the -name flag.

\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\label{sec:Quill-Schema}Quill and Its RDBMS Schema}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{enumerate}
\item Database Schema

With only 7 tables and 2 views, quill uses a relatively simple database
schema.  These can be broadly divided into tables used to store job
queue information and those used to store historical information.

The job queue part of the schema closely follows condor's classad data
model, i.e. each row in these tables describe an <attribute,value>
pair of the classad.  Additionally, just as how condor distinguishes a
ClusterAd from a ProcAd where the former stores attributes common to all
jobs within a cluster whereas the latter stores attributes specific to
each job, the schema also makes this distinction.  Finally, numerical
and string valued attributes are stored separately.

Thus we have four tables:

\begin{enumerate}

\item 
	ClusterAds\_Str\\
	(cid int, attr text, val text, primary key (cid, attr))

\item 
	ClusterAds\_Num\\
	(cid int, attr text, val double precision, primary key (cid, attr))

\item 
	ProcAds\_Str\\
	(cid int, pid int, attr text, val text, primary key (cid, pid, attr))

\item 
	ProcAds\_Num\\
	(cid int, pid int, attr text, val double precision,\\
		primary key (cid, pid, attr))

\end{enumerate}

In addition to the <attribute, value>, each row contains the cluster-id
(cid) and in the case of the ProcAd tables, also the proc-id (pid).

Since each classad would be split into potentially two tables (string
and numeric), there are views that unify them into a single entity in
order to simplify queries.

Here are the view definitions:

\begin{enumerate}
\item Definition of ClusterAds view\\
     CREATE VIEW ClusterAds as\\
        select cid, attr, val from ClusterAds\_Str UNION ALL\\
        select cid, attr, cast(val as text) from ClusterAds\_Num;


\item Definition of ProcAds view\\
     CREATE VIEW ProcAds as\\
        select cid, pid, attr, val from ProcAds\_Str UNION ALL\\
        select cid, pid, attr, cast(val as text) from ProcAds\_Num;
\end{enumerate}

Finally, the job queue part of the schema also contains a table that
stores metadata information related to the job\_queue.log file.

\begin{enumerate}
\item JobQueuePollingInfo (\\
        last\_file\_mtime         BIGINT,\\
        last\_file\_size          BIGINT,\\
        last\_next\_cmd\_offset    BIGINT,\\
        last\_cmd\_offset         BIGINT,\\
        last\_cmd\_type           SMALLINT,\\
        last\_cmd\_key            text,\\
        last\_cmd\_mytype         text,\\
        last\_cmd\_targettype     text,\\
        last\_cmd\_name           text,\\
        last\_cmd\_value          text)
\end{enumerate}
	
At all times, there's only 1 row in this table and it describes
information related to the last time quill polled the job\_queue.log file.

\begin{itemize}
\item \Bold{last\_file\_mtime and last\_file\_size}:
	The last modified time and size of the file.

\item \Bold{last\_cmd\_offset} and \Bold{last\_next\_cmd\_offset}
	The offsets of the record last read from the file and its successive record.

\item \Bold{last\_cmd\_type}
	The command type (101, 102, etc.) of the record.

\item	\Bold{last\_cmd\_key}, 
		\Bold{last\_cmd\_mytype}, 
		\Bold{last\_cmd\_targettype},
		\Bold{last\_cmd\_name},
		and
		\Bold{last\_cmd\_value}

	Together, these attributes define the record itself.	The key
	refers to the combined "cid.pid" pair, mytype and target usually
	contains Job and Machine respectively, and finally the name and
	value contains the <attribute,value> pair.
\end{itemize}

The historical information on the other hand is slightly differently
designed.  Instead of a purely vertical data model (each row is a
<attribute,value> pair), we have two tables that together represent the
complete job classad.  Their schema is as follows:

viii) History\_Horizontal(
        cid                  int,
        pid                  int,
        Owner                text,
        QDate                int,
        RemoteWallClockTime  int,
        RemoteUserCpu        float,
        RemoteSysCpu         float,
        ImageSize            int,
        JobStatus            int,
        JobPrio              int,
        Cmd                  text,
        CompletionDate       int,
        LastRemoteHost       text,
        primary key(cid,pid))

and 

ix)  History\_Vertical (cid int, pid int, attr text, val text, primary key
	(cid, pid, attr))

Each historical job ad is divided into its horizontal and vertical
counterparts.  This division was made because of query performance
reasons.  While its easier to store classads in a vertical table, queries
on vertical tables generally perform worse than those on horizontal
tables since the latter has lot fewer records.  However, in Condor,
since job ads dont have a fixed schema (users can define their own
attributes), a purely horizontal schema would end up having a lot of
null values. As such, we have a hybrid schema where attributes on which
queries are frequently performed (via \Condor{history}) are put in the
History\_Horizontal table and the other attributes are stored vertically
(just as in the Cluster/Proc tables above) in the History\_Vertical
table. Also History\_Horizontal contains all the attributes needed to
service the short form of the \Condor{history} command (i.e. without
the -l option).

The resulting hybrid schema has proven to be the most efficient in
servicing \Condor{history} queries.  The job queue tables (Cluster and
Proc) were not designed in this hybrid manner because job queues aren't
as large as history; just a vertical schema worked great.

\item Security in Quill

There are several layers of security in Quill, some provided by condor and
others provided by the database.  Firstly, all accesses to the database
are password-protected.

\begin{enumerate}
\item As mentioned in section 2c) above, the query tools, \Condor{q}
and \Condor{history} connect to the database as user 'quillreader'.
The password for this user can vary from one database to another and
as such, each quill daemon advertises this password to the collector.
The query tools then obtain this password from the collector and connect
successfully to the database.  Access to the database by the 'quillreader'
user is read-only as this is sufficient for the query tools.  The quill
daemon ensures this protected access using the sql GRANT command when
it first creates the tables in the database.  Note that access to
quillreader's password itself can be blocked by blocking access to the
collector, a feature already supported in Condor.

\item The quill daemon, on the other hand, needs read and write access
to the database.  As such, it connects as user 'quillwriter' who has
owner priviledges to the database.  Since this gives all access to the
'quillwriter' user, its password cannot be stored in a public place
(such as the collector).  For this reason, quillwriter's password is
stored in a file called .quillwritepassword in the condor spool directory.
Appropriate read/write protections on this file guarantee secure access
to the database.  This file must be created and protected by the site
administrator;  if this file does not exist as and where expected,
the quill daemon logs and error and exits.

\item Finally, as mentioned in section 2c) above, the IsRemotelyQueryable
attribute in the SCHEDD\_AD advertised by the quill daemon to the collector
can be used by site administrators to disallow the database from being
read by all remote condor query tools.

\end{enumerate}

\item Maintenance (Non) Issues

There are virtually no maintenance issues in Quill.  Once started, it
checks if all necessary database related structures (database itself,
tables, indices, views) are present and creates them if they are
not present. It also purges old historical jobs based on user policy
(see section 4 above) and garbage collection in the database (using the
postgres VACUUM ANALYZE command).  Of course, if Quill is shut down and
the database is no longer needed, it can be dropped using the postgres
dropdb command.

\end{enumerate}

