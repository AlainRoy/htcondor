%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\label{API-WebService} Web Service}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\index{API!Web Service}
\index{SOAP!Web Service API}
\index{Simple Object Access Protocol(SOAP)}
\index{Web Service API}

Condor's Web Service (WS) API provides a way for application developers
to interact with Condor, without needing to utilize
Condor's command-line tools.
In keeping with the Condor philosophy of reliability and fault-tolerance,
this API is designed to provide a simple and powerful way
to interact with Condor.
Condor daemons understand and implement
the SOAP (Simple Object Access Protocol) XML API
to provide a web service interface for Condor job submission
and management.

To deal with the issues of reliability and fault-tolerance,
a two-phase commit mechanism to provides a transaction-based protocol.  
The following API description describes interaction
between a client using the API and the \Condor{schedd} daemon
to illustrate transactions
for use in job submission and queue management functions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{WebService-Transactions} Transactions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\index{Web Service API!transactions}

All applications using the API to interact with the \Condor{schedd}
will need to use transactions.
A transaction is
an ACID unit of work (atomic, consistent, isolated, and durable).
The API limits the lifetime of a transaction,
and both the client (application) and the server
(the \Condor{schedd} daemon)
may place a limit on the lifetime.
The server reserves the right to specify a maximum
duration for a transaction. 


The client initiates a transaction using the
\Procedure{beginTransaction} method. 
It ends the transaction with either 
a commit (using \Procedure{commitTransaction})
or an abort (using \Procedure{abortTransaction}).

% providing a timeout for the transaction.
% The client is effectively granted a lease to a transaction. Instead
% of providing a timeout that is a guess as to how long the transaction
% is needed, the timeout is just the number of seconds that can elapse
% between subsequent operations in a transaction. Essentially, a
% transaction's timeout is extended each time the transaction is used.
% The amount of time the transaction is extended is the timeout
% initially passed to CreateTransaction(). If that timeout is not
% sufficient there is also an ExtendTransaction() method that can be
% used to modify the timeout. When a client is finished with a
% transaction is will call either CommitTransaction() or
% AbortTransaction(). In the former case, all the jobs submitted in the
% transaction will be queued. In the latter case, everything that
% occurred in the transaction will be undone. If a transaction expires,
% i.e. its timeout is reached, AbortTransaction() is automatically
% called on it.

% This scheme provides a reasonable amount of utility for a client to
% easily deal with transactions. To give the server some say in how its
% resources will be utilized it reserves the right to specify a maximum
% duration for a transaction. This happens when BeginTransaction() is
% called by the client. The result of the call is not only a
% transaction identifier for later use but also the timeout for the
% transaction. That timeout is the actual timeout for the transaction.
% It may be shorter or longer than what the client requested. Any
% reasonable server will allow the timeout to be long enough for a
% significant amount of work to be completed.

Not all operations in the API need to be performed within a
transaction.
Some accept a null transaction.
A null transaction is a SOAP message with
\begin{verbatim}
<transaction xsi:type="ns1:Transaction" xsi:nil="true"/> 
\end{verbatim}
Often this is achieved by passing the programming
language's equivalent of \verb@null@ in place of a transaction identifier.
It is possible that some operations will have access to more
information when they are used inside a transaction. For instance, a
\Procedure{getJobAds}.
query would have access to the jobs that are pending in a
transaction, which are not committed and therefore not visible
outside of the transaction. 
Transactions are as ACID compliant as possible. 
Therefore, do not query for information
outside of a transaction on which to make a decision inside a
transaction based on the query's results.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{WebService-Submission} Job Submission}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\index{Web Service API!job submission}

A ClassAd is required to describe a job.
The job ClassAd will be 
submitted to the \Condor{schedd} within a transaction
using the \Procedure{submit} method.
The complexity of job ClassAd creation may be simplified
by the \Procedure{createJobTemplate} method.
It returns an instance of a ClassAd structure that may be
further modified.
A necessary part of the job ClassAd are the job attributes
\Attr{ClusterId} and \Attr{ProcId}, which uniquely identify
the cluster and the job within a cluster.
Allocation and assignment of (monotonically increasing)
\Attr{ClusterId} values utilize the \Procedure{newCluster} method.
Jobs may be submitted within the assigned cluster only until
the \Procedure{newCluster} method is invoked a subsequent time. 
Each job is allocated and assigned a (monotonically increasing)
\Attr{ProcId} within the current cluster using the \Procedure{newJob}
method.
Therefore, the sequence of method calls to submit a set of jobs
initially calls \Procedure{newCluster}.
This is followed by calls to \Procedure{newJob} and then \Procedure{submit}
for each job within the cluster.

As an example, here are sample cluster and job numbers that 
result from the ordered calls to submission methods:
\begin{enumerate}
 \item
 A call to \Procedure{newCluster}, assigns a \Attr{ClusterId} of 6.
 \item
 A call to \Procedure{newJob}, assigns a \Attr{ProcId} of 0, as
 this is the first job within the cluster.
 \item
 A call to \Procedure{submit} results in a job submission numbered 6.0.
 \item
 A call to \Procedure{newJob}, assigns a \Attr{ProcId} of 1.
 \item
 A call to \Procedure{submit} results in a job submission numbered 6.1.
 \item
 A call to \Procedure{newJob}, assigns a \Attr{ProcId} of 2.
 \item
 A call to \Procedure{submit} results in a job submission numbered 6.2.
 \item
 A call to \Procedure{newCluster}, assigns a \Attr{ClusterId} of 7.
 \item
 A call to \Procedure{newJob}, assigns a \Attr{ProcId} of 0, as
 this is the first job within the cluster.
 \item
 A call to \Procedure{submit} results in a job submission numbered 7.0.
 \item
 A call to \Procedure{newJob}, assigns a \Attr{ProcId} of 1.
 \item
 A call to \Procedure{submit} results in a job submission numbered 7.1.
\end{enumerate}


% The process of submitting a job involves more than creating a
% job ClassAd and passing it to \Procedure{submit}.
% Before Submit() can be called a
% cluster and job identifier must have been allocated. This is achieved
% through the use of NewCluster() and NewJob(). These two calls will
% return identifiers to be used in Submit(). The sequence of operations
% that will typically occur is NewCluster() -> NewJob() -> Submit() ->
% NewJob() -> Submit() -> NewCluster -> NewJob() -> etc. This sequence
% is very important because new jobs can only be submitted to the most
% recently created cluster. If NewCluster() is called twice in a row
% producing identifiers 1 and 2, jobs can only be submitted to cluster 2.

% In the simplest submission case, a client creates a JobAd and passes
% it to Submit() and is finished. In the most common case, this will
% not be enough information for the job to be run. There will be a need
% for the job's input files and the job's executable, known as the
% sand, i.e. the sand of the job's sandbox, to be transferred along
% with the JobAd. To deal with sand movement a client can use the file
% transfer functions of the API, described below. Unfortunately, the
% statement of create a JobAd is often easier said than done. There
% are many things that must to be present in a JobAd for it to be
% accepted by the Schedd. To alleviate the problem of creating a JobAd
% the Schedd also provides a mechanism to create a template of a JobAd.
% This method is called CreateJobTemplate() and it returns a JobAd
% which can readily be sent to Submit().

There is the
potential that a call to \Procedure{submit} will fail.
Failure means that the
job is in the queue,
and it typically indicates that
something needed by the job has not been sent.
As a result the job has no hope in successfully running.
It is possible to recover from
such a failure by trying to resend information that the job will
need. It is also completely acceptable to abort and make another
attempt. To simplify the client's effort in figuring out what the job
requires, a \Procedure{discoverJobRequirements} method accepting a 
job ClassAd and
returning a list of things that should be sent along with the job is
provided.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{WebService-File-Transfer} File Transfer}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\index{Web Service API!file transfer}

A common job submission case requires the job's
executable and input files to be transferred
from the machine where the application is running
to the machine where the \Condor{schedd} daemon is running.
This is the analogous situation to running \Condor{submit}
using the \Opt{-spool} or \Opt{-remote} option.
The executable and input files must be sent directly to
the \Condor{schedd} daemon, which places all files
in a spool location.

The two methods 
\Procedure{declareFile}
and \Procedure{sendFile} work in tandem to transfer files
to the \Condor{schedd} daemon.
The \Procedure{declareFile} method causes the \Condor{schedd} daemon
to create the file in its spool location,
or indicate in its return value that the file already exists.
This increases efficiency, 
as resending an existing file is a waste of resources.
The \Procedure{sendFile} method sends 
base64 encoded data.
\Procedure{sendFile} may be used to send an 
entire file, or chunks of files as desired.
% 
% It is often the case that a job's sand will not already be present on
% the machine where it will be executed. In this case it is necessary
% to transfer the sand to the Schedd, where it will reside in a spool
% location until needed. To transfer a job's sand the API provides two
% methods, DeclareFile() and SendFile(), which work in tandem. For each
% file needed by the job, a client should first call DeclareFile() and
% then send the file's contents with SendFile(). The process of
% transferring a file is broken into two operations because it is
% entirely possible that files being sent to the Schedd may already
% exist, and therefore resending a file is simply a waste of resources.
% In such a case when a client performs a DeclareFile() it will be told
% if it should bother sending the file or not. If the client is told to
% send the file it can then use SendFile() which does not necessarily
% send the entire file at one time. To deal with files that are more
% than a few tens of megabytes the SendFile() operation works on chunks
% of files, meaning a 100MB file can be sent in a series of SendFile()
% calls. (NOTE: All data is base64 encoded before being sent with
% SendFile(), which means there is a 33% increase in size for the data.)

The \Procedure{declareFile} method has both required and
optional arguments.
\Procedure{declareFile} requires the name of the file
and its size in bytes.
The optional arguments relate hash information.
A hash type of \Code{NOHASH} disables file verification;
the \Condor{schedd} daemon will not have a reliable way
to determine the existence of the file being declared.

% The DeclareFile() operation takes a few critical arguments and a few
% optional arguments. Firstly, the name of the file being sent and the
% size of the file, in bytes, are critical. Second, the hash
% information about the file is non-critical. The type of hash can be
% specified as NOHASH for clients who just do not care to have their
% files verified. Also, if NOHASH is used during DeclareFile(), there
% is no reliable way for the server to discover if it already has the
% file being declared.

Methods for retrieving files are most useful when a job is completed.
Consider the categorization of the typical life-cycle for a job:
\begin{description}
  \item[Birth:]
  The birth of a job begins with \Procedure{submit}.
  \item[Childhood:]
  The job executes.
  \item[Middle Age:]
  A completed job waits to be removed.
  As the job enters Middle Age,
  its \Attr{JobStatus} ClassAd attribute becomes Completed (the value 4).
  \item[Old Age:]
  The job's information goes into the history log.
\end{description}

Once the job enters Middle Age,
the \Procedure{getFile} method retrieves a file.
The \Procedure{listSpool} method assists by providing
a list of all the job's files in the spool location.

The job enters Old Age by the application's use of the
\Procedure{closeSpool} method.
It causes  the \Condor{schedd} daemon to remove the 
job from the queue, 
and the job's spool files are no longer available.
As there is no requirement for the application to invoke
the \Procedure{closeSpool} method,
jobs can potentially remain in the queue forever.
The configuration variable \Macro{SOAP\_LEAVE\_IN\_QUEUE}
may mitigate this problem.
When this boolean variable evaluates to \Expr{False},
a job enters Old Age.
A reasonable example for this configuration variable is
\footnotesize
\begin{verbatim}
SOAP_LEAVE_IN_QUEUE = ((JobStatus==4) && ((ServerTime - CompletionDate) < (60 * 60 * 24)))
\end{verbatim}
\normalsize
This expression results in Old age for a job (removed from the queue),
once the job has been Middle Aged (been completed) for 24 hours.

% So far all the API methods have dealt with sending files to the
% Schedd. There are also methods for retrieving files. These methods
% are mostly useful after a job has completed. The typical life-cycle
% of a job is: first, birth with Submit(); second, execution, where the
% job is hopefully productive; third, middle-age, where the completed
% job waits around to be removed; last, old-age, where the job hauled
% off to a history log. When a job enters middle-age, which a client
% can discover by look at its JobStatus attribute (4 indicates the
% Completed state), a client can use the GetFile() method to start
% retrieving files output by the job. In the case where the client does
% not know exactly what the job output, ListSpool() can be used to
% discover all the files related to the job. Finally, there are two
% ways that a job can enter old-age. First, a client can politely force
% the job into old-age by calling CloseSpool(). Once this is done the
% job is removed from the Schedd's queue and its files are no longer
% available via ListSpool() and GetFile(). The second way a job can
% enter old-age is by a configuration option in the Schedd. The
% \Macro{SOAP\_LEAVE\_IN\_QUEUE} option, in a configuration file, specifies an
% expression that, when evaluating to FALSE, will force the job into
% old-age. This configuration option is quite important for the Schedd
% because clients may not ever bother to call CloseSpool() and as a
% result all jobs could stay in middle-age forever. An example of
% \Macro{SOAP\_LEAVE\_IN\_QUEUE} is 
% \begin{verbatim}
% ((JobStatus==4) && ((ServerTime - CompletionDate) < (60 * 60 * 24)))
% \end{verbatim}
% which specifies that all jobs
% should be forced into old-age if they have been in middle-age for a day.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{WebService-Implementation} Implementation Details}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Condor daemons understand and communicate using the
SOAP XML protocol.
An application seeking to use this protocol
will require code that handles the communication.
The XML WSDL (Web Services Description Language)
that Condor implements is included with the
Condor distribution.
It is in \File{\MacroUNI{RELEASE\_DIR}/lib/webservice}.
The WSDL must be run through a toolkit to produce
language-specific routines that do communication.
The application is compiled with these routines.

Condor must be configured to enable responses to SOAP calls.
Please see 
section~\ref{sec:API-Config-File-Entries} for definitions of the
configuration variables related to the web services API.

The API's routines can be roughly categorized into ones that
deal with
\begin{itemize}
  \item Transactions
  \item Job Submission
  \item File Transfer
  \item Job Management
\end{itemize}
The routines for each of these categories is detailed.
Note that the signature provided will accurately 
reflect a routine's name, 
but that return values and parameter specification
will vary according  to the target programming language.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{WebService-Transactions} Methods for Transaction Management}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{description}
\item [\Code{beginTransaction}]
  A prototype is
  
  \Code{StatusAndTransaction beginTransaction(int duration);}
  
  Begin a transaction.
\item [\Code{commitTransaction}]
  A prototype is

  \Code{Status commitTransaction(Transaction transaction);}

  Commits a transaction.
\item [\Code{abortTransaction}]
  A prototype is

  \Code{Status abortTransaction(Transaction transaction);}

  Abort a transaction.
\item [\Code{extendTransaction}]
  A prototype is

  \Code{StatusAndTransaction extendTransaction(Transaction transaction, int duration);}

  Request an extension in duration for a specific transaction.
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{WebService-Submission} Methods for Job Submission}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{description}
\item [\Code{submit}]
  A prototype is

  \Code{Status submit(Transaction transaction, int clusterId, int jobId, ClassAd jobAd);}

  Submit a job.
\item [\Code{createJobTemplate}]
  A prototype is 

  \Code{StatusAndClassAd createJobTemplate(int clusterId, int jobId,
  String owner, UniverseType type, String command, String arguments, 
  String requirements);}
 
  Request a job Class Ad, given some of the job requirements.
  This job Class Ad will be suitable for use when submitting the job.

%%    StatusAndRequirements discoverJobRequirements(ClassAd jobAd)

\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{WebService-FileTransfer} Methods for File Transfer}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{description}
\item [\Code{declareFile}]
  A prototype is 

  \Code{Status declareFile(Transaction transaction, int clusterId, 
  int jobId, String name, int size, HashType hashType, String hash);}

  Declare a file that may be used by a job.
\item [\Code{sendFile}]
  A prototype is 

  \Code{Status sendFile(Transaction transaction, int clusterId, int jobId, String name, int offset, Base64 data);}

  Send a file that a job may use.
\item [\Code{getFile}]
  A prototype is 

  \Code{StatusAndBase64 getFile(Transaction transaction, int clusterId, 
  int jobId, String name, int offset, int length);}

  Get a file from a job's spool.
  Does not need to occur in a transaction.
\item [\Code{closeSpool}]
  A prototype is 

  \Code{Status closeSpool(Transaction transaction, int clusterId, int jobId);}

  Close a job's spool.
  Does not need to occur in a transaction.
  All the files in the job's spool can be deleted. 
  %%  deleted before or after this method returns/is invoked?
\item [\Code{listSpool}]
  A prototype is 

  \Code{FileInfoArrayAndStatus listSpool(Transaction transaction, int clusterId, int jobId);}

  List the files in a job's spool.
  Does not need to occur in a transaction.
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{WebService-JobManagement} Methods for Job Management}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{description}
\item [\Code{newCluster}]
  A prototype is 

  \Code{StatusAndInteger newCluster(Transaction transaction);}

  Create a new job cluster.
\item [\Code{removeCluster}]
  A prototype is 

  \Code{Status removeCluster(Transaction transaction, int clusterId,
  String reason);}

  Remove a job cluster, and all the jobs within it.
  %% What does it mean within Condor to remove a cluster?
  Does not need to occur in a transaction.
\item [\Code{newJob}]
  A prototype is 

  \Code{StatusAndInteger newJob(Transaction transaction, int clusterId);}

  Creates a new job within the most recently created job cluster.
  %% Why pass the clusterId if there's only 1 that we can use?
  %% Is this to mimic the behaviour of commands within a submit file
  %%     WRT the queue command?
\item [\Code{removeJob}]
  A prototype is 

  \Code{Status removeJob(Transaction transaction, int clusterId, 
  int jobId, String reason, boolean forceRemoval);}

  Remove a job, regardless of the job's state.
  Does not need to occur in a transaction.
\item [\Code{holdJob}]
  A prototype is 

  \Code{Status holdJob();}
  %% Needs parameters.

  Put a job into the Hold state, regardless of the job's current state.
  Does not need to occur in a transaction.
\item [\Code{releaseJob}]
  A prototype is 

  \Code{Status releaseJob(Transaction transaction, int clusterId, 
  int jobId, String reason, boolean emailUser, boolean emailAdmin);}

  Release a job that has been in the Hold state.
  Does not need to occur in a transaction.

\item [\Code{getJobAds}]
  A prototype is 

  \Code{StatusAndClassAdArray getJobAds(Transaction transaction, 
  String constraint);}

  Find all the job ClassAds matching the given constraint.
  %% Find them from where?  The API's set of cluster/jobs or Condor's?
  Does not need to occur in a transaction.
\item [\Code{getJobAd}]
  A prototype is 

  \Code{StatusAndClassAd getJobAd(Transaction transaction, 
  int clusterId, int jobId);}

   Find a specific job ClassAd. 
   This method does much the same as the first element from the array 
   returned by

\footnotesize
\begin{verbatim}
getJobAds(transaction, "(ClusterId==clusterId && JobId==jobId)")
\end{verbatim}
\normalsize


\item [\Code{requestReschedule}]
  A prototype is 

  \Code{Status  requestReschedule();}

   Request a \Condor{reschedule} from the \Condor{schedd} daemon.
\end{description}

%% Not yet in this list:
