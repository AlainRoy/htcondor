%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\label{sec:Security}Security In Condor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This section describes various aspects of security within Condor.
The section is not yet complete.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\label{sec:Non-Root}Running Condor as Non-Root}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

While we strongly recommend starting up the Condor daemons as root, we
understand that it is not always possible to do so.
The main problems appear
if you have one Condor installation shared by many users
on a single machine, or if you are setting up machines to only
execute Condor jobs.
If you are setting up a submit-only installation for
a single user, then there is no need for (or benefit from) running as
root.  

What follows are the effects on the various parts of Condor
of running both with and without root access.

\begin{description}

\item[\Condor{startd}] If you're setting up a machine to run Condor
   jobs and don't start the \Condor{startd} as root, you're basically
   relying on the goodwill of your Condor users to agree to the policy
   you configure the startd to enforce as far as starting, suspending,
   vacating and killing Condor jobs under certain conditions.  If you
   run as root, however, you can enforce these policies regardless of
   malicious users.  By running as root, the Condor daemons run with a
   different UID than the Condor job that gets started (since the
   user's job is started as either the UID of the user who submitted
   it, or as user ``nobody'', depending on the \Macro{UID\_DOMAIN}
   settings).  Therefore, the Condor job cannot do anything to the
   Condor daemons.  If you don't start the daemons as root, all
   processes started by Condor, including the end user's job, run with
   the same UID (since you can't switch UIDs unless you're root).
   Therefore, a user's job could just kill the \Condor{startd} and
   \Condor{starter} as soon as it starts up and by doing so, avoid
   getting suspended or vacated when a user comes back to the machine.
   This is nice for the user, since they get unlimited access to the
   machine, but awful for the machine owner or administrator.  If you
   trust the users submitting jobs to Condor, this might not be a
   concern.  However, to ensure that the policy you choose is
   effectively enforced by Condor, the \Condor{startd} should be
   started as root.

   In addition, some system information cannot be obtained without
   root access on some platforms (such as load average on IRIX).  As a
   result, when running without root access, the \Condor{startd} has to
   call other programs (for example, ``uptime'') to get this
   information.  This is much less efficient than getting the
   information directly from the kernel (which is what we do if we're
   running as root).  On Linux and Solaris, we can get this
   information directly without root access, so this is not a concern
   on those platforms.

   If you can't have all of Condor running as root, at least consider
   whether you can install the \Condor{startd} as setuid root.  That
   would solve both of these problems.  If you can't do that, you
   could also install it as a setgid sys or kmem program (depending on
   whatever group has read access to \File{/dev/kmem} on your system)
   and that would at least solve the system information problem.

\item[\Condor{schedd}] The biggest problem running the schedd
    without root access is that the \Condor{shadow} processes which it
    spawns are stuck with the same UID the \Condor{schedd} has.  This
    means that users submitting their jobs have to go out of their way
    to grant write access to user or group condor (or whoever the
    schedd is running as) for any files or directories their jobs
    write or create.  Similarly, read access must be granted to their
    input files.

    You might consider installing \Condor{submit} as a setgid condor
    program so that at least the \File{stdout}, \File{stderr} and
    \File{UserLog} files get created with the right permissions.  If
    \Condor{submit} is a setgid program, it will automatically set
    it's umask to 002, so that creates group-writable files.  This
    way, the simple case of a job that just writes to \File{stdout}
    and \File{stderr} will work.  If users have programs that open
    their own files, they'll have to know to set the right permissions
    on the directories they submit from.

\item[\Condor{master}] The \Condor{master} is what spawns the
    \Condor{startd} and \Condor{schedd}, so if want them both running
    as root, you should have the master run as root.  This happens
    automatically if you start the master from your boot scripts.

\item[\Condor{negotiator}]
\item[\Condor{collector}] There is no need to have either of these
daemons running as root.

\item[\Condor{kbdd}] On platforms that need the \Condor{kbdd} (Digital
    Unix and IRIX) the \Condor{kbdd} has to run as root.  If it is
    started as any other user, it will not work.  You might consider
    installing this program as a setuid root binary if you can't run
    the \Condor{master} as root.  Without the \Condor{kbdd}, the
    startd has no way to monitor mouse activity at all, and the only
    keyboard activity it will notice is activity on ttys (such as
    xterms, remote logins, etc).

\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\label{sec:uids}UIDs in Condor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{UIDs in Condor|(}

On a Unix system,
UIDs (User IDentification numbers) form part of an operating system's
tools for maintaining access control.
Each executing program has a UID,
a unique identifier of a user executing the program.
This is also called the real UID.
\index{UID!real}
A common situation has one user executing the program owned
by another user.
Many system commands work this way, with a user (corresponding
to a person) executing a program belonging to (owned by) root.
Since the program may require privileges that root has which
the user does not have, a special bit in the program's
protection specification (a setuid bit) allows the program
to run with the UID of the program's owner, instead of the
user that executes the program.
This UID of the program's owner is called an effective UID.
\index{UID!effective}

%GID (group identification)
Condor works most smoothly when its daemons run as root.
The daemons then have the ability to switch their 
effective UIDs at will.
When the daemons run as root,
they normally leave their effective UID and GID (Group IDentification)
to be those of user and group condor.
This allows access to the log files without
changing the ownership of the log files.
It also allows access to these files when
the user condor's home directory resides on an NFS server.
root can not normally access NFS files.

On a machine where a job is submitted,
the \Condor{schedd} daemon
changes its effective UID to root
such that it has the capability to start up a \Condor{shadow} daemon
for the job.
Before a \Condor{shadow} daemon is created,
the \Condor{schedd} daemon
switches back to root,
so that it can start up the \Condor{shadow} daemon with the (real) UID
of the user who submitted the job.
Since the \Condor{shadow} runs as the owner of the job,
all remote system calls are performed under the owner's UID
and GID.
This ensures that as the job executes,
it can access only files that its owner could access if the job
were running locally, without Condor.
On the machine where the job executes, the 
job runs as user nobody, to help ensure that the job cannot access
local resources or do harm.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{sec:norootaccess}What if Condor is not run as root?}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Condor can also function on all platforms by starting up as
user condor.  Since user condor does not have the ability to switch
UID or GID, all daemons run with both the UID and GID belonging
to user condor.
The \Condor{shadow} daemon and the job's executable also
run as user condor.
This has the effect that
the job can access only the files and directories that are
accessible to the user condor on the machine where the job
was submitted.
Owners of
jobs must make their input readable to the user condor.
A job's output must be placed in a directory that is writable by
the user condor as well.
In practice, this means creating
world-writable directories for output from Condor jobs.
This creates a potential security risk,
in that any user on the machine where the job is submitted
can alter the data, remove it, or do other undesirable things.
It is acceptable in an environment where users can trust other users.

On platforms where root access is not needed,
Condor can even function without a UID or GID of the user condor.
A directory to act as the condor home directory is still required,
containing the configuration files, spool,
execute and log directories.
This home directory is not technically the
home directory of any user.
In this case, a user condor may or may not even exist,
but the directory is still referred to as the condor home
directory.
If the user condor does not exist,
use the CONDOR\_CONFIG environment variable such
that all Condor daemons and tools
can find their configuration file
(which in turn defines the
locations of other needed files and directories),
or place a configuration file in \File{/etc/condor/condor\_config}.
The Condor daemons can then be started up by whatever UID and GID has
access to the local \File{condor} directory.
Normally, users without root
access who wish to use Condor on their machines create a
\File{condor} home directory somewhere within their own accounts
and start up the daemons (to run with the UID of the user).
As in the case where the daemons run as user condor,
there is no ability to switch UIDs or GIDs.
The daemons run as the UID and GID of the user who started them.
On a machine where jobs are submitted, the \Condor{shadow} daemons
all run as this same user.
However, if other users on the machine are using Condor in this
environment, the \Condor{shadow} daemons for these other users'
jobs execute with the UID of the user who started the daemons.
This is a security risk, since the Condor job of the other user
has access to all the files and directories of the user
who started the daemons.
Some installations have this level of trust,
but others do not.
Where this level of trust does not exist, it is best to set up a
condor account and group, or to have each user start up their own
Personal Condor submit installation.

When a machine is an execution site for a Condor job,
the Condor job executes with the UID of the user who started the
\Condor{startd} daemon.
This is also potentially a security risk, which is why we do not
recommend starting up the execution site daemons as a regular user.
Use either root or a user (such as the user condor) that 
exists only to run Condor jobs.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{sec:DirOfJob}What directory does a job run in?}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Any executing process has a notion of its current working
directory (cwd),
the directory that acts as the base for all file system access.
There are two sides to any Condor job:
the submit side and the execution side.
This implies that there are two cwds.
On the submit side, the owner's cwd sets
a default cwd as a job is submitted.
The cwd can be changed with a command in the submit description file.
Since many jobs can be submitted at the same time,
the commands are flexible in order to set the cwd individually for
each job if desired.
This submit side cwd remains for the entire life of a job.
The submit side cwd is also used as the cwd of the \Condor{shadow} daemon.
Since file system access for the job goes through the \Condor{shadow}
daemon,
all accesses behave as if they were executing without Condor.

There is also a cwd associated with the Condor job on the execution machine.
It is set to the \File{execute} subdirectory of Condor's home directory.
This directory is world-writable, since a Condor job usually runs as user
nobody.
Normally, the executable would never access this directory,
since all I/O system calls are passed back to the \Condor{shadow} daemon
on the submit machine.
However, in the event that the job that creates a core dump,
the cwd on the execute machine needs to be accessible by
the job so that it can write the core file.
The core file is moved back to the submit machine,
and the \Condor{shadow} daemon is informed.
The \Condor{shadow} daemon sends e-mail to the job owner announcing the
crash and providing a pointer to the core file, then residing
in the submit side cwd.

\index{UIDs in Condor|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\label{sec:Config-Security} Security Configuration}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Condor adds strong authentication, encryption, and integrity
assurance to its network communications.
Most of these security features are not visible to the user
(one who submits jobs).
They are enabled by site administrators through the use of
configuration macros.
The macros describe the authentication, encryption,
integrity assurance, as well as authorization used by Condor.

Authentication provides an assurance of the identity of one of the
communicating parties.
Mutual authentication provides an assurance of the identities of
both of the communicating parties.
Encoding information such that its contents is not easily
decipherable by outsiders is called encryption.
The integrity of a message is assured when any form of
tampering with the message can be detected. 
Nothing in the message can be added, deleted, or modified.

When Condor is installed, default configuration settings
use no authentication, encryption, or integrity checks.
This allows newer versions of Condor with
security features to work or interact
with previous versions that had no security.
An administrator must modify the configuration settings to
enable the security features.

Inside Condor, daemons need to communicate with each other;
furthermore, various tools provided by Condor may also
require communication with Condor daemons.
All these communications can be made more secure
through the proper usage of authentication, encryption,
and integrity checks.

When a daemon receives a request,
it uses a combination of the client's security information
(included with the request)
together with its own configuration settings to decide upon
the security aspects of the communication.
This can be considered a negotiation between the client and
the daemon.
The daemon replies to the client with a confirmation of
the security aspects of the communication.
If this includes a required authentication, then the
client must follow the chosen protocol.

After a required authentication, the client can again send its
request to the daemon. 
The daemon identifies the access level required for the specific
request,
and it checks the configuration settings to determine if the client 
has the required access level.
If the client has the required access level,
permission is granted, and the request is filled. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{sec:Security-access-levels} Access Level Descriptions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Authorization is granted based on specified access levels.
An access level is granted for users in configuration variables.
The following describe the various access levels.

\begin{description}

\item[\DCPerm{READ}] \label{dcperm:read} \DCPerm{READ} level
   access can obtain or read information about Condor.
   Examples that require only \DCPerm{READ} access are
   viewing the status of the pool, seeing the job queue(s),
   or viewing user permissions.
   \DCPerm{READ} access does not allow any
   changes, and it does not allow job submission.

\item[\DCPerm{WRITE}] \label{dcperm:write} \DCPerm{WRITE} access
   is required to send (write) information to Condor.
   Note that \DCPerm{WRITE} access does not include \DCPerm{READ} access.
   They are separate access levels.
   Job submission requires \DCPerm{WRITE} access.

\item[\DCPerm{ADMINISTRATOR}] \label{dcperm:administrator} The
   \DCPerm{ADMINISTRATOR} access level has additional Condor
   administrator rights to the pool.  This includes the ability to
   change user priorities (with the command \Condor{userprio -set}),
   and the ability to turn Condor on and off
   (as with the command \Condor{off}).

\item[\DCPerm{CONFIG}] \label{dcperm:config} This access level is
   required to modify a daemon's configuration using
   the \Condor{config\_val} command.
   By default, this level of access is allowed
   to change any configuration parameters, except those specified in
   the \File{condor\_config.root} configuration file.

\item[\DCPerm{DAEMON}] \label{dcperm:config} 
   This access level is for daemon to daemon communications.
   An example is the message sent from the \Condor{startd} daemon
   to the \Condor{schedd} daemon in order to claim a resource.

\item[\DCPerm{OWNER}] \label{dcperm:owner} This level of access is
   required for commands that the owner of a machine (any local user)
   should be able to use, in addition to the Condor administrators.
   An example that requires the \DCPerm{OWNER} access level is
   the \Condor{vacate} command.
   The command causes the \Condor{startd} daemon to vacate any
   Condor job currently running on a machine.
   The owner of that machine should be able to cause the removal
   of a job running on the machine.

\item[\DCPerm{NEGOTIATOR}] \label{dcperm:negotiator} This 
   access level is used specifically to verify that commands are
   sent by the \Condor{negotiator} daemon.
   The \Condor{negotiator} daemon runs on the central manager of
   the pool.
   Commands requiring this access
   level are the ones that tell the \Condor{schedd} daemon to begin
   negotiating, and those that tell an available \Condor{startd} daemon
   that it has been matched to a \Condor{schedd} with jobs to run.

\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{sec:Security-NamesValues} Security Macro Names and Values}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%\index{configuration macro!\texttt{SEC\_DEFAULT\_NEGOTIATION}}
%\index{configuration macro!\texttt{SEC\_READ\_NEGOTIATION}}
%\index{configuration macro!\texttt{SEC\_WRITE\_NEGOTIATION}}
%\index{configuration macro!\texttt{SEC\_ADMIN\_NEGOTIATION}}
%\index{configuration macro!\texttt{SEC\_DAEMON\_NEGOTIATION}}
%\index{configuration macro!\texttt{SEC\_CONFIG\_NEGOTIATION}}
%\index{configuration macro!\texttt{SEC\_OWNER\_NEGOTIATION}}
%\index{configuration macro!\texttt{SEC\_NEGOTIATOR\_NEGOTIATION}}
% client-side 
%\index{configuration macro!\texttt{SEC\_DEFAULT\_NEGOTIATION}}
%\index{configuration macro!\texttt{SEC\_CLIENT\_NEGOTIATION}}

The configuration macro names follow a pattern.
Each of the names starts with the string
\MacroNI{SEC\_}.
This string is followed by a string that describes an
authorization or access level.
The authorization levels are
\begin{description}
    \item[DEFAULT]
    \item[READ]
    \item[WRITE]
    \item[ADMIN]
    \item[DAEMON]
    \item[CONFIG]
    \item[OWNER]
    \item[NEGOTIATOR]
    \item[CLIENT]
\end{description}
\MacroNI{DEFAULT} and \MacroNI{CLIENT} 
are not access levels.
The \MacroNI{DEFAULT} is used to define all levels of access
for a specific configuration variable when individual levels
are not specified.
The \MacroNI{CLIENT} is used to define the client's requirements
and preferences in a secure communication.

Still within the name of a configuration macro,
the authorization level is followed by another underscore
character and then a string describing the communication type.
The communication types are
\begin{description}
    \item[AUTHENTICATION]
    \item[ENCRYPTION]
    \item[INTEGRITY]
    %\item[NEGOTIATION]
\end{description}
Two examples of the complete macro names are
\MacroNI{SEC\_ADMIN\_AUTHENTICATION}
and
\MacroNI{SEC\_DEFAULT\_INTEGRITY}.

Each configuration variable would be defined with one
of four predefined values.
The values are
\begin{description}
    \item[REQUIRED]
    \item[PREFERRED]
    \item[OPTIONAL]
    \item[NEVER] 
\end{description}

A daemon uses both the client's configuration for security
and its own configuration
to choose the communication type
(for authentication, encryption, or integrity check).
The following table defines whether or not (Yes or No) the
communication type will be used, or if the interaction cannot
continue (Fail) due to a mismatch in the configuration settings.

\begin{verbatim}
client     daemon       Yes/No/Fail

REQUIRED   REQUIRED       Yes
REQUIRED   PREFERRED      Yes
REQUIRED   OPTIONAL       Yes
REQUIRED   NEVER          Fail

PREFERRED  REQUIRED       Yes
PREFERRED  PREFERRED      Yes
PREFERRED  OPTIONAL       Yes
PREFERRED  NEVER          No

OPTIONAL   REQUIRED       Yes
OPTIONAL   PREFERRED      Yes
OPTIONAL   OPTIONAL       No
OPTIONAL   NEVER          No

NEVER      REQUIRED       Fail
NEVER      PREFERRED      No
NEVER      OPTIONAL       No
NEVER      NEVER          No
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{sec:Security-Authentication} Authentication}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Authentication provides an assurance of an identity.
Through configuration macros, both the client and the daemon
can specify whether authentication is required before communication
is continued.

The client uses one of two macros:
\begin{description}
\item{\Macro{SEC\_DEFAULT\_AUTHENTICATION}}
\item{\Macro{SEC\_CLIENT\_AUTHENTICATION}}
\end{description}

For the daemon, there are eight macros:
\begin{description}
\item{\Macro{SEC\_DEFAULT\_AUTHENTICATION}}
\item{\Macro{SEC\_READ\_AUTHENTICATION}}
\item{\Macro{SEC\_WRITE\_AUTHENTICATION}}
\item{\Macro{SEC\_ADMIN\_AUTHENTICATION}}
\item{\Macro{SEC\_DAEMON\_AUTHENTICATION}}
\item{\Macro{SEC\_CONFIG\_AUTHENTICATION}}
\item{\Macro{SEC\_OWNER\_AUTHENTICATION}}
\item{\Macro{SEC\_NEGOTIATOR\_AUTHENTICATION}}
\end{description}

As an example, the macro defined in the configuration file
for a daemon as
\begin{verbatim}
SEC_WRITE_AUTHENTICATION = REQUIRED
\end{verbatim}
signifies that the daemon must authenticate the client for
any communication that requires the \DCPerm{WRITE} access level.
If the daemon's configuration contains
\begin{verbatim}
SEC_DEFAULT_AUTHENTICATION = REQUIRED
\end{verbatim}
and does not contain any other security configuration for
AUTHENTICATION, then this default defines the daemon's needs
for authentication over all access levels.
Where a specific macro is present, its value takes
precedence over any default given.


If authentication is to be done, then the communicating parties
must find (negotiate) a mutually acceptable method of
authentication to be used.
A list of acceptable methods may be provided by the client, using the
macros
\begin{description}
\item{\Macro{SEC\_DEFAULT\_AUTHENTICATION\_METHODS}}
\item{\Macro{SEC\_CLIENT\_AUTHENTICATION\_METHODS}}
\end{description}
A list of acceptable methods may be provided by the daemon, using the
macros
\begin{description}
\item{\Macro{SEC\_DEFAULT\_AUTHENTICATION\_METHODS}}
\item{\Macro{SEC\_READ\_AUTHENTICATION\_METHODS}}
\item{\Macro{SEC\_WRITE\_AUTHENTICATION\_METHODS}}
\item{\Macro{SEC\_ADMIN\_AUTHENTICATION\_METHODS}}
\item{\Macro{SEC\_DAEMON\_AUTHENTICATION\_METHODS}}
\item{\Macro{SEC\_CONFIG\_AUTHENTICATION\_METHODS}}
\item{\Macro{SEC\_OWNER\_AUTHENTICATION\_METHODS}}
\item{\Macro{SEC\_NEGOTIATOR\_AUTHENTICATION\_METHODS}}
\end{description}
The methods are
given as a comma-separated list of acceptable values.
These variables list the authentication methods that are available
to be used.
The values will be 
\begin{description}
    \item[KERBEROS]
    \item[FS]
    \item[GSS\_AUTHENTICATION]
    \item[CLAIMTOBE]
    \item[ANONYMOUS]
    \item[NTSSPI]
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{sec:Security-Encryption} Encryption}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Encryption makes the messages between communicating parties
difficult to decipher.
Through configuration macros, both the client and the daemon
can specify whether encryption is required for further communication.

The client uses one of two macros:
\begin{description}
\item{\Macro{SEC\_DEFAULT\_ENCRYPTION}}
\item{\Macro{SEC\_CLIENT\_ENCRYPTION}}
\end{description}

For the daemon, there are eight macros:
\begin{description}
\item{\Macro{SEC\_DEFAULT\_ENCRYPTION}}
\item{\Macro{SEC\_READ\_ENCRYPTION}}
\item{\Macro{SEC\_WRITE\_ENCRYPTION}}
\item{\Macro{SEC\_ADMIN\_ENCRYPTION}}
\item{\Macro{SEC\_DAEMON\_ENCRYPTION}}
\item{\Macro{SEC\_CONFIG\_ENCRYPTION}}
\item{\Macro{SEC\_OWNER\_ENCRYPTION}}
\item{\Macro{SEC\_NEGOTIATOR\_ENCRYPTION}}
\end{description}

As an example, the macro defined in the configuration file
for a daemon as
\begin{verbatim}
SEC_DAEMON_ENCRYPTION = REQUIRED
\end{verbatim}
signifies that any daemon to daemon communication must be
encrypted.
If a daemon's configuration contains
\begin{verbatim}
SEC_DEFAULT_ENCRYPTION = REQUIRED
\end{verbatim}
and does not contain any other security configuration for
ENCRYPTION, then this default defines the daemon's needs
for encryption over all access levels.
Where a specific macro is present, its value takes
precedence over any default given.

If encryption is to be done, then the communicating parties
must find (negotiate) a mutually acceptable method of
encryption to be used.
A list of acceptable methods may be provided by the client, using the
macros
\begin{description}
\item{\Macro{SEC\_DEFAULT\_CRYPTO\_METHODS}}
\item{\Macro{SEC\_CLIENT\_CRYPTO\_METHODS}}
\end{description}
A list of acceptable methods may be provided by the daemon, using the
macros
\begin{description}
\item{\Macro{SEC\_DEFAULT\_CRYPTO\_METHODS}}
\item{\Macro{SEC\_READ\_CRYPTO\_METHODS}}
\item{\Macro{SEC\_WRITE\_CRYPTO\_METHODS}}
\item{\Macro{SEC\_ADMIN\_CRYPTO\_METHODS}}
\item{\Macro{SEC\_DAEMON\_CRYPTO\_METHODS}}
\item{\Macro{SEC\_CONFIG\_CRYPTO\_METHODS}}
\item{\Macro{SEC\_OWNER\_CRYPTO\_METHODS}}
\item{\Macro{SEC\_NEGOTIATOR\_CRYPTO\_METHODS}}
\end{description}

The methods are
given as a comma-separated list of acceptable values.
These variables list the encryption methods that are available
to be used.
The values will be 
\begin{description}
    \item[3DES]
    \item[BLOWFISH]
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{sec:Security-Integrity} Integrity Checks}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

An integrity check assures that the messages between communicating parties
have not been tampered with.
Messages changed (such as reordering, bits removed, or bits added)
can be detected.
Through configuration macros, both the client and the daemon
can specify whether an integrity check is required of further communication.

The client uses one of two macros:
\begin{description}
\item{\Macro{SEC\_DEFAULT\_INTEGRITY}}
\item{\Macro{SEC\_CLIENT\_INTEGRITY}}
\end{description}

For the daemon, there are eight macros:
\begin{description}
\item{\Macro{SEC\_DEFAULT\_INTEGRITY}}
\item{\Macro{SEC\_READ\_INTEGRITY}}
\item{\Macro{SEC\_WRITE\_INTEGRITY}}
\item{\Macro{SEC\_ADMIN\_INTEGRITY}}
\item{\Macro{SEC\_DAEMON\_INTEGRITY}}
\item{\Macro{SEC\_CONFIG\_INTEGRITY}}
\item{\Macro{SEC\_OWNER\_INTEGRITY}}
\item{\Macro{SEC\_NEGOTIATOR\_INTEGRITY}}
\end{description}

As an example, the macro defined in the configuration file
for a daemon as
\begin{verbatim}
SEC_DAEMON_INTEGRITY = REQUIRED
\end{verbatim}
signifies that any daemon to daemon communication must
have its integrity assured.
If a daemon's configuration contains
\begin{verbatim}
SEC_DEFAULT_INTEGRITY = REQUIRED
\end{verbatim}
and does not contain any other security configuration for
INTEGRITY, then this default defines the daemon's needs
for integrity checks over all access levels.
Where a specific macro is present, its value takes
precedence over any default given.

There is currently only one method used for integrity checking:
a signed MD5 checksum.
Its use is implied whenever integrity checks occur.
If more methods are implemented, then there will be further
macros to allow both the client and the daemon to specify
which methods are acceptable.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{sec:Security-sample1} Example Daemon-Side Security Configuration}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A configuration file is provided when Condor is installed.
No security features are enabled within the configuration as
distributed.
Included in the configuration file is an example setting
that enables security.
Here is the daemon-side portion of the configuration file.

% from Zach
\begin{verbatim}
SEC_DEFAULT_AUTHENTICATION=REQUIRED
SEC_DEFAULT_ENCRYPTION=REQUIRED
SEC_DEFAULT_INTEGRITY=REQUIRED

SEC_DEFAULT_AUTHENTICATION_METHODS = KERBEROS
SEC_DEFAULT_CRYPTO_METHODS = 3DES

KERBEROS_MAP_FILE = /path/to/etc/condor.kmap

\end{verbatim}

This set of configuration macros forces all security features
to be used at all times.
All communication is authenticated (using Kerberos),
and all communication is both encrypted and has its
integrity checked to make sure that messages
are not modified or corrupted (using triple DES).

This configuration requires that all Condor daemons be
version 6.3.3 or later, since previous versions will not have
the ability to do secure communication.

The configuration variable
\Macro{KERBEROS\_MAP\_FILE}
defines a path to an administrator-maintained file that
contains Kerberos domain (called a realm) to Condor UID domain mapping.
Lines within this map file have the syntax
\begin{verbatim}
   FromDomain = ToDomain
\end{verbatim}
If no map file is specified, then Condor assumes that the
Kerberos realm is the same as the Condor UID domain.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\label{sec:Security-Authorization} Authorization}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Independent of other security checks, authorization defines
who is allowed to do what.

Authorization is defined in terms of users (the effective UID
of an executing program).
A previous, first-pass implementation did authorization
based on hosts (machines).
Section~\ref{sec:Host-Security}
on Setting Up IP/Host-Based Security in Condor describes the
implementation.
The IP/Host-Based security still exists, and it can be used,
but significantly stronger security is achieved with the newer
authorization based on fully qualified user names.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{sec:Security-UserAuthorization}User-based Authorization}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The authorization portion of the security of a Condor pool is
based on a set of configuration
macros that list which user/daemon may be allowed to issue what request.

These configuration variables define a set of users that will be
allowed to (or denied from) carrying out various Condor commands.
Each access level may have its own list of authorized users.
A complete list of the authorization macros:
\begin{description}
\item{\Macro{ALLOW\_READ}}
\item{\Macro{ALLOW\_WRITE}}
\item{\Macro{ALLOW\_ADMINISTRATOR}}
\item{\Macro{ALLOW\_CONFIG}}
\item{\Macro{ALLOW\_DAEMON}}
\item{\Macro{ALLOW\_OWNER}}
\item{\Macro{ALLOW\_NEGOTIATOR}}
\item{\Macro{DENY\_READ}}
\item{\Macro{DENY\_WRITE}}
\item{\Macro{DENY\_ADMINISTRATOR}}
\item{\Macro{DENY\_CONFIG}}
\item{\Macro{DENY\_DAEMON}}
\item{\Macro{DENY\_OWNER}}
\item{\Macro{DENY\_NEGOTIATOR}}
\end{description}

%Need description here about whether allow or deny takes precedence.

Each macro is defined by a comma-separated list of fully qualified
users.
Each
fully qualified user
is described using the following format:
\begin{verbatim}
username@domain/hostname
\end{verbatim}
The information to the left of the slash character describes
a user within a domain.
The information to the right of the slash character describes
a machine from which the user would be issuing a command. 
An example is
\begin{verbatim}
zmiller@cs.wisc.edu/bird.cs.wisc.edu
\end{verbatim}

Within the format, wildcard characters (the asterisk, *) are allowed.
The use of wildcards is limited to one wildcard on either side
of the slash character.
For example,
\begin{verbatim}
*@cs.wisc.edu/bird.cs.wisc.edu
\end{verbatim}
refers to any user that comes from \verb@cs.wisc.edu@,
where the command is originating from the machine
\verb@bird.cs.wisc.edu@.
Another example,
\begin{verbatim}
zmiller@cs.wisc.edu/*.cs.wisc.edu
\end{verbatim}
refers to commands coming from any machine within the 
\verb@cs.wisc.edu@ domain, and issued by \verb@zmiller@.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{sec:Security-sample2} Example User-Side Security Configuration}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Todo

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{sec:Host-Security}Setting Up IP/Host-Based Security in
Condor} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This section describes the mechanisms for setting up Condor's
host-based security.  
This is now an outdated form of implementing security at
the level of machine access. 
It remains available and documented for purposes of backward compatibility.

The host-based security allows control over what machines can
join a Condor pool, what machines can find out information about
your pool, and what machines within your pool can perform
administrative commands.  By default, Condor is configured to allow
anyone to view or join your pool.  You probably want to change that.

This section discusses how the host-based security works inside Condor.
It lists the different levels of access and what
parts of Condor use which levels.
There is a description of how to configure
your pool to grant (or deny) certain levels of access to various
machines.
Configuration examples and the settings of configuration variables
using the \Condor{config\_val} command complete this section.

Inside the Condor daemons or tools that use DaemonCore (see
section~\ref{sec:DaemonCore} for details), most
things are accomplished by sending commands to another Condor daemon.
These commands are formed from an integer to specify which command,
followed
by any optional information that the protocol requires at that point
(such as a ClassAd, capability string, etc).
When the daemons start up,
they register which commands they are willing to accept, what to
do with arriving commands, and the access level required for
that command.
When a command arrives, Condor identifies the  access level
required, and checks the IP address of the sender to be
sure it passes the various allow/deny settings
in the configuration file for the given access level.
If permission is granted, the command continues. 
If not, the command is aborted.
%% What does it mean for a command to be aborted?  Is it just
%% thrown away (ignored), or is a reply sent indicating failure?

As expected, settings for the access levels in the global
configuration file affect all the machines in the pool.
Settings in a local configuration file only affect the specific machine.
The settings for a given machine determine what other hosts can send
commands to that machine.
So, if machine foo is to be given 
administrator access on machine bar, place foo in
bar's configuration file access list (not the other way around).


The following are the various access levels that commands within
Condor can be registered with:

\begin{description}

\item[\DCPerm{READ}] \label{dcperm:read} Machines with \DCPerm{READ}
   access can read information from Condor.  For example, they can
   view the status of the pool, see the job queue(s) or view user
   permissions.  \DCPerm{READ} access does not allow a machine to
   change anything, and it does not allow
   job submission. A machine listed
   with \DCPerm{READ} permission cannot join a Condor pool; the machine can
   only view information about the pool.

\item[\DCPerm{WRITE}] \label{dcperm:write} Machines with
   \DCPerm{WRITE} access can write information to Condor.
   Most notably, a machine can join a pool by sending ClassAd
   updates to the central manager. 
   The machine can talk to the other machines
   in a pool in order to submit or run jobs.
   In addition, any machine with
   \DCPerm{WRITE} access can request the \Condor{startd} daemon to perform a
   periodic checkpoint on a currently executing job. After a
   periodic checkpoint, the job will continue to execute, and the
   machine will still be claimed by whatever \Condor{schedd} daemon had claimed it.
   This allows users on the machines where they submitted their jobs
   to use the \Condor{checkpoint} command to get their jobs to
   periodically checkpoint, even if the users do not have an account on the
   machine where the jobs execute.

   \textbf{IMPORTANT:} For a machine to join a Condor pool, the machine must
   have both \DCPerm{WRITE} permission \textbf{AND} \DCPerm{READ} permission.
   \DCPerm{WRITE} permission is not enough.

\item[\DCPerm{ADMINISTRATOR}] \label{dcperm:administrator} Machines
   with \DCPerm{ADMINISTRATOR} access have additional Condor
   administrator rights to the pool.  This includes the ability to
   change user priorities (with the command \Code{userprio -set}),
   and the ability to turn Condor on and off
   (with the command \Code{off \Sinful{machine}}).
   Typically, very few
   machines are in this list, perhaps only the workstations where the
   Condor administrators or system administrators work,
   or perhaps only the pool's central manager.

   \textbf{IMPORTANT:} This access is given to a machine,
   and it applies to an entire pool.
   So, \DCPerm{ADMINISTRATOR} access for a given machine provides
   \textbf{ANY USER} on that machine \DCPerm{ADMINISTRATOR}
   rights (including users who can run Condor jobs on that machine).
   Therefore, grant \DCPerm{ADMINISTRATOR} access carefully.

\item[\DCPerm{OWNER}] \label{dcperm:owner} This level of access is
   required for commands that the owner of a machine (any local user)
   should be able to use, in addition to the Condor administrators.
   For example, the \Condor{vacate} command causes the
   \Condor{startd} daemon to vacate any running Condor job.
   It requires \DCPerm{OWNER} permission,
   so that any user logged into a local machine
   can issue a \Condor{vacate} command.

\item[\DCPerm{NEGOTIATOR}] \label{dcperm:negotiator} This 
   access level is used specifically to verify that commands are
   sent by the \Condor{negotiator} daemon.
   The \Condor{negotiator} daemon runs on the central manager of
   the pool.
   Commands requiring this access
   level are the ones that tell the \Condor{schedd} daemon to begin
   negotiating, and those that tell an available \Condor{startd} daemon
   that it has been matched to a \Condor{schedd} with jobs to run.

\item[\DCPerm{CONFIG}] \label{dcperm:config} This access level is
   required to modify a daemon's configuration using
   the \Condor{config\_val} command.
   By default, machines with this level of access are able 
   to change any configuration parameters, except those specified in
   the \File{condor\_config.root} configuration file.
   Therefore, granting this level of host-wide access requires
   extreme caution.
   By default, \DCPerm{CONFIG} access is denied for all hosts.

   Starting with version 6.3.2, Condor provides a mechanism for more
   fine-grained control over the configuration settings that can be
   modified remotely with \Condor{config\_val}.  
   Please see section~\ref{sec:Config-Val-Security} below on Host
   Security for \Condor{config\_val}.

\end{description}

Host-based security access
permissions are specified in configuration files.

\DCPerm{ADMINISTRATOR} and \DCPerm{NEGOTIATOR} access default to 
the central manager machine.
\DCPerm{OWNER} access defaults to the local machine, as well as
any machines
given with \DCPerm{ADMINISTRATOR} access.
\DCPerm{CONFIG} access is not granted to any machine
as its default.
These defaults work well, and should not be changed without
a compelling reason.
If machines other than the default are to have to have \DCPerm{OWNER}
access, they probably should also have \DCPerm{ADMINISTRATOR} access.
By granting machines \DCPerm{ADMINISTRATOR} access, they
will automatically have \DCPerm{OWNER} access, given how
\DCPerm{OWNER} access is set within the configuration.

The default access configuration is
\begin{verbatim}
HOSTALLOW_ADMINISTRATOR = $(CONDOR_HOST)
HOSTALLOW_OWNER = $(FULL_HOSTNAME), $(HOSTALLOW_ADMINISTRATOR)
HOSTALLOW_READ = *
HOSTALLOW_WRITE = *
HOSTALLOW_NEGOTIATOR = $(NEGOTIATOR_HOST)
HOSTALLOW_NEGOTIATOR_SCHEDD = $(NEGOTIATOR_HOST), $(FLOCK_NEGOTIATOR_HOSTS)
HOSTALLOW_WRITE_COLLECTOR = $(HOSTALLOW_WRITE), $(FLOCK_FROM)
HOSTALLOW_WRITE_STARTD    = $(HOSTALLOW_WRITE), $(FLOCK_FROM)
HOSTALLOW_READ_COLLECTOR  = $(HOSTALLOW_READ), $(FLOCK_FROM)
HOSTALLOW_READ_STARTD     = $(HOSTALLOW_READ), $(FLOCK_FROM)
\end{verbatim}

For each access level, an ALLOW or a DENY may be added.
\begin{itemize}

\item If you have an ALLOW, it means "only allow these machines".  No
    ALLOW means allow anyone.

\item If you have a DENY, it means "deny these machines".  No DENY
    means to deny nobody.

\item If you have both an ALLOW and a DENY, it means allow the
    machines listed in ALLOW except for the machines listed in DENY.

\item Exclusively for the \DCPerm{CONFIG} access,
    no ALLOW means allow no one.
    Note that this is different than the other ALLOW configurations.
    It is different to enable more stringent security where
    older configurations are used, since
    older configuration files would not have a 
    \DCPerm{CONFIG} configuration entry.
\end{itemize}

Multiple machine entries
in the configuration files
may be separated by either a space or a comma.
The machines may be listed by

\begin{itemize}
\item Individual host names - for example: condor.cs.wisc.edu
\item Individual IP address - for example: 128.105.67.29
\item IP subnets (use a trailing ``*'') - for example: 144.105.*, 128.105.67.*
\item Host names with a wildcard ``*'' character (only one ``*'' is
    allowed per name) - for example: *.cs.wisc.edu, sol*.cs.wisc.edu
\end{itemize}

To resolve an entry that falls into both allow and deny:
individual
machines have a higher order of precedence than wildcard entries, and
host names with a wildcard have a higher order of precedence than IP
subnets.
Otherwise, DENY has a higher order of precedence than ALLOW.
(this is how most people would intuitively expect it to work).  

In addition, the above access levels may be specified on a
per-daemon basis, instead of machine-wide for all daemons.
Do this with the subsystem string (described in
section~\ref{sec:Condor-Subsystem-Names} on Subsystem Names),
which is one of: STARTD, SCHEDD, MASTER, NEGOTIATOR,
or COLLECTOR.
For example, to grant different read access for the \Condor{schedd}:
\begin{verbatim}
        HOSTALLOW_READ_SCHEDD = <list of machines>
\end{verbatim}

The following is a list of registered commands that daemons will
accept.  The list is ordered by daemon.
For each daemon, the commands are grouped by the access level
required for a daemon to accept the command from a
given machine.

ALL DAEMONS:

\begin{description}
\item[\DCPerm{WRITE}]

  The command sent as a result of \Condor{reconfig} to reconfigure a daemon.

\item[\DCPerm{ADMINISTRATOR}]

  The command sent as a result of \Code{reconfig -full}
  to perform a full reconfiguration on a daemon. 
\end{description}

STARTD:

\begin{description}
\item[\DCPerm{WRITE}] 

All commands that relate to a \Condor{schedd} daemon claiming
  a machine, starting jobs there, or stopping those jobs.

The command that \Condor{checkpoint} sends to periodically checkpoint
  all running jobs.

\item[\DCPerm{READ}]

The command that \Condor{preen} sends to request the
  current state of the \Condor{startd} daemon.

\item[\DCPerm{OWNER}]
The command that \Condor{vacate} sends to cause
  any running jobs to stop running.

\item[\DCPerm{NEGOTIATOR}]
The command that the \Condor{negotiator} daemon sends to
  match a machine's \Condor{startd} daemon with a given \Condor{schedd}
  daemon.
\end{description}

NEGOTIATOR:

\begin{description}
\item[\DCPerm{WRITE}]
The command that initiates a new negotiation
  cycle. It is sent by the \Condor{schedd} when new jobs are submitted
  or a \Condor{reschedule} command is issued.

\item[\DCPerm{READ}]
The command that can retrieve the current state
  of user priorities in the pool (sent by the \Condor{userprio} command).

\item[\DCPerm{ADMINISTRATOR}]
The command that can set the current
  values of user priorities (sent as a result of the \Code{userprio -set}
  command).
\end{description}

COLLECTOR:

\begin{description}
\item[\DCPerm{WRITE}]
All commands that update the \Condor{collector} daemon with new ClassAds.

\item[\DCPerm{READ}]
All commands that query the \Condor{collector} daemon for ClassAds.
\end{description}

SCHEDD: 

\begin{description}
\item[\DCPerm{NEGOTIATOR}]
The command that the \Condor{negotiator} sends to
  begin negotiating with this \Condor{schedd} to match its jobs with available
  \Condor{startds}.

\item[\DCPerm{WRITE}]
The command which \Condor{reschedule} sends to
  the \Condor{schedd} to get it to update the \Condor{collector} with a current ClassAd
  and begin a negotiation cycle.

  The commands that a \Condor{startd} sends to the \Condor{schedd} when it must vacate
  its jobs and release the \Condor{schedd's} claim.

  The commands which write information into the job queue (such as
  \Condor{submit} and \Condor{hold}).  
  Note that for most commands which attempt to write to the job queue, Condor
  will perform an additional user-level authentication step.  
  This additional user-level authentication prevents, for example, an
  ordinary user from removing a different user's jobs.

\item[\DCPerm{READ}]
The command from any
  tool to view the status of the job queue.  
\end{description}

MASTER:  All commands are registered with \DCPerm{ADMINISTRATOR}
access:

\begin{description}
\item[restart] : Master restarts itself (and all its children)	
\item[off] : Master shuts down all its children
\item[off -master] : Master shuts down all its children and exits
\item[on] : Master spawns all the daemons it is configured to spawn
\end{description}


This section provides examples of configuration settings.
Notice that \DCPerm{ADMINISTRATOR} access is
only granted through a HOSTALLOW setting to explicitly grant access to
a small number of machines.  We recommend this.

\begin{itemize}

\item Let any machine join your pool.
Only the central manager has
administrative access (this is the default that ships with Condor)
\begin{verbatim}
HOSTALLOW_ADMINISTRATOR = $(CONDOR_HOST)
HOSTALLOW_OWNER = $(FULL_HOSTNAME), $(HOSTALLOW_ADMINISTRATOR)
\end{verbatim}

\item Only allow machines at NCSA to join or view the pool.
The central manager is the only machine with \DCPerm{ADMINISTRATOR} access.
\begin{verbatim}
HOSTALLOW_READ = *.ncsa.uiuc.edu
HOSTALLOW_WRITE = *.ncsa.uiuc.edu
HOSTALLOW_ADMINISTRATOR = $(CONDOR_HOST)
HOSTALLOW_OWNER = $(FULL_HOSTNAME), $(HOSTALLOW_ADMINISTRATOR)
\end{verbatim}

\item Only allow machines at NCSA and the U of I Math department join the
pool, EXCEPT do \textbf{not} allow lab machines to do so.
Also, do not
allow the 177.55 subnet (perhaps this is the dial-in subnet).
Allow anyone to view pool statistics.  The machine named
bigcheese administers the pool (not the central manager).
\begin{verbatim}
HOSTALLOW_WRITE = *.ncsa.uiuc.edu, *.math.uiuc.edu
HOSTDENY_WRITE = lab-*.edu, *.lab.uiuc.edu, 177.55.*
HOSTALLOW_ADMINISTRATOR = bigcheese.ncsa.uiuc.edu
HOSTALLOW_OWNER = $(FULL_HOSTNAME), $(HOSTALLOW_ADMINISTRATOR)
\end{verbatim}

\item Only allow machines at NCSA and UW-Madison's CS department to
view the pool.  Only NCSA machines and the machine raven.cs.wisc.edu can join
the pool.
(Note: the machine raven has the read access it needs through the
wildcard setting in \Macro{HOSTALLOW\_READ}).
This example also shows
how to use ``\verb@\@'' to continue a long list of machines
onto multiple lines, making it more readable (this works for all
configuration file entries, not just host access entries)
\begin{verbatim}
HOSTALLOW_READ = *.ncsa.uiuc.edu, *.cs.wisc.edu
HOSTALLOW_WRITE = *.ncsa.uiuc.edu, raven.cs.wisc.edu
HOSTALLOW_ADMINISTRATOR = $(CONDOR_HOST), bigcheese.ncsa.uiuc.edu, \
                          biggercheese.uiuc.edu
HOSTALLOW_OWNER = $(FULL_HOSTNAME), $(HOSTALLOW_ADMINISTRATOR)
\end{verbatim}

\item Allow anyone except the military to view the status of the
pool, but only let machines at NCSA view the job queues.
Only NCSA machines can join the pool.
The central manager, bigcheese, and
biggercheese can perform most administrative functions.
However, only biggercheese can update user priorities.
\begin{verbatim}
HOSTDENY_READ = *.mil
HOSTALLOW_READ_SCHEDD = *.ncsa.uiuc.edu 
HOSTALLOW_WRITE = *.ncsa.uiuc.edu
HOSTALLOW_ADMINISTRATOR = $(CONDOR_HOST), bigcheese.ncsa.uiuc.edu, \
                          biggercheese.uiuc.edu
HOSTALLOW_ADMINISTRATOR_NEGOTIATOR = biggercheese.uiuc.edu
HOSTALLOW_OWNER = $(FULL_HOSTNAME), $(HOSTALLOW_ADMINISTRATOR)
\end{verbatim}

\end{itemize}

A new security feature introduced in
Condor version 6.3.2 enables more fine-grained control over the
configuration settings that can be modified remotely with the
\Condor{config\_val} command.
The manual page for \Condor{config\_val} on
page~\pageref{man-condor-config-val} details how to use 
\Condor{config\_val} to modify configuration settings remotely. 
Since certain configuration attributes can have a large impact on the 
functioning of the Condor system and the security of the machines in a
Condor pool, it is important to restrict the ability to change
attributes remotely.

For each security access level described,
the Condor
administrator can define which configuration settings a host at that
access level is allowed to change.
Optionally, the administrator can define separate lists of settable
attributes for each Condor daemon, or the administrator
can define one list that is used by all daemons.

For each command that requests a change in configuration setting,
Condor searches all the different possible security access
levels to see which, if any, the request satisfies.
(Some hosts can qualify for multiple access levels. For example, any
host with \DCPerm{ADMINISTRATOR} permission probably has
\DCPerm{WRITE} permission also).
Within the qualified access level,
Condor searches for the list of attributes that may be modified.
If the request is covered by the list,
the request will be granted.
If not covered, the request will be refused.

The default configuration shipped with Condor is exceedingly
restrictive.
Condor users or administrators cannot set
configuration values from remote hosts with \Condor{config\_val}.
Enabling this feature requires a change to the
settings in the configuration file.
Use this security feature carefully.
Grant access only for attributes which you need to be able to modify
in this manner, and grant access only at the most restrictive
security level possible.

The most secure use of this feature allows Condor users to set
attributes in the configuration file which are not used by Condor
directly.
These are custom attributes published by various Condor
daemons with the \Macro{SUBSYS\_EXPRS} setting described in
section~\ref{param:SubsysExprs} on page~\pageref{param:SubsysExprs}.
It is secure to grant access only to modify attributes that are used by Condor
to publish information.
Granting access to modify
settings used to control the behavior of Condor is
not secure.
The goal is to
ensure no
one can use the power to change configuration attributes to compromise 
the security of your Condor pool.

The control lists are defined by configuration settings that contain 
\Macro{SETTABLE\_ATTRS} in their name.
The name of the control lists have the following form: 

\begin{verbatim}
SUBSYS_SETTABLE_ATTRS_PERMISSION-LEVEL
\end{verbatim}

The two parts of this name that can vary are
PERMISSION-LEVEL and the SUBSYS.
The PERMISSON-LEVEL can be any of the security access levels
described earlier in this section.
Examples include \DCPerm{WRITE}, \DCPerm{OWNER}, and \DCPerm{CONFIG}.

The SUBSYS is an optional portion of the name. 
It can be used to
define separate rules for which configuration attributes can be set
for each kind of Condor daemon (for example, STARTD, SCHEDD, MASTER).
There are many configuration settings that can be defined differently
for each daemon that use this SUBSYS naming convention.
See section~\ref{sec:Condor-Subsystem-Names} on
page~\pageref{sec:Condor-Subsystem-Names} for a list.
If there is no daemon-specific value for a given daemon, Condor will
look for \Macro{SETTABLE\_ATTRS\_PERMISSION-LEVEL}.

Each control list is defined by a comma-separated list of attribute
names which should be allowed to be modified.
The lists can contain wildcards characters (`*'). 

Some examples of valid definitions of control lists with explanations:

\begin{itemize}

\item \begin{verbatim}SETTABLE_ATTRS_CONFIG = *\end{verbatim}
Grant unlimited access to modify configuration attributes
to any request that came from a machine in the \DCPerm{CONFIG} access
level. 
This was the default behavior before Condor version 6.3.2.

\item \begin{verbatim}SETTABLE_ATTRS_ADMINISTRATOR = *_DEBUG, MAX_*_LOG\end{verbatim} 
Grant access to change any configuration setting that ended
with ``\_DEBUG'' (for example, \Macro{STARTD\_DEBUG}) and any
attribute that matched ``MAX\_*\_LOG'' (for example,
\Macro{MAX\_SCHEDD\_LOG}) to any host with \DCPerm{ADMINISTRATOR}
access. 

\item \begin{verbatim}STARTD_SETTABLE_ATTRS_OWNER = HasDataSet\end{verbatim}
Allows any request to modify the \Macro{HasDataSet} 
attribute that came from a host with \DCPerm{OWNER} access.
By default, \DCPerm{OWNER} covers any request originating from the
local host, plus any machines listed in the \DCPerm{ADMINISTRATOR}
level.
Therefore, any Condor job would qualify for OWNER access to the
machine where it is running. 
So, this setting would allow any process running on a given host,
including a Condor job, to modify the \Macro{HasDataSet} variable for
that host. 
\Macro{HasDataSet} is not used by Condor, it is an invented attribute
included in the \Macro{STARTD\_EXPRS} setting in order for this
example to make sense.

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\label{sec:Authentication}Authentication}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Todo

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\label{sec:X509-Authentication}X.509 Authentication}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Todo
% the X509 map file
% Note that at the end of each line is the mapped to userid (eg. condor@cs.wisc.edu)

%V	020406001927Z		01	unknown	/C=US/O=Condor/O=University of Wisconsin/OU=Computer Sciences Department/CN=condor@cs.wisc.edu	condor@cs.wisc.edu
%V	020406002049Z		02	unknown	/C=US/O=Condor/O=University of Wisconsin/OU=Computer Sciences Department/CN=hbwang@cs.wisc.edu	hbwang@cs.wisc.edu
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\label{sec:X509-Authentication}Kerberos Authentication}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Todo

