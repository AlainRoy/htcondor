%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\label{sec:Security}Security In Condor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\index{security! in Condor|(}

This section describes various aspects of security within Condor.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\label{sec:uids}UIDs in Condor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{UIDs in Condor|(}

On a Unix system,
UIDs (User IDentification numbers) form part of an operating system's
tools for maintaining access control.
Each executing program has a UID,
a unique identifier of a user executing the program.
This is also called the real UID.
\index{UID!real}
A common situation has one user executing the program owned
by another user.
Many system commands work this way, with a user (corresponding
to a person) executing a program belonging to (owned by) root.
Since the program may require privileges that root has which
the user does not have, a special bit in the program's
protection specification (a setuid bit) allows the program
to run with the UID of the program's owner, instead of the
user that executes the program.
This UID of the program's owner is called an effective UID.
\index{UID!effective}

%GID (group identification)
Condor works most smoothly when its daemons run as root.
The daemons then have the ability to switch their 
effective UIDs at will.
When the daemons run as root,
they normally leave their effective UID and GID (Group IDentification)
to be those of user and group condor.
This allows access to the log files without
changing the ownership of the log files.
It also allows access to these files when
the user condor's home directory resides on an NFS server.
root can not normally access NFS files.

On a machine where a job is submitted,
the \Condor{schedd} daemon
changes its effective UID to root
such that it has the capability to start up a \Condor{shadow} daemon
for the job.
Before a \Condor{shadow} daemon is created,
the \Condor{schedd} daemon
switches back to root,
so that it can start up the \Condor{shadow} daemon with the (real) UID
of the user who submitted the job.
Since the \Condor{shadow} runs as the owner of the job,
all remote system calls are performed under the owner's UID
and GID.
This ensures that as the job executes,
it can access only files that its owner could access if the job
were running locally, without Condor.
On the machine where the job executes, the 
job runs as user nobody, to help ensure that the job cannot access
local resources or do harm.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{sec:norootaccess}What if Condor is not run as root?}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Condor can also function on all platforms by starting up as
user condor.  Since user condor does not have the ability to switch
UID or GID, all daemons run with both the UID and GID belonging
to user condor.
The \Condor{shadow} daemon and the job's executable also
run as user condor.
This has the effect that
the job can access only the files and directories that are
accessible to the user condor on the machine where the job
was submitted.
Owners of
jobs must make their input readable to the user condor.
A job's output must be placed in a directory that is writable by
the user condor as well.
In practice, this means creating
world-writable directories for output from Condor jobs.
This creates a potential security risk,
in that any user on the machine where the job is submitted
can alter the data, remove it, or do other undesirable things.
It is acceptable in an environment where users can trust other users.

On platforms where root access is not needed,
Condor can even function without a UID or GID of the user condor.
A directory to act as the condor home directory is still required,
containing the configuration files, spool,
execute and log directories.
This home directory is not technically the
home directory of any user.
In this case, a user condor may or may not even exist,
but the directory is still referred to as the condor home
directory.
If the user condor does not exist,
use the CONDOR\_CONFIG environment variable such
that all Condor daemons and tools
can find their configuration file
(which in turn defines the
locations of other needed files and directories),
or place a configuration file in \File{/etc/condor/condor\_config}.
The Condor daemons can then be started up by whatever UID and GID has
access to the local \File{condor} directory.
Normally, users without root
access who wish to use Condor on their machines create a
\File{condor} home directory somewhere within their own accounts
and start up the daemons (to run with the UID of the user).
As in the case where the daemons run as user condor,
there is no ability to switch UIDs or GIDs.
The daemons run as the UID and GID of the user who started them.
On a machine where jobs are submitted, the \Condor{shadow} daemons
all run as this same user.
However, if other users on the machine are using Condor in this
environment, the \Condor{shadow} daemons for these other users'
jobs execute with the UID of the user who started the daemons.
This is a security risk, since the Condor job of the other user
has access to all the files and directories of the user
who started the daemons.
Some installations have this level of trust,
but others do not.
Where this level of trust does not exist, it is best to set up a
condor account and group, or to have each user start up their own
Personal Condor submit installation.

When a machine is an execution site for a Condor job,
the Condor job executes with the UID of the user who started the
\Condor{startd} daemon.
This is also potentially a security risk, which is why we do not
recommend starting up the execution site daemons as a regular user.
Use either root or a user (such as the user condor) that 
exists only to run Condor jobs.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{sec:DirOfJob}What directory does a job run in?}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Any executing process has a notion of its current working
directory (cwd),
the directory that acts as the base for all file system access.
There are two sides to any Condor job:
the submit side and the execution side.
This implies that there are two cwds.
On the submit side, the owner's cwd sets
a default cwd as a job is submitted.
The cwd can be changed with a command in the submit description file.
Since many jobs can be submitted at the same time,
the commands are flexible in order to set the cwd individually for
each job if desired.
This submit side cwd remains for the entire life of a job.
The submit side cwd is also used as the cwd of the \Condor{shadow} daemon.
Since file system access for the job goes through the \Condor{shadow}
daemon,
all accesses behave as if they were executing without Condor.

There is also a cwd associated with the Condor job on the execution machine.
It is set to the \File{execute} subdirectory of Condor's home directory.
This directory is world-writable, since a Condor job usually runs as user
nobody.
Normally, the executable would never access this directory,
since all I/O system calls are passed back to the \Condor{shadow} daemon
on the submit machine.
However, in the event that the job that creates a core dump,
the cwd on the execute machine needs to be accessible by
the job so that it can write the core file.
The core file is moved back to the submit machine,
and the \Condor{shadow} daemon is informed.
The \Condor{shadow} daemon sends e-mail to the job owner announcing the
crash and providing a pointer to the core file, then residing
in the submit side cwd.

\index{UIDs in Condor|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\label{sec:Non-Root}Running Condor as Non-Root}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

While we strongly recommend starting up the Condor daemons as root, we
understand that it is not always possible to do so.
The main problems appear
if you have one Condor installation shared by many users
on a single machine, or if you are setting up machines to only
execute Condor jobs.
If you are setting up a submit-only installation for
a single user, then there is no need for (or benefit from) running as
root.  

What follows are the effects on the various parts of Condor
of running both with and without root access.

\begin{description}

\item[\Condor{startd}] If you're setting up a machine to run Condor
   jobs and don't start the \Condor{startd} as root, you're basically
   relying on the goodwill of your Condor users to agree to the policy
   you configure the startd to enforce as far as starting, suspending,
   vacating and killing Condor jobs under certain conditions.  If you
   run as root, however, you can enforce these policies regardless of
   malicious users.  By running as root, the Condor daemons run with a
   different UID than the Condor job that gets started (since the
   user's job is started as either the UID of the user who submitted
   it, or as user ``nobody'', depending on the \Macro{UID\_DOMAIN}
   settings).  Therefore, the Condor job cannot do anything to the
   Condor daemons.  If you don't start the daemons as root, all
   processes started by Condor, including the end user's job, run with
   the same UID (since you can't switch UIDs unless you're root).
   Therefore, a user's job could just kill the \Condor{startd} and
   \Condor{starter} as soon as it starts up and by doing so, avoid
   getting suspended or vacated when a user comes back to the machine.
   This is nice for the user, since they get unlimited access to the
   machine, but awful for the machine owner or administrator.  If you
   trust the users submitting jobs to Condor, this might not be a
   concern.  However, to ensure that the policy you choose is
   effectively enforced by Condor, the \Condor{startd} should be
   started as root.

   In addition, some system information cannot be obtained without
   root access on some platforms (such as load average on IRIX).  As a
   result, when running without root access, the \Condor{startd} has to
   call other programs (for example, ``uptime'') to get this
   information.  This is much less efficient than getting the
   information directly from the kernel (which is what we do if we're
   running as root).  On Linux and Solaris, we can get this
   information directly without root access, so this is not a concern
   on those platforms.

   If you can't have all of Condor running as root, at least consider
   whether you can install the \Condor{startd} as setuid root.  That
   would solve both of these problems.  If you can't do that, you
   could also install it as a setgid sys or kmem program (depending on
   whatever group has read access to \File{/dev/kmem} on your system)
   and that would at least solve the system information problem.

\item[\Condor{schedd}] The biggest problem running the schedd
    without root access is that the \Condor{shadow} processes which it
    spawns are stuck with the same UID the \Condor{schedd} has.  This
    means that users submitting their jobs have to go out of their way
    to grant write access to user or group condor (or whoever the
    schedd is running as) for any files or directories their jobs
    write or create.  Similarly, read access must be granted to their
    input files.

    You might consider installing \Condor{submit} as a setgid condor
    program so that at least the \File{stdout}, \File{stderr} and
    \File{UserLog} files get created with the right permissions.  If
    \Condor{submit} is a setgid program, it will automatically set
    it's umask to 002, so that creates group-writable files.  This
    way, the simple case of a job that just writes to \File{stdout}
    and \File{stderr} will work.  If users have programs that open
    their own files, they'll have to know to set the right permissions
    on the directories they submit from.

\item[\Condor{master}] The \Condor{master} is what spawns the
    \Condor{startd} and \Condor{schedd}, so if want them both running
    as root, you should have the master run as root.  This happens
    automatically if you start the master from your boot scripts.

\item[\Condor{negotiator}]
\item[\Condor{collector}] There is no need to have either of these
daemons running as root.

\item[\Condor{kbdd}] On platforms that need the \Condor{kbdd} (Digital
    Unix and IRIX) the \Condor{kbdd} has to run as root.  If it is
    started as any other user, it will not work.  You might consider
    installing this program as a setuid root binary if you can't run
    the \Condor{master} as root.  Without the \Condor{kbdd}, the
    startd has no way to monitor mouse activity at all, and the only
    keyboard activity it will notice is activity on ttys (such as
    xterms, remote logins, etc).

\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\label{sec:Config-Security} Security Configuration}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Condor provides support for strong authentication,
encryption, integrity assurance, as well as authorization.
Most of these security features are not visible to the user
(one who submits jobs).
They are enabled by site administrators through the use of
configuration macros.
This section describes the authentication, encryption,
integrity assurance, as well as authorization configuration
macros provided by Condor.

Authentication provides an assurance of the identity of one of the
communicating parties.
Mutual authentication provides an assurance of the identities of
both of the communicating parties.
Encoding information such that its contents is not easily
decipherable by outsiders is called encryption.
The integrity of a message is assured when any form of
tampering with the message can be detected. 
With integrity support,
nothing in the message can be added, deleted, or modified
without being detected.

When Condor is installed, default configuration settings
use no authentication, encryption, or integrity checks,
nor are authorization checks provided.
This allows newer versions of Condor with
security features to work or interact
with previous versions without security support.
An administrator must modify the configuration settings to
enable the security features.

Inside Condor, daemons need to communicate with each other;
furthermore, various tools provided by Condor may also
require communication with Condor daemons.
All these communications can be made more secure
through the proper usage of authentication, encryption,
and integrity checks.
Authorization can be used to protect resources in a Condor pool.

When a daemon receives a request,
it uses the client's security configuration information
together with its own configuration settings to decide upon
the security aspects of the communication.
This can be considered a negotiation between the client and
the daemon.
The daemon replies to the client with 
a set of reconciled policies that controls the communication,
including authentication, encryption,
and integrity algorithms.

If the daemon determines that authentication is required, then the
client must follow the chosen authentication protocol.
After the required authentication, the client can send its
request to the daemon. 
The daemon identifies the access level required for the specific
request,
and it checks the configuration settings to determine if the client 
has the required access level.
If the client has the required access level,
permission is granted, and the request is serviced. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{sec:Security-access-levels} Access Level Descriptions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\index{security!access levels}
Authorization is granted based on specified access levels.
Access levels are granted for users by configuration settings.
The following describes the various access levels provided
by Condor.

\begin{description}

\item[\DCPerm{READ}] \label{sec-level-read} This access level
   access can obtain or read information about Condor.
   Examples that require only \DCPerm{READ} access are
   viewing the status of the pool, checking the job queue(s),
   or viewing user permissions.
   \DCPerm{READ} access does not allow any
   changes, and it does not allow job submission.

\item[\DCPerm{WRITE}] \label{sec-level-write} This access level
   is required to send (write) information to Condor.
   Note that \DCPerm{WRITE} access does not include \DCPerm{READ} access.
   They are separate access levels.
   Job submission requires \DCPerm{WRITE} access.

\item[\DCPerm{ADMINISTRATOR}] \label{sec-level-administrator} This
   access level has additional Condor
   administrator rights to the pool.  It includes the ability to
   change user priorities (with the command \Condor{userprio -set}),
   and the ability to turn Condor on and off
   (as with the commands \Condor{on} and \Condor{off}).

\item[\DCPerm{CONFIG}] \label{sec-level-config} This access level is
   required to modify a daemon's configuration using
   the \Condor{config\_val} command.
   By default, this level of access can
   change any configuration parameters of a Condor pool,
   except those specified in
   the \File{condor\_config.root} configuration file.

\item[\DCPerm{IMMEDIATE\_FAMILY}] \label{sec-level-immfamily} 
   This access level is only used by Condor daemons for internal
   exchange of requests.
   An example is the message sent from the \Condor{startd} daemon
   to the \Condor{schedd} daemon in order to claim a resource.
   In general, this level of access should be granted to all Condor
   daemons, implying that this level of access should be granted
   to the id under which the Condor daemons are run.

\item[\DCPerm{OWNER}] \label{sec-level-owner} This level of access is
   required for commands that the owner of a machine (any local user)
   should be able to use, in addition to the Condor administrators.
   An example that requires the \DCPerm{OWNER} access level is
   the \Condor{vacate} command.
   The command causes the \Condor{startd} daemon to vacate any
   Condor job currently running on a machine.
   The owner of that machine should be able to cause the removal
   of a job running on the machine.

\item[\DCPerm{NEGOTIATOR}] \label{sec-level-negotiator} This 
   access level is used specifically to verify that commands are
   sent by the \Condor{negotiator} daemon.
   The \Condor{negotiator} daemon runs on the central manager of
   the pool.
   Commands requiring this access
   level are the ones that tell the \Condor{schedd} daemon to begin
   negotiating, and those that tell an available \Condor{startd} daemon
   that it has been matched to a \Condor{schedd} with jobs to run.

\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{sec:Security-NamesValues} Security Macro Names and Values}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%\index{configuration macro!\texttt{SEC\_DEFAULT\_NEGOTIATION}}
%\index{configuration macro!\texttt{SEC\_READ\_NEGOTIATION}}
%\index{configuration macro!\texttt{SEC\_WRITE\_NEGOTIATION}}
%\index{configuration macro!\texttt{SEC\_ADMIN\_NEGOTIATION}}
%\index{configuration macro!\texttt{SEC\_IMMEDIATE\_FAMILY\_NEGOTIATION}}
%\index{configuration macro!\texttt{SEC\_CONFIG\_NEGOTIATION}}
%\index{configuration macro!\texttt{SEC\_OWNER\_NEGOTIATION}}
%\index{configuration macro!\texttt{SEC\_NEGOTIATOR\_NEGOTIATION}}
% client-side 
%\index{configuration macro!\texttt{SEC\_DEFAULT\_NEGOTIATION}}
%\index{configuration macro!\texttt{SEC\_CLIENT\_NEGOTIATION}}

The configuration macro names follow a pattern.
Each of the names starts with the string
\MacroNI{SEC\_}.
This string is followed by a string that describes an
access level.
The levels are
\begin{verbatim}
    DEFAULT
    READ
    WRITE
    ADMIN
    IMMEDIATE_FAMILY
    CONFIG
    OWNER
    NEGOTIATOR
    CLIENT
\end{verbatim}
Both \MacroNI{DEFAULT} and \MacroNI{CLIENT} 
from this list are not access levels.
The \MacroNI{DEFAULT} is used to define all levels of access
for a specific configuration variable when individual levels
are not specified.
The \MacroNI{CLIENT} is used to define the client's requirements
and preferences in a secure communication.

Still within the name of a configuration macro,
the access level is followed by another underscore
character and then a string describing the communication type.
The communication types are
\begin{verbatim}
    AUTHENTICATION
    ENCRYPTION
    INTEGRITY
    NEGOTIATION
\end{verbatim}
Two examples of the complete macro names are
\MacroNI{SEC\_ADMIN\_AUTHENTICATION}
and
\MacroNI{SEC\_DEFAULT\_INTEGRITY}.

Each configuration variable would be defined with one
of four predefined values.
The values are
\begin{verbatim}
    REQUIRED
    PREFERRED
    OPTIONAL
    NEVER 
\end{verbatim}
For example, a line in a daemon's configuration file
to require all interactions to be encrypted is
\begin{verbatim}
    SEC_DEFAULT_ENCRYPTION = REQUIRED
\end{verbatim}
A second example from a configuration file specifies that all
requests (from a client) that would require a \MacroNI{WRITE}
access level be authenticated is
\begin{verbatim}
    SEC_WRITE_AUTHENTICATION = REQUIRED
\end{verbatim}

A daemon uses both the client's security configuration
together with its own configuration to choose the communication
setting
for authentication, encryption, or integrity check.
The following table defines whether or not (Yes or No) a
communication setting will be used, or if the setting cannot
work (Fail) due to a mismatch in the configuration settings.

\begin{verbatim}
    client     daemon       Yes/No/Fail

    REQUIRED   REQUIRED       Yes
    REQUIRED   PREFERRED      Yes
    REQUIRED   OPTIONAL       Yes
    REQUIRED   NEVER          Fail

    PREFERRED  REQUIRED       Yes
    PREFERRED  PREFERRED      Yes
    PREFERRED  OPTIONAL       Yes
    PREFERRED  NEVER          No

    OPTIONAL   REQUIRED       Yes
    OPTIONAL   PREFERRED      Yes
    OPTIONAL   OPTIONAL       No
    OPTIONAL   NEVER          No

    NEVER      REQUIRED       Fail
    NEVER      PREFERRED      No
    NEVER      OPTIONAL       No
    NEVER      NEVER          No
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{sec:Security-Authentication} Authentication}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\index{security!authentication}
Authentication provides an assurance of an identity.
Through configuration macros, both the client and the daemon
can specify whether authentication is required.

The client uses one of two macros to configure authentication:
\index{SEC\_DEFAULT\_AUTHENTICATION macro@\texttt{SEC\_DEFAULT\_AUTHENTICATION} macro}
\index{configuration macro!\texttt{SEC\_DEFAULT\_AUTHENTICATION}}
\index{SEC\_CLIENT\_AUTHENTICATION macro@\texttt{SEC\_CLIENT\_AUTHENTICATION} macro}
\index{configuration macro!\texttt{SEC\_CLIENT\_AUTHENTICATION}}
\begin{verbatim}
    SEC_DEFAULT_AUTHENTICATION
    SEC_CLIENT_AUTHENTICATION
\end{verbatim}

For the daemon, there are eight macros to configure authentication:
\index{SEC\_READ\_AUTHENTICATION macro@\texttt{SEC\_READ\_AUTHENTICATION} macro}
\index{configuration macro!\texttt{SEC\_READ\_AUTHENTICATION}}
\index{SEC\_WRITE\_AUTHENTICATION macro@\texttt{SEC\_WRITE\_AUTHENTICATION} macro}
\index{configuration macro!\texttt{SEC\_WRITE\_AUTHENTICATION}}
\index{SEC\_ADMIN\_AUTHENTICATION macro@\texttt{SEC\_ADMIN\_AUTHENTICATION} macro}
\index{configuration macro!\texttt{SEC\_ADMIN\_AUTHENTICATION}}
\index{SEC\_IMMEDIATE\_FAMILY\_AUTHENTICATION macro@\texttt{SEC\_IMMEDIATE\_FAMILY\_AUTHENTICATION} macro}
\index{configuration macro!\texttt{SEC\_IMMEDIATE\_FAMILY\_AUTHENTICATION}}
\index{SEC\_CONFIG\_AUTHENTICATION macro@\texttt{SEC\_CONFIG\_AUTHENTICATION} macro}
\index{configuration macro!\texttt{SEC\_CONFIG\_AUTHENTICATION}}
\index{SEC\_OWNER\_AUTHENTICATION macro@\texttt{SEC\_OWNER\_AUTHENTICATION} macro}
\index{configuration macro!\texttt{SEC\_OWNER\_AUTHENTICATION}}
\index{SEC\_NEGOTIATOR\_AUTHENTICATION macro@\texttt{SEC\_NEGOTIATOR\_AUTHENTICATION} macro}
\index{configuration macro!\texttt{SEC\_NEGOTIATOR\_AUTHENTICATION}}
\begin{verbatim}
    SEC_DEFAULT_AUTHENTICATION
    SEC_READ_AUTHENTICATION
    SEC_WRITE_AUTHENTICATION
    SEC_ADMIN_AUTHENTICATION
    SEC_IMMEDIATE_FAMILY_AUTHENTICATION
    SEC_CONFIG_AUTHENTICATION
    SEC_OWNER_AUTHENTICATION
    SEC_NEGOTIATOR_AUTHENTICATION
\end{verbatim}

As an example, the macro defined in the configuration file
for a daemon as
\begin{verbatim}
SEC_WRITE_AUTHENTICATION = REQUIRED
\end{verbatim}
signifies that the daemon must authenticate the client for
any communication that requires the \DCPerm{WRITE} access level.
If the daemon's configuration contains
\begin{verbatim}
SEC_DEFAULT_AUTHENTICATION = REQUIRED
\end{verbatim}
and does not contain any other security configuration for
\verb@AUTHENTICATION@, then this default defines the daemon's needs
for authentication over all access levels.
Where a specific macro is present, its value takes
precedence over any default given.


If authentication is to be done, then the communicating parties
must negotiate a mutually acceptable method of
authentication to be used.
A list of acceptable methods may be provided by the client, using the
macros
\index{SEC\_DEFAULT\_AUTHENTICATION\_METHODS macro@\texttt{SEC\_DEFAULT\_AUTHENTICATION\_METHODS} macro}
\index{configuration macro!\texttt{SEC\_DEFAULT\_AUTHENTICATION\_METHODS}}
\index{SEC\_CLIENT\_AUTHENTICATION\_METHODS macro@\texttt{SEC\_CLIENT\_AUTHENTICATION\_METHODS} macro}
\index{configuration macro!\texttt{SEC\_CLIENT\_AUTHENTICATION\_METHODS}}
\begin{verbatim}
    SEC_DEFAULT_AUTHENTICATION_METHODS
    SEC_CLIENT_AUTHENTICATION_METHODS
\end{verbatim}
A list of acceptable methods may be provided by the daemon, using the
macros
\index{SEC\_DEFAULT\_AUTHENTICATION\_METHODS macro@\texttt{SEC\_DEFAULT\_AUTHENTICATION\_METHODS} macro}
\index{configuration macro!\texttt{SEC\_DEFAULT\_AUTHENTICATION\_METHODS}}
\index{SEC\_READ\_AUTHENTICATION\_METHODS macro@\texttt{SEC\_READ\_AUTHENTICATION\_METHODS} macro}
\index{configuration macro!\texttt{SEC\_READ\_AUTHENTICATION\_METHODS}}
\index{SEC\_WRITE\_AUTHENTICATION\_METHODS macro@\texttt{SEC\_WRITE\_AUTHENTICATION\_METHODS} macro}
\index{configuration macro!\texttt{SEC\_WRITE\_AUTHENTICATION\_METHODS}}
\index{SEC\_ADMIN\_AUTHENTICATION\_METHODS macro@\texttt{SEC\_ADMIN\_AUTHENTICATION\_METHODS} macro}
\index{configuration macro!\texttt{SEC\_ADMIN\_AUTHENTICATION\_METHODS}}
\index{SEC\_IMMEDIATE\_FAMILY\_AUTHENTICATION\_METHODS macro@\texttt{SEC\_IMMEDIATE\_FAMILY\_AUTHENTICATION\_METHODS} macro}
\index{configuration macro!\texttt{SEC\_IMMEDIATE\_FAMILY\_AUTHENTICATION\_METHODS}}
\index{SEC\_CONFIG\_AUTHENTICATION\_METHODS macro@\texttt{SEC\_CONFIG\_AUTHENTICATION\_METHODS} macro}
\index{configuration macro!\texttt{SEC\_CONFIG\_AUTHENTICATION\_METHODS}}
\index{SEC\_OWNER\_AUTHENTICATION\_METHODS macro@\texttt{SEC\_OWNER\_AUTHENTICATION\_METHODS} macro}
\index{configuration macro!\texttt{SEC\_OWNER\_AUTHENTICATION\_METHODS}}
\index{SEC\_NEGOTIATOR\_AUTHENTICATION\_METHODS macro@\texttt{SEC\_NEGOTIATOR\_AUTHENTICATION\_METHODS} macro}
\index{configuration macro!\texttt{SEC\_NEGOTIATOR\_AUTHENTICATION\_METHODS}}
\begin{verbatim}
    SEC_DEFAULT_AUTHENTICATION_METHODS
    SEC_READ_AUTHENTICATION_METHODS
    SEC_WRITE_AUTHENTICATION_METHODS
    SEC_ADMIN_AUTHENTICATION_METHODS
    SEC_IMMEDIATE_FAMILY_AUTHENTICATION_METHODS
    SEC_CONFIG_AUTHENTICATION_METHODS
    SEC_OWNER_AUTHENTICATION_METHODS
    SEC_NEGOTIATOR_AUTHENTICATION_METHODS
\end{verbatim}
The methods are
given as a comma-separated list of acceptable values.
These variables list the authentication methods that are available
to be used.
The ordering of the list gives preference;
the first item in the list indicates the highest preference.
The values will be 
\begin{verbatim}
    KERBEROS
    FS
    CLAIMTOBE
    ANONYMOUS
    NTSSPI
\end{verbatim}
%   GSI

As an example, the macro
% \begin{verbatim}
% SEC_DEFAULT_AUTHENTICATION_METHODS = KERBEROS, GSI
% \end{verbatim}
% indicates that either Kerberos or the Globus Security Infrastructure
% (GSI) authentication may be used,
% but Kerberos is preferred over GSI.
\begin{verbatim}
SEC_DEFAULT_AUTHENTICATION_METHODS = KERBEROS, NTSSPI
\end{verbatim}
indicates that either Kerberos or Windows authentication may be used,
but Kerberos is preferred over Windows.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{sec:Security-Encryption} Encryption}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\index{security!encryption}
Encryption provides privacy support between two communicating parties.
Through configuration macros, both the client and the daemon
can specify whether encryption is required for further communication.

The client uses one of two macros to enable or disable encryption:
\index{SEC\_DEFAULT\_ENCRYPTION macro@\texttt{SEC\_DEFAULT\_ENCRYPTION} macro}
\index{configuration macro!\texttt{SEC\_DEFAULT\_ENCRYPTION}}
\index{SEC\_CLIENT\_ENCRYPTION macro@\texttt{SEC\_CLIENT\_ENCRYPTION} macro}
\index{configuration macro!\texttt{SEC\_CLIENT\_ENCRYPTION}}
\begin{verbatim}
    SEC_DEFAULT_ENCRYPTION
    SEC_CLIENT_ENCRYPTION
\end{verbatim}

For the daemon, there are eight macros to enable or disable encryption:
\index{SEC\_DEFAULT\_ENCRYPTION macro@\texttt{SEC\_DEFAULT\_ENCRYPTION} macro}
\index{configuration macro!\texttt{SEC\_DEFAULT\_ENCRYPTION}}
\index{SEC\_READ\_ENCRYPTION macro@\texttt{SEC\_READ\_ENCRYPTION} macro}
\index{configuration macro!\texttt{SEC\_READ\_ENCRYPTION}}
\index{SEC\_WRITE\_ENCRYPTION macro@\texttt{SEC\_WRITE\_ENCRYPTION} macro}
\index{configuration macro!\texttt{SEC\_WRITE\_ENCRYPTION}}
\index{SEC\_ADMIN\_ENCRYPTION macro@\texttt{SEC\_ADMIN\_ENCRYPTION} macro}
\index{configuration macro!\texttt{SEC\_ADMIN\_ENCRYPTION}}
\index{SEC\_IMMEDIATE\_FAMILY\_ENCRYPTION macro@\texttt{SEC\_IMMEDIATE\_FAMILY\_ENCRYPTION} macro}
\index{configuration macro!\texttt{SEC\_IMMEDIATE\_FAMILY\_ENCRYPTION}}
\index{SEC\_CONFIG\_ENCRYPTION macro@\texttt{SEC\_CONFIG\_ENCRYPTION} macro}
\index{configuration macro!\texttt{SEC\_CONFIG\_ENCRYPTION}}
\index{SEC\_OWNER\_ENCRYPTION macro@\texttt{SEC\_OWNER\_ENCRYPTION} macro}
\index{configuration macro!\texttt{SEC\_OWNER\_ENCRYPTION}}
\index{SEC\_NEGOTIATOR\_ENCRYPTION macro@\texttt{SEC\_NEGOTIATOR\_ENCRYPTION} macro}
\index{configuration macro!\texttt{SEC\_NEGOTIATOR\_ENCRYPTION}}
\begin{verbatim}
    SEC_DEFAULT_ENCRYPTION
    SEC_READ_ENCRYPTION
    SEC_WRITE_ENCRYPTION
    SEC_ADMIN_ENCRYPTION
    SEC_IMMEDIATE_FAMILY_ENCRYPTION
    SEC_CONFIG_ENCRYPTION
    SEC_OWNER_ENCRYPTION
    SEC_NEGOTIATOR_ENCRYPTION
\end{verbatim}

As an example, the macro defined in the configuration file
for a daemon as
\begin{verbatim}
SEC_IMMEDIATE_FAMILY_ENCRYPTION = REQUIRED
\end{verbatim}
signifies that any daemon to daemon communication must be
encrypted.
If a daemon's configuration contains
\begin{verbatim}
SEC_DEFAULT_ENCRYPTION = REQUIRED
\end{verbatim}
and does not contain any other security configuration for
ENCRYPTION, then this default defines the daemon's needs
for encryption over all access levels.
Where a specific macro is present, its value takes
precedence over any default given.

If encryption is to be done, then the communicating parties
must find (negotiate) a mutually acceptable method of
encryption to be used.
A list of acceptable methods may be provided by the client, using the
macros
\index{SEC\_DEFAULT\_CRYPTO\_METHODS macro@\texttt{SEC\_DEFAULT\_CRYPTO\_METHODS} macro}
\index{configuration macro!\texttt{SEC\_DEFAULT\_CRYPTO\_METHODS}}
\index{SEC\_CLIENT\_CRYPTO\_METHODS macro@\texttt{SEC\_CLIENT\_CRYPTO\_METHODS} macro}
\index{configuration macro!\texttt{SEC\_CLIENT\_CRYPTO\_METHODS}}
\begin{verbatim}
    SEC_DEFAULT_CRYPTO_METHODS
    SEC_CLIENT_CRYPTO_METHODS
\end{verbatim}
A list of acceptable methods may be provided by the daemon, using the
macros
\index{SEC\_DEFAULT\_CRYPTO\_METHODS macro@\texttt{SEC\_DEFAULT\_CRYPTO\_METHODS} macro}
\index{configuration macro!\texttt{SEC\_DEFAULT\_CRYPTO\_METHODS}}
\index{SEC\_READ\_CRYPTO\_METHODS macro@\texttt{SEC\_READ\_CRYPTO\_METHODS} macro}
\index{configuration macro!\texttt{SEC\_READ\_CRYPTO\_METHODS}}
\index{SEC\_WRITE\_CRYPTO\_METHODS macro@\texttt{SEC\_WRITE\_CRYPTO\_METHODS} macro}
\index{configuration macro!\texttt{SEC\_WRITE\_CRYPTO\_METHODS}}
\index{SEC\_ADMIN\_CRYPTO\_METHODS macro@\texttt{SEC\_ADMIN\_CRYPTO\_METHODS} macro}
\index{configuration macro!\texttt{SEC\_ADMIN\_CRYPTO\_METHODS}}
\index{SEC\_IMMEDIATE\_FAMILY\_CRYPTO\_METHODS macro@\texttt{SEC\_IMMEDIATE\_FAMILY\_CRYPTO\_METHODS} macro}
\index{configuration macro!\texttt{SEC\_IMMEDIATE\_FAMILY\_CRYPTO\_METHODS}}
\index{SEC\_CONFIG\_CRYPTO\_METHODS macro@\texttt{SEC\_CONFIG\_CRYPTO\_METHODS} macro}
\index{configuration macro!\texttt{SEC\_CONFIG\_CRYPTO\_METHODS}}
\index{SEC\_OWNER\_CRYPTO\_METHODS macro@\texttt{SEC\_OWNER\_CRYPTO\_METHODS} macro}
\index{configuration macro!\texttt{SEC\_OWNER\_CRYPTO\_METHODS}}
\index{SEC\_NEGOTIATOR\_CRYPTO\_METHODS macro@\texttt{SEC\_NEGOTIATOR\_CRYPTO\_METHODS} macro}
\index{configuration macro!\texttt{SEC\_NEGOTIATOR\_CRYPTO\_METHODS}}
\begin{verbatim}
    SEC_DEFAULT_CRYPTO_METHODS
    SEC_READ_CRYPTO_METHODS
    SEC_WRITE_CRYPTO_METHODS
    SEC_ADMIN_CRYPTO_METHODS
    SEC_IMMEDIATE_FAMILY_CRYPTO_METHODS
    SEC_CONFIG_CRYPTO_METHODS
    SEC_OWNER_CRYPTO_METHODS
    SEC_NEGOTIATOR_CRYPTO_METHODS
\end{verbatim}

The methods are
given as a comma-separated list of acceptable values.
These variables list the encryption methods that are available
to be used.
The ordering of the list gives preference;
the first item in the list indicates the highest preference.
Possible values are
\begin{verbatim}
    3DES
    BLOWFISH
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{sec:Security-Integrity} Integrity Checks}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\index{security!integrity}

An integrity check assures that the messages between communicating parties
have not been tampered with.
Any change, such as addition, modification, or deletion can
be detected.
Through configuration macros, both the client and the daemon
can specify whether an integrity check is required of further communication.

The client uses one of two macros to enable or disable an integrity check:
\index{SEC\_DEFAULT\_INTEGRITY macro@\texttt{SEC\_DEFAULT\_INTEGRITY} macro}
\index{configuration macro!\texttt{SEC\_DEFAULT\_INTEGRITY}}
\index{SEC\_CLIENT\_INTEGRITY macro@\texttt{SEC\_CLIENT\_INTEGRITY} macro}
\index{configuration macro!\texttt{SEC\_CLIENT\_INTEGRITY}}
\begin{verbatim}
    SEC_DEFAULT_INTEGRITY
    SEC_CLIENT_INTEGRITY
\end{verbatim}

For the daemon, there are eight macros to enable or disable an integrity check:
\index{SEC\_DEFAULT\_INTEGRITY macro@\texttt{SEC\_DEFAULT\_INTEGRITY} macro}
\index{configuration macro!\texttt{SEC\_DEFAULT\_INTEGRITY}}
\index{SEC\_READ\_INTEGRITY macro@\texttt{SEC\_READ\_INTEGRITY} macro}
\index{configuration macro!\texttt{SEC\_READ\_INTEGRITY}}
\index{SEC\_WRITE\_INTEGRITY macro@\texttt{SEC\_WRITE\_INTEGRITY} macro}
\index{configuration macro!\texttt{SEC\_WRITE\_INTEGRITY}}
\index{SEC\_ADMIN\_INTEGRITY macro@\texttt{SEC\_ADMIN\_INTEGRITY} macro}
\index{configuration macro!\texttt{SEC\_ADMIN\_INTEGRITY}}
\index{SEC\_IMMEDIATE\_FAMILY\_INTEGRITY macro@\texttt{SEC\_IMMEDIATE\_FAMILY\_INTEGRITY} macro}
\index{configuration macro!\texttt{SEC\_IMMEDIATE\_FAMILY\_INTEGRITY}}
\index{SEC\_CONFIG\_INTEGRITY macro@\texttt{SEC\_CONFIG\_INTEGRITY} macro}
\index{configuration macro!\texttt{SEC\_CONFIG\_INTEGRITY}}
\index{SEC\_OWNER\_INTEGRITY macro@\texttt{SEC\_OWNER\_INTEGRITY} macro}
\index{configuration macro!\texttt{SEC\_OWNER\_INTEGRITY}}
\index{SEC\_NEGOTIATOR\_INTEGRITY macro@\texttt{SEC\_NEGOTIATOR\_INTEGRITY} macro}
\index{configuration macro!\texttt{SEC\_NEGOTIATOR\_INTEGRITY}}
\begin{verbatim}
    SEC_DEFAULT_INTEGRITY
    SEC_READ_INTEGRITY
    SEC_WRITE_INTEGRITY
    SEC_ADMIN_INTEGRITY
    SEC_IMMEDIATE_FAMILY_INTEGRITY
    SEC_CONFIG_INTEGRITY
    SEC_OWNER_INTEGRITY
    SEC_NEGOTIATOR_INTEGRITY
\end{verbatim}

As an example, the macro defined in the configuration file
for a daemon as
\begin{verbatim}
SEC_IMMEDIATE_FAMILY_INTEGRITY = REQUIRED
\end{verbatim}
signifies that any daemon to daemon communication must
have its integrity assured.
If a daemon's configuration contains
\begin{verbatim}
SEC_DEFAULT_INTEGRITY = REQUIRED
\end{verbatim}
and does not contain any other security configuration for
\verb@INTEGRITY@, then this default defines the daemon's needs
for integrity checks over all access levels.
Where a specific macro is present, its value takes
precedence over any default given.

There is currently only one method used for integrity checking:
a signed MD5 checksum.
Its use is implied whenever integrity checks occur.
If more methods are implemented, then there will be further
macros to allow both the client and the daemon to specify
which methods are acceptable.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{sec:Security-sample1} Example of Daemon-Side Security Configuration}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A configuration file is provided when Condor is installed.
No security features are enabled within the configuration as
distributed.
Included as comments within the configuration file is an example 
suggesting settings that enable security features.
Here is that example of the daemon-side portion.

% from Zach  (3/7/03)
\begin{verbatim}
SEC_DEFAULT_AUTHENTICATION=REQUIRED
SEC_DEFAULT_ENCRYPTION=REQUIRED
SEC_DEFAULT_INTEGRITY=REQUIRED

SEC_DEFAULT_AUTHENTICATION_METHODS = FS, KERBEROS
SEC_DEFAULT_CRYPTO_METHODS = 3DES, BLOWFISH
\end{verbatim}

This set of configuration macros forces security features
to be used at all times.
All communication is authenticated (using Kerberos),
and all communication is both encrypted
(using triple DES)
and has its
integrity checked to make sure that messages
are not modified or corrupted.
Negotiation configuration variables are not included in this
suggested configuration.
The default (when undefined) will be to set
\begin{verbatim}
SEC_DEFAULT_NEGOTIATION=OPTIONAL
\end{verbatim}


Note that this example configuration requires that all Condor daemons be
version 6.3.3 or later, since previous versions will not have
the ability to do secure communication.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\label{sec:Authentication}Authentication}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\index{authentication|(}
\index{security!authentication}
Authentication provides an assurance of an identity.
Condor supports authenticated communications by using any one
of several supported methods.
The details of Condor's requirements for using various methods
of authentication are given below.

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsubsection{\label{sec:X509-Authentication}X.509 Authentication}
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The Globus GSI (Grid Security Infrastructure) protocol provides
% an avenue for Condor to do
% PKI-based authentication using X.509 certificates.
% 
% Several steps are required to enable this authentication.
% \begin{description}
% \item[X.509 Certificates]
% 
% PKI-based authentication between Condor daemons
% requires
% a valid X.509 certificate from a trusted
% CA (Certification Authority).
% The certificate may be a single host certificate,
% and all Condor daemons on the same machine may share the same certificate.
% The directory where the certificate resides, along with
% other related files such as one containing the private key,
% are utilized by Condor when doing authentication. 
% 
% Condor locates the daemon's certificate through the use of
% a configuration macro.
% Note that the certificate can be shared by all Condor daemons
% running on a machine.
% The certificate can also be copied to other machines,
% where local copies are necessary.
% The certificates must be protected by access rights to
% files, since the password file is not encrypted.
% 
% Condor users (those who submit jobs) can also use
% the X.509-based authentication.
% These users must also
% have valid X.509 certificates signed by a trusted CA.
% For use when submitting jobs,
% the certificate is used to generate a proxy:
% a combination of certificate and password that is valid only
% for a specific (and usually short) time period.
% A proxy is used so that the user does  
% not need to be present (to give a password) when a job is executed.
% 
% \item[Condor Configuration]
        % 
% To use X.509 certificates for authentication, the Condor configuration file
% must have the following configuration macros set.
% This setting is an example.
% 
% \begin{verbatim}
% SEC_DEFAULT_AUTHENTICATION = REQUIRED
% SEC_DEFAULT_AUTHENTICATION_METHODS = GSS_AUTHENTICATION 
% X509_DIRECTORY = /path/to/daemon/certificatedirectory
% CONDOR_GATEKEEPER = /C=US/O=Condor/O=University of Wisconsin
% /OU=Computer Sciences Department/CN=condor@cs.wisc.edu
% \end{verbatim}
% 
% The
% \MacroNI{SEC\_DEFAULT\_AUTHENTICATION} macro specifies that
% authentication is required for all communications.
% This single macro covers all communications, but could be
% replaced with a set of macros that require authentication for
% only specific communications.
% See section~\ref{sec:Security-Authentication} for details on the
% more specific configuration variables used for authentication.

% The \MacroNI{GSS\_AUTHENTICATION} method specifies the use of
% the X.509 protocol. 
% If this is the only method listed, then X.509 will be the only
% protocol used.
% If other methods are acceptable, then placing this method
% first within the list will cause Condor to give preference to
% this method over others.
% 
% The macro \MacroNI{X509\_DIRECTORY} must be specified,
% so that Condor knows where to look for the daemon's certificate.
% This path may be a directory or a shared file system such as AFS. 
% Alternatively, this path name
% can point to 
% local copies of the certificate stored
% in a local file system.
% 
% The macro \MacroNI{CONDOR\_GATEKEEPER} configuration macro
% provides daemons with a distinguished name to use for
% X.509 authentication.
% This name is specified with the following format
% \begin{verbatim}
% CONDOR_GATEKEEPER = /C=?/O=?/O=?/OU=?/CN=<daemon_name@domain>
% \end{verbatim}
% A complete example that has the question marks filled in and the
% daemon's user name filled in is given in the 
% example above.
% 
% Condor will also need a way to map an X.509 distinguished
% name to a Condor user id.
% This is done in an administrator-maintained file called an X.509 map file,
% mapping from X509 Distinguished Name (DN) to Condor user id.
% It is similar to a Globus Gridmap file.
% Entries (lines) in the file each contain two items.
% The first item in an entry is the distinguished name
% given in an X.509 certificate.
% The second item is the Condor user id, given as a
% fully qualified name.
% Note that the two items in an entry are separated by tab character(s),
% not spaces.
% An example of two entries in an X.509 map file:
% 
% \begin{verbatim}
% V	020406001927Z		01	unknown	/C=US/O=Condor/O=University
% of Wisconsin/ OU=Computer Sciences Department/CN=condor@cs.wisc.edu
% condor@cs.wisc.edu
% V	020406002049Z		02	unknown	/C=US/O=Condor/O=University
% of Wisconsin/OU=Computer Sciences Department/CN=jsmith@cs.wisc.edu
% jsmith@cs.wisc.edu
% \end{verbatim}
% 
% Condor expects the map file to be in the location given by
% \begin{verbatim}
% $(X509_DIRECTORY)/certdir/index.txt
% \end{verbatim}
% If the map file is not in this location, a symbolic link
% may be used to point to the actual map file.
% 
% \item[User environment]
% 
% The Condor user (one who submits jobs) must create a proxy
% prior to authentication.
% The user creates a proxy using the program
% \Prog{grid-proxy-init}.
% This program needs to know 
% the location of the user's certificate directory.
% This is done by setting an environment variable, called
% \Env{X509\_CERT\_DIR}.
% For example, if the X509 directory is \File{/test/myX509},
% then \Env{X509\_CERT\_DIR} should be set to \File{/test/myX509/certdir}.
% 
% After running \Prog{grid-proxy-init},
% an environment variable called
% \Env{X509\_USER\_PROXY} may be set to give
% the location where the proxy is stored.
% By default,
% \Prog{grid-proxy-init} will place the proxy in the \File{/tmp}
% directory with
% the file name being determined by the format:
% \begin{verbatim}
% /tmp/x509_uXXXX
% \end{verbatim}
% The specific file name is given by substituting the \verb@XXXX@
% characters with the UID of the user.
% The
% \Env{X509\_USER\_PROXY} environment variable is optional,
% since Condor looks in the default location if the environment
% variable is not set.
% 
% 
% \end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{sec:Kerberos-Authentication}Kerberos Authentication}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\index{authentication!Kerberos}
If Kerberos is used for authentication, then 
the configuration variable
\Macro{KERBEROS\_MAP\_FILE}
must be used to define a path to an administrator-maintained file that
contains Kerberos domain (called a realm) to Condor UID domain mapping.
The configuration syntax is
\begin{verbatim}
KERBEROS_MAP_FILE = /path/to/etc/condor.kmap
\end{verbatim}

Lines within the map file have the syntax
\begin{verbatim}
   KERB.REALM = UID.domain.name
\end{verbatim}
%If no map file is specified, then Condor assumes that the
%Kerberos realm is the same as the Condor UID domain.
Here are two lines from a map file to use as an example:
\begin{verbatim}
   CS.WISC.EDU   = cs.wisc.edu
   ENGR.WISC.EDU = ee.wisc.edu
\end{verbatim}

The configuration variable
\Macro{CONDOR\_SERVER\_PRINCIPAL}
defines the name of a Kerberos principal.
If \MacroNI{CONDOR\_SERVER\_PRINCIPAL} is not defined,
then the default value used is "host".
A principal specifies a unique name to which a set of credentials
may be assigned.
\index{authentication!Kerberos principal}

Condor takes the specified (or default) principal and appends
a slash character, the host name, an '@' (at sign character),
and the kerberos realm.
As an example, the configuration
\begin{verbatim}
CONDOR_SERVER_PRINCIPAL=condor-daemon
\end{verbatim}
results in Condor's use of
\begin{verbatim}
condor-daemon/the.host.name@YOUR.KERB.REALM
\end{verbatim}
as the server principal.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{sec:FS-Authentication}File System Authentication}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{authentication!using a file system}
This form of authentication utilizes the ownership of a file
in the identity verification of a client.
A daemon authenticating a client requires the client to write
a file in a specific location.
The daemon then checks the ownership of the file.
The file's ownership verifies the identity of the client.
In this way, the file system becomes the trusted authority.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{sec:NTSSPI-Authentication}Windows Authentication}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\index{authentication!Windows}
This is authentication done among Windows machines using
a proprietary method.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{sec:CLAIM-Authentication}Claim To Be Authentication}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Claim To Be authentication accepts any identity claimed by the client.
As such, it does not authenticate.
It is included in Condor and in the list of authentication methods
for testing purposes only.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{sec:ANON-Authentication}Anonymous Authentication}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Anonymous authentication causes authentication to be skipped entirely.
As such, it does not authenticate.
It is included in Condor and in the list of authentication methods
for testing purposes only.

\index{authentication|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\label{sec:Security-Authorization} Authorization}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\index{security!authorization}

Authorization protects resource usage by granting or denying
access requests made to the resources.
It defines who is allowed to do what.

Authorization is defined in terms of users.
An initial implementation provided authorization
based on hosts (machines), while the current implementation
relies on user-based authorization.
Section~\ref{sec:Host-Security}
on Setting Up IP/Host-Based Security in Condor describes the
previous implementation.
This IP/Host-Based security still exists, and it can be used,
but significantly stronger and more flexible
security can be achieved with the newer
authorization based on fully qualified user names.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{sec:Security-UserAuthorization}User-based Authorization}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\index{security!based on user authorization}

% format for the configuration macro index entries
%\index{ macro@\texttt{} macro}
%\index{configuration macro!\texttt{}}

Unlike authentication, encryption, and integrity checks,
which can be configured by both client and server,
authorization is used only by a server.
The authorization portion of the security of a Condor pool is
based on a set of configuration macros.
The macros list which user/daemon will be authorized
to issue what request given a specific access level.

These configuration macros define a set of users that will be
allowed to (or denied from) carrying out various Condor commands.
Each access level may have its own list of authorized users.
A complete list of the authorization macros:
\index{ALLOW\_READ macro@\texttt{ALLOW\_READ} macro}
\index{configuration macro!\texttt{ALLOW\_READ}}
\index{ALLOW\_WRITE macro@\texttt{ALLOW\_WRITE} macro}
\index{configuration macro!\texttt{ALLOW\_WRITE}}
\index{ALLOW\_ADMINISTRATOR macro@\texttt{ALLOW\_ADMINISTRATOR} macro}
\index{configuration macro!\texttt{ALLOW\_ADMINISTRATOR}}
\index{ALLOW\_CONFIG macro@\texttt{ALLOW\_CONFIG} macro}
\index{configuration macro!\texttt{ALLOW\_CONFIG}}
\index{ALLOW\_IMMEDIATE\_FAMILY macro@\texttt{ALLOW\_IMMEDIATE\_FAMILY} macro}
\index{configuration macro!\texttt{ALLOW\_IMMEDIATE\_FAMILY}}
\index{ALLOW\_OWNER macro@\texttt{ALLOW\_OWNER} macro}
\index{configuration macro!\texttt{ALLOW\_OWNER}}
\index{ALLOW\_NEGOTIATOR macro@\texttt{ALLOW\_NEGOTIATOR} macro}
\index{configuration macro!\texttt{ALLOW\_NEGOTIATOR}}
\index{DENY\_READ macro@\texttt{DENY\_READ} macro}
\index{configuration macro!\texttt{DENY\_READ}}
\index{DENY\_WRITE macro@\texttt{DENY\_WRITE} macro}
\index{configuration macro!\texttt{DENY\_WRITE}}
\index{DENY\_ADMINISTRATOR macro@\texttt{DENY\_ADMINISTRATOR} macro}
\index{configuration macro!\texttt{DENY\_ADMINISTRATOR}}
\index{DENY\_CONFIG macro@\texttt{DENY\_CONFIG} macro}
\index{configuration macro!\texttt{DENY\_CONFIG}}
\index{DENY\_IMMEDIATE\_FAMILY macro@\texttt{DENY\_IMMEDIATE\_FAMILY} macro}
\index{configuration macro!\texttt{DENY\_IMMEDIATE\_FAMILY}}
\index{DENY\_OWNER macro@\texttt{DENY\_OWNER} macro}
\index{configuration macro!\texttt{DENY\_OWNER}}
\index{DENY\_NEGOTIATOR macro@\texttt{DENY\_NEGOTIATOR} macro}
\index{configuration macro!\texttt{DENY\_NEGOTIATOR}}
\begin{verbatim}
    ALLOW_READ
    ALLOW_WRITE
    ALLOW_ADMINISTRATOR
    ALLOW_CONFIG
    ALLOW_IMMEDIATE_FAMILY
    ALLOW_OWNER
    ALLOW_NEGOTIATOR
    DENY_READ
    DENY_WRITE
    DENY_ADMINISTRATOR
    DENY_CONFIG
    DENY_IMMEDIATE_FAMILY
    DENY_OWNER
    DENY_NEGOTIATOR
\end{verbatim}

Each macro is defined by a comma-separated list of fully qualified
users.
Each
fully qualified user
is described using the following format:
\begin{verbatim}
    username@domain/hostname
\end{verbatim}
The information to the left of the slash character describes
a user within a domain.
The information to the right of the slash character describes
a machine from which the user would be issuing a command. 
An example is
\begin{verbatim}
zmiller@cs.wisc.edu/bird.cs.wisc.edu
\end{verbatim}

Within the format, wildcard characters (the asterisk, *) are allowed.
The use of wildcards is limited to one wildcard on either side
of the slash character.
For example,
\begin{verbatim}
*@cs.wisc.edu/bird.cs.wisc.edu
\end{verbatim}
refers to any user that comes from \verb@cs.wisc.edu@,
where the command is originating from the machine
\verb@bird.cs.wisc.edu@.
Another example,
\begin{verbatim}
zmiller@cs.wisc.edu/*.cs.wisc.edu
\end{verbatim}
refers to commands coming from any machine within the 
\verb@cs.wisc.edu@ domain, and issued by \verb@zmiller@.
A third example,
\begin{verbatim}
*@cs.wisc.edu/*
\end{verbatim}
refers to commands coming from any user within the 
\verb@cs.wisc.edu@ domain
where the command is issued from any machine.

This flexible set of configuration macros could used to define
conflicting authorization.
Therefore, the following protocol defines the precedence of the
configuration macros.
\begin{description}
\item{1. }\MacroNI{DENY\_*} macros take precedence over \Macro{ALLOW\_* macros}
where there is a conflict.
This implies that if a specific user is both denied and granted authorization,
the conflict is resolved by denying access.
\item{2. }If macros are omitted, the default behavior is to grant
authorization for every user.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{sec:Security-sample2} Example of Authorization Security Configuration}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

An example of the configuration variables for the user-side
authorization is derived from the necessary access levels
as described in
Section~\ref{sec:Security-access-levels}.

\begin{verbatim}
ALLOW_READ            = *@cs.wisc.edu/*
ALLOW_WRITE           = *@cs.wisc.edu/*.cs.wisc.edu
ALLOW_ADMINISTRATOR   = condor-admin@cs.wisc.edu/*.cs.wisc.edu
ALLOW_NEGOTIATOR      = condor@cs.wisc.edu/$(NEGOTIATOR_HOST)
ALLOW_CONFIG          = condor-admin@cs.wisc.edu/*.cs.wisc.edu
ALLOW_IMMEDIATE_FAMILY= condor@cs.wisc.edu/*.cs.wisc.edu
\end{verbatim}

This example configuration authorizes
any user in the 
\verb@cs.wisc.edu@ domain to 
carry out a request that requires the 
\DCPerm{READ} access level
from any machine.
Any user in the 
\verb@cs.wisc.edu@ domain may 
carry out a request that requires the 
\DCPerm{WRITE} access level
from any machine in the
\verb@cs.wisc.edu@ domain.
Only the user called \verb@condor-admin@ may 
carry out a request that requires the 
\DCPerm{ADMINISTRATOR} access level
from any machine in the
\verb@cs.wisc.edu@ domain.
Only the negotiator daemon, running as
\verb@condor@ on the machine defined by the
\MacroNI{NEGOTIATOR\_HOST} macro is authorized 
with the
\DCPerm{NEGOTIATOR} access level.
The administrator, logged into any machine within
the \verb@cs.wisc.edu@ domain is authorized at the
\DCPerm{CONFIG} access level.
And, the last line of the example presumes that there is a
user called condor, and that the daemons have all been started
up as this user.
It authorizes only programs (which will be the daemons)
running as 
\verb@condor@ to
carry out requests that require the 
\DCPerm{IMMEDIATE\_FAMILY} access level,
where the commands originate from
any machine in the
\verb@cs.wisc.edu@ domain.

In the local configuration file for each host, the host's
owner should be authorized
as the owner of the machine.
An example of the entry in the local configuration file:
\begin{verbatim}
ALLOW_OWNER           = username@cs.wisc.edu/hostname.cs.wisc.edu
\end{verbatim}
In this example the owner has a login of
\verb@username@, and the machine's name is represented by
\verb@hostname@.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{sec:Host-Security}Setting Up IP/Host-Based Security in
Condor} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\index{security!host-based}

This section describes the mechanisms for setting up Condor's
host-based security.  
This is now an outdated form of implementing security at
the level of machine access. 
It remains available and documented for purposes of backward compatibility.
If used at the same time as the user-based authorization,
the two specifications are merged together.

The host-based security allows control over what machines can
join a Condor pool, what machines can find out information about
your pool, and what machines within your pool can perform
administrative commands.  By default, Condor is configured to allow
anyone to view or join your pool.  You probably want to change that.

This section discusses how the host-based security works inside Condor.
It lists the different levels of access and what
parts of Condor use which levels.
There is a description of how to configure
your pool to grant (or deny) certain levels of access to various
machines.
Configuration examples and the settings of configuration variables
using the \Condor{config\_val} command complete this section.

Inside the Condor daemons or tools that use DaemonCore (see
section~\ref{sec:DaemonCore} for details), most
things are accomplished by sending commands to another Condor daemon.
These commands are formed from an integer to specify which command,
followed
by any optional information that the protocol requires at that point
(such as a ClassAd, capability string, etc).
When the daemons start up,
they register which commands they are willing to accept, what to
do with arriving commands, and the access level required for
that command.
When a command arrives, Condor identifies the  access level
required, and checks the IP address of the sender to be
sure it passes the various allow/deny settings
in the configuration file for the given access level.
If permission is granted, the command continues. 
If not, the command is aborted.
%% What does it mean for a command to be aborted?  Is it just
%% thrown away (ignored), or is a reply sent indicating failure?

As expected, settings for the access levels in the global
configuration file affect all the machines in the pool.
Settings in a local configuration file only affect the specific machine.
The settings for a given machine determine what other hosts can send
commands to that machine.
So, if machine foo is to be given 
administrator access on machine bar, place foo in
bar's configuration file access list (not the other way around).


The following are the various access levels that commands within
Condor can be registered with:

\begin{description}

\item[\DCPerm{READ}] \label{dcperm:read} Machines with \DCPerm{READ}
   access can read information from Condor.  For example, they can
   view the status of the pool, see the job queue(s) or view user
   permissions.  \DCPerm{READ} access does not allow a machine to
   change anything, and it does not allow
   job submission. A machine listed
   with \DCPerm{READ} permission cannot join a Condor pool; the machine can
   only view information about the pool.

\item[\DCPerm{WRITE}] \label{dcperm:write} Machines with
   \DCPerm{WRITE} access can write information to Condor.
   Most notably, a machine can join a pool by sending ClassAd
   updates to the central manager. 
   The machine can talk to the other machines
   in a pool in order to submit or run jobs.
   In addition, any machine with
   \DCPerm{WRITE} access can request the \Condor{startd} daemon to perform a
   periodic checkpoint on a currently executing job. After a
   periodic checkpoint, the job will continue to execute, and the
   machine will still be claimed by whatever \Condor{schedd} daemon had claimed it.
   This allows users on the machines where they submitted their jobs
   to use the \Condor{checkpoint} command to get their jobs to
   periodically checkpoint, even if the users do not have an account on the
   machine where the jobs execute.

   \textbf{IMPORTANT:} For a machine to join a Condor pool, the machine must
   have both \DCPerm{WRITE} permission \textbf{AND} \DCPerm{READ} permission.
   \DCPerm{WRITE} permission is not enough.

\item[\DCPerm{ADMINISTRATOR}] \label{dcperm:administrator} Machines
   with \DCPerm{ADMINISTRATOR} access have additional Condor
   administrator rights to the pool.  This includes the ability to
   change user priorities (with the command \Code{userprio -set}),
   and the ability to turn Condor on and off
   (with the command \Code{off \Sinful{machine}}).
   Typically, very few
   machines are in this list, perhaps only the workstations where the
   Condor administrators or system administrators work,
   or perhaps only the pool's central manager.

   \textbf{IMPORTANT:} This access is given to a machine,
   and it applies to an entire pool.
   So, \DCPerm{ADMINISTRATOR} access for a given machine provides
   \textbf{ANY USER} on that machine \DCPerm{ADMINISTRATOR}
   rights (including users who can run Condor jobs on that machine).
   Therefore, grant \DCPerm{ADMINISTRATOR} access carefully.

\item[\DCPerm{OWNER}] \label{dcperm:owner} This level of access is
   required for commands that the owner of a machine (any local user)
   should be able to use, in addition to the Condor administrators.
   For example, the \Condor{vacate} command causes the
   \Condor{startd} daemon to vacate any running Condor job.
   It requires \DCPerm{OWNER} permission,
   so that any user logged into a local machine
   can issue a \Condor{vacate} command.

\item[\DCPerm{NEGOTIATOR}] \label{dcperm:negotiator} This 
   access level is used specifically to verify that commands are
   sent by the \Condor{negotiator} daemon.
   The \Condor{negotiator} daemon runs on the central manager of
   the pool.
   Commands requiring this access
   level are the ones that tell the \Condor{schedd} daemon to begin
   negotiating, and those that tell an available \Condor{startd} daemon
   that it has been matched to a \Condor{schedd} with jobs to run.

\item[\DCPerm{CONFIG}] \label{dcperm:config} This access level is
   required to modify a daemon's configuration using
   the \Condor{config\_val} command.
   By default, machines with this level of access are able 
   to change any configuration parameters, except those specified in
   the \File{condor\_config.root} configuration file.
   Therefore, granting this level of host-wide access requires
   extreme caution.
   By default, \DCPerm{CONFIG} access is denied for all hosts.

\end{description}

Starting with version 6.3.2, Condor provides a mechanism for more
fine-grained control over the configuration settings that can be
modified remotely with \Condor{config\_val}.  

Host-based security access
permissions are specified in configuration files.

\DCPerm{ADMINISTRATOR} and \DCPerm{NEGOTIATOR} access default to 
the central manager machine.
\DCPerm{OWNER} access defaults to the local machine, as well as
any machines
given with \DCPerm{ADMINISTRATOR} access.
\DCPerm{CONFIG} access is not granted to any machine
as its default.
These defaults work well, and should not be changed without
a compelling reason.
If machines other than the default are to have to have \DCPerm{OWNER}
access, they probably should also have \DCPerm{ADMINISTRATOR} access.
By granting machines \DCPerm{ADMINISTRATOR} access, they
will automatically have \DCPerm{OWNER} access, given how
\DCPerm{OWNER} access is set within the configuration.

The default access configuration is
\begin{verbatim}
HOSTALLOW_ADMINISTRATOR = $(CONDOR_HOST)
HOSTALLOW_OWNER = $(FULL_HOSTNAME), $(HOSTALLOW_ADMINISTRATOR)
HOSTALLOW_READ = *
HOSTALLOW_WRITE = *
HOSTALLOW_NEGOTIATOR = $(NEGOTIATOR_HOST)
HOSTALLOW_NEGOTIATOR_SCHEDD = $(NEGOTIATOR_HOST), $(FLOCK_NEGOTIATOR_HOSTS)
HOSTALLOW_WRITE_COLLECTOR = $(HOSTALLOW_WRITE), $(FLOCK_FROM)
HOSTALLOW_WRITE_STARTD    = $(HOSTALLOW_WRITE), $(FLOCK_FROM)
HOSTALLOW_READ_COLLECTOR  = $(HOSTALLOW_READ), $(FLOCK_FROM)
HOSTALLOW_READ_STARTD     = $(HOSTALLOW_READ), $(FLOCK_FROM)
\end{verbatim}

For each access level, an ALLOW or a DENY may be added.
\begin{itemize}

\item If you have an ALLOW, it means "only allow these machines".  No
    ALLOW means allow anyone.

\item If you have a DENY, it means "deny these machines".  No DENY
    means to deny nobody.

\item If you have both an ALLOW and a DENY, it means allow the
    machines listed in ALLOW except for the machines listed in DENY.

\item Exclusively for the \DCPerm{CONFIG} access,
    no ALLOW means allow no one.
    Note that this is different than the other ALLOW configurations.
    It is different to enable more stringent security where
    older configurations are used, since
    older configuration files would not have a 
    \DCPerm{CONFIG} configuration entry.
\end{itemize}

Multiple machine entries
in the configuration files
may be separated by either a space or a comma.
The machines may be listed by

\begin{itemize}
\item Individual host names - for example: condor.cs.wisc.edu
\item Individual IP address - for example: 128.105.67.29
\item IP subnets (use a trailing ``*'') - for example: 144.105.*, 128.105.67.*
\item Host names with a wildcard ``*'' character (only one ``*'' is
    allowed per name) - for example: *.cs.wisc.edu, sol*.cs.wisc.edu
\end{itemize}

To resolve an entry that falls into both allow and deny:
individual
machines have a higher order of precedence than wildcard entries, and
host names with a wildcard have a higher order of precedence than IP
subnets.
Otherwise, DENY has a higher order of precedence than ALLOW.
(this is how most people would intuitively expect it to work).  

In addition, the above access levels may be specified on a
per-daemon basis, instead of machine-wide for all daemons.
Do this with the subsystem string (described in
section~\ref{sec:Condor-Subsystem-Names} on Subsystem Names),
which is one of: STARTD, SCHEDD, MASTER, NEGOTIATOR,
or COLLECTOR.
For example, to grant different read access for the \Condor{schedd}:
\begin{verbatim}
        HOSTALLOW_READ_SCHEDD = <list of machines>
\end{verbatim}

The following is a list of registered commands that daemons will
accept.  The list is ordered by daemon.
For each daemon, the commands are grouped by the access level
required for a daemon to accept the command from a
given machine.

ALL DAEMONS:

\begin{description}
\item[\DCPerm{WRITE}]

  The command sent as a result of \Condor{reconfig} to reconfigure a daemon.

\item[\DCPerm{ADMINISTRATOR}]

  The command sent as a result of \Code{reconfig -full}
  to perform a full reconfiguration on a daemon. 
\end{description}

STARTD:

\begin{description}
\item[\DCPerm{WRITE}] 

All commands that relate to a \Condor{schedd} daemon claiming
  a machine, starting jobs there, or stopping those jobs.

The command that \Condor{checkpoint} sends to periodically checkpoint
  all running jobs.

\item[\DCPerm{READ}]

The command that \Condor{preen} sends to request the
  current state of the \Condor{startd} daemon.

\item[\DCPerm{OWNER}]
The command that \Condor{vacate} sends to cause
  any running jobs to stop running.

\item[\DCPerm{NEGOTIATOR}]
The command that the \Condor{negotiator} daemon sends to
  match a machine's \Condor{startd} daemon with a given \Condor{schedd}
  daemon.
\end{description}

NEGOTIATOR:

\begin{description}
\item[\DCPerm{WRITE}]
The command that initiates a new negotiation
  cycle. It is sent by the \Condor{schedd} when new jobs are submitted
  or a \Condor{reschedule} command is issued.

\item[\DCPerm{READ}]
The command that can retrieve the current state
  of user priorities in the pool (sent by the \Condor{userprio} command).

\item[\DCPerm{ADMINISTRATOR}]
The command that can set the current
  values of user priorities (sent as a result of the \Code{userprio -set}
  command).
\end{description}

COLLECTOR:

\begin{description}
\item[\DCPerm{WRITE}]
All commands that update the \Condor{collector} daemon with new ClassAds.

\item[\DCPerm{READ}]
All commands that query the \Condor{collector} daemon for ClassAds.
\end{description}

SCHEDD: 

\begin{description}
\item[\DCPerm{NEGOTIATOR}]
The command that the \Condor{negotiator} sends to
  begin negotiating with this \Condor{schedd} to match its jobs with available
  \Condor{startds}.

\item[\DCPerm{WRITE}]
The command which \Condor{reschedule} sends to
  the \Condor{schedd} to get it to update the \Condor{collector} with a current ClassAd
  and begin a negotiation cycle.

  The commands that a \Condor{startd} sends to the \Condor{schedd} when it must vacate
  its jobs and release the \Condor{schedd's} claim.

  The commands which write information into the job queue (such as
  \Condor{submit} and \Condor{hold}).  
  Note that for most commands which attempt to write to the job queue, Condor
  will perform an additional user-level authentication step.  
  This additional user-level authentication prevents, for example, an
  ordinary user from removing a different user's jobs.

\item[\DCPerm{READ}]
The command from any
  tool to view the status of the job queue.  
\end{description}

MASTER:  All commands are registered with \DCPerm{ADMINISTRATOR}
access:

\begin{description}
\item[restart] : Master restarts itself (and all its children)	
\item[off] : Master shuts down all its children
\item[off -master] : Master shuts down all its children and exits
\item[on] : Master spawns all the daemons it is configured to spawn
\end{description}


This section provides examples of configuration settings.
Notice that \DCPerm{ADMINISTRATOR} access is
only granted through a HOSTALLOW setting to explicitly grant access to
a small number of machines.  We recommend this.

\begin{itemize}

\item Let any machine join your pool.
Only the central manager has
administrative access (this is the default that ships with Condor)
\begin{verbatim}
HOSTALLOW_ADMINISTRATOR = $(CONDOR_HOST)
HOSTALLOW_OWNER = $(FULL_HOSTNAME), $(HOSTALLOW_ADMINISTRATOR)
\end{verbatim}

\item Only allow machines at NCSA to join or view the pool.
The central manager is the only machine with \DCPerm{ADMINISTRATOR} access.
\begin{verbatim}
HOSTALLOW_READ = *.ncsa.uiuc.edu
HOSTALLOW_WRITE = *.ncsa.uiuc.edu
HOSTALLOW_ADMINISTRATOR = $(CONDOR_HOST)
HOSTALLOW_OWNER = $(FULL_HOSTNAME), $(HOSTALLOW_ADMINISTRATOR)
\end{verbatim}

\item Only allow machines at NCSA and the U of I Math department join the
pool, EXCEPT do \textbf{not} allow lab machines to do so.
Also, do not
allow the 177.55 subnet (perhaps this is the dial-in subnet).
Allow anyone to view pool statistics.  The machine named
bigcheese administers the pool (not the central manager).
\begin{verbatim}
HOSTALLOW_WRITE = *.ncsa.uiuc.edu, *.math.uiuc.edu
HOSTDENY_WRITE = lab-*.edu, *.lab.uiuc.edu, 177.55.*
HOSTALLOW_ADMINISTRATOR = bigcheese.ncsa.uiuc.edu
HOSTALLOW_OWNER = $(FULL_HOSTNAME), $(HOSTALLOW_ADMINISTRATOR)
\end{verbatim}

\item Only allow machines at NCSA and UW-Madison's CS department to
view the pool.  Only NCSA machines and the machine raven.cs.wisc.edu can join
the pool.
(Note: the machine raven has the read access it needs through the
wildcard setting in \Macro{HOSTALLOW\_READ}).
This example also shows
how to use ``\verb@\@'' to continue a long list of machines
onto multiple lines, making it more readable (this works for all
configuration file entries, not just host access entries)
\begin{verbatim}
HOSTALLOW_READ = *.ncsa.uiuc.edu, *.cs.wisc.edu
HOSTALLOW_WRITE = *.ncsa.uiuc.edu, raven.cs.wisc.edu
HOSTALLOW_ADMINISTRATOR = $(CONDOR_HOST), bigcheese.ncsa.uiuc.edu, \
                          biggercheese.uiuc.edu
HOSTALLOW_OWNER = $(FULL_HOSTNAME), $(HOSTALLOW_ADMINISTRATOR)
\end{verbatim}

\item Allow anyone except the military to view the status of the
pool, but only let machines at NCSA view the job queues.
Only NCSA machines can join the pool.
The central manager, bigcheese, and
biggercheese can perform most administrative functions.
However, only biggercheese can update user priorities.
\begin{verbatim}
HOSTDENY_READ = *.mil
HOSTALLOW_READ_SCHEDD = *.ncsa.uiuc.edu 
HOSTALLOW_WRITE = *.ncsa.uiuc.edu
HOSTALLOW_ADMINISTRATOR = $(CONDOR_HOST), bigcheese.ncsa.uiuc.edu, \
                          biggercheese.uiuc.edu
HOSTALLOW_ADMINISTRATOR_NEGOTIATOR = biggercheese.uiuc.edu
HOSTALLOW_OWNER = $(FULL_HOSTNAME), $(HOSTALLOW_ADMINISTRATOR)
\end{verbatim}

\end{itemize}

A new security feature introduced in
Condor version 6.3.2 enables more fine-grained control over the
configuration settings that can be modified remotely with the
\Condor{config\_val} command.
The manual page for \Condor{config\_val} on
page~\pageref{man-condor-config-val} details how to use 
\Condor{config\_val} to modify configuration settings remotely. 
Since certain configuration attributes can have a large impact on the 
functioning of the Condor system and the security of the machines in a
Condor pool, it is important to restrict the ability to change
attributes remotely.

For each security access level described,
the Condor
administrator can define which configuration settings a host at that
access level is allowed to change.
Optionally, the administrator can define separate lists of settable
attributes for each Condor daemon, or the administrator
can define one list that is used by all daemons.

For each command that requests a change in configuration setting,
Condor searches all the different possible security access
levels to see which, if any, the request satisfies.
(Some hosts can qualify for multiple access levels. For example, any
host with \DCPerm{ADMINISTRATOR} permission probably has
\DCPerm{WRITE} permission also).
Within the qualified access level,
Condor searches for the list of attributes that may be modified.
If the request is covered by the list,
the request will be granted.
If not covered, the request will be refused.

The default configuration shipped with Condor is exceedingly
restrictive.
Condor users or administrators cannot set
configuration values from remote hosts with \Condor{config\_val}.
Enabling this feature requires a change to the
settings in the configuration file.
Use this security feature carefully.
Grant access only for attributes which you need to be able to modify
in this manner, and grant access only at the most restrictive
security level possible.

The most secure use of this feature allows Condor users to set
attributes in the configuration file which are not used by Condor
directly.
These are custom attributes published by various Condor
daemons with the \Macro{SUBSYS\_EXPRS} setting described in
section~\ref{param:SubsysExprs} on page~\pageref{param:SubsysExprs}.
It is secure to grant access only to modify attributes that are used by Condor
to publish information.
Granting access to modify
settings used to control the behavior of Condor is
not secure.
The goal is to
ensure no
one can use the power to change configuration attributes to compromise 
the security of your Condor pool.

The control lists are defined by configuration settings that contain 
\Macro{SETTABLE\_ATTRS} in their name.
The name of the control lists have the following form: 

\begin{verbatim}
SUBSYS_SETTABLE_ATTRS_PERMISSION-LEVEL
\end{verbatim}

The two parts of this name that can vary are
PERMISSION-LEVEL and the SUBSYS.
The PERMISSON-LEVEL can be any of the security access levels
described earlier in this section.
Examples include \DCPerm{WRITE}, \DCPerm{OWNER}, and \DCPerm{CONFIG}.

The SUBSYS is an optional portion of the name. 
It can be used to
define separate rules for which configuration attributes can be set
for each kind of Condor daemon (for example, STARTD, SCHEDD, MASTER).
There are many configuration settings that can be defined differently
for each daemon that use this SUBSYS naming convention.
See section~\ref{sec:Condor-Subsystem-Names} on
page~\pageref{sec:Condor-Subsystem-Names} for a list.
If there is no daemon-specific value for a given daemon, Condor will
look for \Macro{SETTABLE\_ATTRS\_PERMISSION-LEVEL}.

Each control list is defined by a comma-separated list of attribute
names which should be allowed to be modified.
The lists can contain wildcards characters (`*'). 

Some examples of valid definitions of control lists with explanations:

\begin{itemize}

\item \begin{verbatim}SETTABLE_ATTRS_CONFIG = *\end{verbatim}
Grant unlimited access to modify configuration attributes
to any request that came from a machine in the \DCPerm{CONFIG} access
level. 
This was the default behavior before Condor version 6.3.2.

\item \begin{verbatim}SETTABLE_ATTRS_ADMINISTRATOR = *_DEBUG, MAX_*_LOG\end{verbatim} 
Grant access to change any configuration setting that ended
with ``\_DEBUG'' (for example, \Macro{STARTD\_DEBUG}) and any
attribute that matched ``MAX\_*\_LOG'' (for example,
\Macro{MAX\_SCHEDD\_LOG}) to any host with \DCPerm{ADMINISTRATOR}
access. 

\item \begin{verbatim}STARTD_SETTABLE_ATTRS_OWNER = HasDataSet\end{verbatim}
Allows any request to modify the \Macro{HasDataSet} 
attribute that came from a host with \DCPerm{OWNER} access.
By default, \DCPerm{OWNER} covers any request originating from the
local host, plus any machines listed in the \DCPerm{ADMINISTRATOR}
level.
Therefore, any Condor job would qualify for OWNER access to the
machine where it is running. 
So, this setting would allow any process running on a given host,
including a Condor job, to modify the \Macro{HasDataSet} variable for
that host. 
\Macro{HasDataSet} is not used by Condor, it is an invented attribute
included in the \Macro{STARTD\_EXPRS} setting in order for this
example to make sense.

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\label{sec:security-networks}
Using Condor w/ Firewalls, Private Networks, and NATs}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{security!firewalls}
\index{security!private networks}
\index{security!NATs}

\index{security! in Condor|)}
