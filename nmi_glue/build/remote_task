#!/usr/bin/env perl

######################################################################
# $Id: remote_task,v 1.1.4.5.40.1 2006-02-21 19:34:13 bt Exp $
# Perform a given build task, and return the status of that task
# 0 = success
# 1 = build failed
# 3 = internal fatal error (a.k.a. die)
######################################################################

use Cwd;
my $BaseDir = getcwd();
my $SrcDir = "$BaseDir/src";
my $NTConfigDir = "$BaseDir/NTconfig";
my $PublicDir = "$BaseDir/public";

# WINDOWS SPECIFIC ENV...
if ($ENV{NMI_PLATFORM} =~ /winnt/) {
    $BaseDir =~ s/\//\\/g;
    $SrcDir = "$BaseDir\\src";
    $NTConfigDir = "$BaseDir\\NTconfig";
    $PublicDir = "$BaseDir\\public";
    $ENV{USERPROFILE} = "c:\\temp";
    $ENV{TMP} = "c:\\temp";
    $ENV{PATH} .= ";\"C:\\Program Files\\Microsoft Visual Studio\\VC98\\Bin\"";
    $ENV{PATH} .= ";\"C:\\Program Files\\Microsoft Platform SDK for Windows XP SP2\"";
    $ENV{PATH} .= ";$NTConfigDir";
}

# autoflush our STDOUT
$| = 1;

######################################################################
###### WARNING!!!  The return value of this script has special  ######
###### meaning, so you can NOT just call die().  you MUST       ######
###### use the special c_die() method so we return 3!!!!        ######
######################################################################

if( ! defined $ENV{_NMI_TASKNAME} ) {
    c_die("_NMI_TASKNAME not in environment, can't build anything!\n");
}
my $taskname = $ENV{_NMI_TASKNAME};
if( ! $taskname ) {
    # if we have no task, just return success immediately
    print "No tasks specified, returning SUCCESS\n";
    exit 0;
}

print "------------------------- ENV DUMP ------------------------\n";
if ($ENV{NMI_PLATFORM} =~ /winnt/) {
    system("set");
} 
else {
    system("env");
}
print "------------------------- ENV DUMP ------------------------\n";
######################################################################
# build the task
######################################################################


if ($taskname eq "win_make") {
    chdir("$NTConfigDir") || c_die("Can't chdir($NTConfigDir): $!\n");
    system("make.bat /exit");
}
elsif ($taskname eq "win_release") {
    mkdir("$PublicDir", 0777) || c_die ("Can't mkdir($PublicDir): $!\n");
    chdir("$NTConfigDir") || c_die("Can't chdir($NTConfigDir): $!\n");
    system("dorelease $PublicDir");
}
else {
    chdir("$SrcDir") || c_die("Can't chdir($SrcDir): $!\n");
    open( BUILD, "make $taskname 2>&1 |" ) || 
        c_die("Can't run make $taskname\n");
    while( <BUILD> ) {
        print $_;
    }
    close( BUILD );
}
$buildstatus = $?;
if( $buildstatus == 0 ) {
    print "Building $taskname: SUCCESS\n";
    exit 0;
}

print "Building $taskname: FAILURE ($buildstatus)\n";
if( $taskname eq "externals" && -d "$BaseDir/externals/build" ) {
    # if the externals failed to build, we want to grab a copy of all
    # the build logs from the externals tree into our public output
    # directory.  however, we only care if we got far enough into the
    # externals build process to have any build logs
    if( ! -d "$BaseDir/public" ) {
        mkdir( "$BaseDir/public", 0777 ) || 
            c_die("Can't mkdir($BaseDir/public): $!\n");
    }
    $pub_ext_log = "$BaseDir/public/external-logs";
    if( ! -d "$pub_ext_log" ) {
        mkdir( "$pub_ext_log", 0777 ) || 
            c_die("Can't mkdir($pub_ext_log): $!\n");
    }
    $ext_build = "$BaseDir/externals/build";
    opendir( DIR, "$ext_build" ) || 
        c_die("Failed to opendir($ext_build): $!\n");
    @files = readdir(DIR);
    closedir DIR;
    foreach $file ( @files ) {
        if( $file =~ /log\..*/ ) {
            system( "cp $ext_build/$file $pub_ext_log" );
            if( $? >> 8 ) {
                c_die("Can't cp $ext_build/$file $pub_ext_log\n");
            }
        }
    }
}
exit 1;


sub c_die {
    my( $msg ) = @_;
    print $msg;
    exit 3;
}
