#!/usr/bin/env perl
##**************************************************************
##
## Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
## University of Wisconsin-Madison, WI.
## 
## Licensed under the Apache License, Version 2.0 (the "License"); you
## may not use this file except in compliance with the License.  You may
## obtain a copy of the License at
## 
##    http://www.apache.org/licenses/LICENSE-2.0
## 
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
##**************************************************************


######################################################################
# script to setup the Condor build
######################################################################

use Cwd;

use Getopt::Long;
use vars qw/ $opt_use_externals_cache $opt_clear_externals_cache /;
GetOptions(
            'use_externals_cache' => \$opt_use_externals_cache,
            'use-externals-cache' => \$opt_use_externals_cache,
            'clear_externals_cache' => \$opt_clear_externals_cache,
            'clear-externals-cache' => \$opt_clear_externals_cache,
            'clear_externals_cache_weekly' => \$opt_clear_externals_cache_weekly,
            'clear-externals-cache-weekly' => \$opt_clear_externals_cache_weekly,
);


my $BaseDir = getcwd();
my $SrcDir = "$BaseDir/src";
my $vers_file = "CONDOR-VERSION";
my $buildid_file = "BUILD-ID";
my $buildid;

# autoflush our STDOUT
$| = 1;

print "------------------------- ENV DUMP ------------------------\n";
if ($ENV{NMI_PLATFORM} =~ /winnt/) {
    system("set");
} else {
    system("env");
}
print "------------------------- ENV DUMP ------------------------\n";

######################################################################
# grab out the build id so we can tell configure what to use for the
# version string.
######################################################################
print "Finding build id of Condor\n";
open( BUILDID, "$buildid_file" ) || die "Can't open $buildid_file: $!\n";
while( <BUILDID> ) {
    chomp;
    $buildid = $_;
}
close( BUILDID );
if( ! $buildid ) {
    die "Can't find Condor build id in $buildid_file!\n";
}
print "Build id is: $buildid\n";
$buildid = " --with-buildid=$buildid ";

######################################################################
# grab the Condor version out of the version file so we can unpack our 
# source tarball and get everything ready for the other steps.
######################################################################

print "Finding version of Condor\n";
open( VERS, "$vers_file" ) || die "Can't open $vers_file: $!\n";
while( <VERS> ) {
    chomp;
    $vers = $_;
}
close( VERS );
if( ! $vers ) {
    die "Can't find Condor version in $vers_file!\n";
}
print "Condor version: $vers\n";
$src_file = "condor-$vers.tar.gz";
-f $src_file || die "$src_file does not exist!\n";

print "**************************************************\n";
print "Untarring Condor source tarball\n";
print "**************************************************\n";
open( TAR, "tar -zxvf $src_file|" ) ||
    die "Can't open(tar -zxvf $src_file): $!\n";
while( <TAR> ) {
    print $_;
}
close( TAR );
print "**************************************************\n";
if( $? ) {
    die "Tar failed with status $?\n";
}
print "Tar completed successfully, moving contents to base directory\n";

system( "mv condor-$vers/* $BaseDir" );
if( $? ) {
    die "moving condor-$vers/* to $BaseDir failed with status $?\n";
}
print "Move completed successfully\n";


### EXIT POINT FOR WINDOWS ### 

if ($ENV{NMI_PLATFORM} =~ /winnt/) {
    print "SKIPPING external caching and configure step for windows\n";
    exit 0;
}

###
# Update the external cache
#
# - matt 9 oct 2007
###

# Problems:
#  Multiple writers? Two builds on the same system when the cache
#  either does not exist or has stale data could try to update the
#  cache at the same time. Is the multiple writer situation likely?
#   Solution: Put a lock on the cache and retry + fail over to no
#    cache.
#   Problems: Stale locks? A stale lock would have to be manually
#    removed.
#  External changes? A workspace/branch build that changes an external
#  without changing its version could change the externals seen by an
#  already running build on the same system.
#   Solution: Do not change externals without changing their version.

$old = "/scratch/externals"; # the cache, likely /scratch/externals
$new = "$BaseDir/externals"; # the new version. likely ./externals

# People need to be somewhat careful if they are going to use the
# externals cache. At a minimum they need to make sure they are not
# updating an external without changing its version, all the externals
# they are building should succeed, and they should not remove their
# build jobs while an external is building.
print "use_externals_cache: $opt_use_externals_cache\n";
if (!defined($opt_use_externals_cache)) {
    goto bail;
}

print "Checking externals cache in '$old'...\n";

#
# Perform sanity checks to get a good idea if we can properly access
# the cache
#

(! -e "$old") &&
    system("mkdir -m 0777 -p $old") &&
    print "Failed to create '$old'\n" &&
    goto bail;

# Permissions...
(! -r "$old" || ! -w "$old") &&
    print "No permissions to write '$old'\n" &&
    goto bail;

# Actually a directory...
(! -d "$old") &&
    print "'$old' is a file, not a directory\n" &&
    goto bail;

if (defined($opt_clear_externals_cache_weekly)) {
	@now = localtime;
	@then = localtime( (stat( $old ))[9] );
	if ( ($now[7] - $now[6]) != ($then[7] - $then[6]) ) {
		print "Doing weekly cache clearing\n";
		$opt_clear_externals_cache = 1;
	}
}

# If we want to clear the cache or if the script used to build
# externals changes we better clear the cache
if (defined($opt_clear_externals_cache)) {
    print "Clearing cache " .
	"(clear_externals_cache: $opt_clear_externals_cache)...\n";
    system("rm -r $old/*");
    (-e "$old/bundles" ) &&
	print "Failed to remove '$old/bundles'\n" &&
	goto bail;
    (-e "$old/build" ) &&
	print "Failed to remove '$old/build'\n" &&
	goto bail;
    (-e "$old/install" ) &&
	print "Failed to remove '$old/install'\n" &&
	goto bail;
    (-e "$old/triggers" ) &&
	print "Failed to remove '$old/triggers'\n" &&
	goto bail;
    (-e "$old/build_external" ) &&
	print "Failed to remove '$old/build_external'\n" &&
	goto bail;
}

success:
{
    # We want to always make sure that the cache directory is
    # maximally permissive, this also cleans up cases where
    # permissions were too restrictive in the past
    system("chmod -f -R a+rwX $old");
    $externals = $old;
    print "...using cache...\n";
    goto configure; # skip bail label
}

bail:
{
    print "...skipping cache...\n";
    $externals = $new;
}

configure:
######################################################################
# run configure on the source tree
######################################################################

chdir( $SrcDir ) || die "Can't chdir($SrcDir): $!\n";

print "running CONFIGURE ...\n"; 
my $configexecstr = 
      "./configure " .
	  $buildid .
      " --enable-soft-is-hard " .
      " --with-externals=$externals";

print "$configexecstr\n";

open( CONFIG, "$configexecstr 2>&1 |") ||
    die "Can't open configure as a pipe: $!\n";
while ( <CONFIG> ) {
  print $_;
}
close( CONFIG );
$configstat = $?;
print "CONFIGURE returned a code of $configstat\n"; 
($configstat == 0) || die "CONFIGURE failed, aborting build\n";  

