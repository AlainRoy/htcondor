#!/usr/bin/env perl
##**************************************************************
##
## Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
## University of Wisconsin-Madison, WI.
## 
## Licensed under the Apache License, Version 2.0 (the "License"); you
## may not use this file except in compliance with the License.  You may
## obtain a copy of the License at
## 
##    http://www.apache.org/licenses/LICENSE-2.0
## 
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
##**************************************************************


######################################################################
# $Id: pre_all,v 1.12 2007-12-01 21:38:01 gthain Exp $ 
# Submit-side NMI build system infrastructure to prepare sources for
# the Condor build
#
# We assume the 'common' subdir contains everything we checked out of
# CVS.  We need to go into that directory, and do a few things:
# 1) Figure out what version of Condor we're building
# 2) build_init so we have a working configure script
# 3) build the nroff source for the man pages so that the man-current
#    external package will work
# 4) Setup the sources as a release-able source tarball
# 5) Make the platform-independent results.tar.gz
# 6) Save the cvs diffs between this builds and the previous
######################################################################

######################################################################
# NOTE: This script depends on the following bootstrap programs:
# - GNU tar (so long as it supports --exclude)
# - GNU autoconf and autoheader (version >= 2.59) [used by build_init]
# - everything required for "make nroff"
#    - latex
#    - latex2html
#    ...  ;) (could fill this in later)
######################################################################

use Cwd;

use Getopt::Long;
use vars qw/ $opt_version_buildid /;
GetOptions(
  'version-buildid=s' => \$opt_version_buildid,
);

# autoflush our STDOUT
$| = 1;

# NOTE: when/if the NMI framework provides a cleaner way to define
# submit-host prereqs, we should use it.  for now, we have to hard-code
my $autoconf_path = "/prereq/autoconf-2.59/bin";
$ENV{PATH} = "$autoconf_path:$ENV{PATH}";

my $CommonDir = getcwd();
my $SrcDir = "$CommonDir/src";
my $DocDir = "$CommonDir/doc";
my $ExtDir = "$CommonDir/externals";

-d $CommonDir || die "$CommonDir does not exist!\n";
-d $SrcDir || die "$SrcDir does not exist!\n";
-d $DocDir || die "$DocDir does not exist!\n";
-d $ExtDir || die "$ExtDir does not exist!\n";
-d "$ExtDir/bundles" || die "$ExtDir/bundles does not exist! "
   . "(build tag probably doesn't include externals)\n";


my $result = "results.tar.gz";


######################################################################
# 1) Figure out what version of Condor we're building
######################################################################

print "Figuring out Condor version\n";
chdir( "$CommonDir" ) || die "Can't chdir($CommonDir): $!\n";
my $vers_src="$SrcDir/condor_c++_util/condor_version.cpp";
my $vers_file="CONDOR-VERSION";
my $buildid_file="BUILD-ID";
my $majorv;
my $minorv;
my $releasev;
my $version;

open( VERS_SRC, "<$vers_src" ) || die "Can't open $vers_src: $!\n";
while( <VERS_SRC> ) {
    if( /^static char\* CondorVersionString = \"\$CondorVersion: (\d+)\.(\d+)\.(\d+).*/ ) {
	$majorv = $1;
	$minorv = $2;
	$releasev = $3;
	$version = "$majorv.$minorv.$releasev";
	last;
    }
}
close( VERS_SRC );
if( $version =~ /(\d+)\.(\d+)\.(\d+)/ ) {
    print "Condor version is: $version\n";
} else {
    die "ERROR: Can't parse the version string!";
}
open( VERS_FILE, ">$vers_file") || die "Can't open $vers_file: $!\n";
print VERS_FILE "$version";
close( VERS_FILE );


######################################################################
# Step #2: run build_init
######################################################################

my $cmd="./build_init";
print "Running $cmd to generate configure script\n";
chdir( "$SrcDir" ) || die "Can't chdir($SrcDir): $!\n";
system( $cmd );
$cmd_status = $?;
if( $cmd_status ) {
    die "$cmd failed with status $cmd_status\n";
}
system( "rm -rf autom4te.cache" );
$status = $?;
if( $status ) {
    warn "Can't remove autom4te.cache directory!\n";
}
print "Finished generating configure script\n";


######################################################################
# Step #3: build nroff sources
######################################################################

print "Building man page nroff source\n";
chdir( "$DocDir" ) || die "Can't chdir($DocDir): $!\n";
my $doc_log = "$CommonDir/nroff.log";
open( DOC, "make just-man-pages 2>&1|" ) || die "Can't open 'make just-man-pages': $!\n";
open( DOC_LOG, ">$doc_log" ) || die "Can't open $doc_log: $!\n";
$oldfh = select(DOC_LOG); $| = 1; select($oldfh);
while( <DOC> ) {
    print DOC_LOG "$_";
}
close( DOC );
close( DOC_LOG );
$nroff_status = $?;
if( $nroff_status ) {
	print `cat $doc_log`;
    die "Building nroff man pages failed with status $nroff_status!\n";
} else {
    unlink( $doc_log ) || warn "Can't unlink($doc_log): $!\n";
}
print "Building nroff man pages successful, tar'ing up results\n";
-d "$ExtDir/bundles/man/current" || 
   die "$ExtDir/bundles/man/current doesn't exist! Build tag broken\n";
system("tar zcf $ExtDir/bundles/man/current/man-current.tar.gz man");
print "Finished packaging man page nroff source\n";

chdir( "$CommonDir" ) || die "Can't chdir($CommonDir): $!\n";
print "Removing doc directory\n";
system( "rm -rf $DocDir" );
print "Done removing doc directory\n";


######################################################################
# 4) Record some cvs archeology
######################################################################

print "Checking if this build came from CVS, and if so, from which tags\n";
chdir( "$CommonDir" ) || die "Can't chdir($CommonDir): $!\n";

my $tagname = "";
open( TAGFILE, "src/CVS/Tag"); # if it doesn't exist, that's ok

print ("Opened src/CVS/Tag\n");

while (<TAGFILE>) {
	# If there's a tag entry, read it in,
	$tagname = $_;

	print("Found tag named $tagname \n");

	# remove the newline
	chomp $tagname;

	# Remove the leading "T" for tag
	$tagname =~ s/^T//;
}

# Tagname must have something in it to continue
if ($tagname ne "") {

	print "This build uses tag $tagname \n";

	my $buildName = "";
	open(CURRENT, "/space/cvs/nwo-build-tags");
	while(<CURRENT>) {
		if (/^([^\t]+)\t$tagname/) {
			$buildName = $1;
		}
	}

	if ($buildName ne "") {
		print "$tagname is build named $buildName \n";

		my $prevtagname = "";
		open(PREVIOUS, "/space/cvs/nwo-build-tags.old");
		while(<PREVIOUS>) {
			if (/^$buildName\t(.+)/) {
				$prevtagname = $1;
			}
		}

		if ($prevtagname ne "") {

		print "Previous tag was $prevtagname \n";

		# cd into src directory to get saved CVSROOT
		chdir("$CommonDir/src") || die ("Can't chdir into src");

		print "Running cvs log -r ${prevtagname}::${tagname}\n";

		system("cvs -q log -N -S -r${prevtagname}::${tagname} 2>/dev/null > ${CommonDir}/cvslog.txt");

		print "Running cvs diff -r ${prevtagname} -r ${tagname}\n";
		system("cvs -q diff -r ${prevtagname} -r ${tagname} 2>/dev/null > ${CommonDir}/cvsdiffs.txt");
		}
	}

}

######################################################################
# 4.5) Create a buildid file which represents the runid of this build
######################################################################

print "Creating embedded buildid\n";
chdir( "$CommonDir" ) || die "Can't chdir($CommonDir): $!\n";

# Stash this in the common dir for remote_pre
if (defined($opt_version_buildid)) {
  $runid = $opt_version_buildid;
  print "Using build id from command-line: $runid\n";
}
else {
  $runid = acquire_runid();
  print "Automatically discovered that my build id is: $runid\n";
}
open( BUILDID_FILE, ">$buildid_file") || die "Can't open $buildid_file: $!\n";
print BUILDID_FILE "$runid\n";
close( BUILDID_FILE );


######################################################################
# 5) Setup the sources as a release-able source tarball
######################################################################

print "Creating source tarball\n";
chdir( "$CommonDir" ) || die "Can't chdir($CommonDir): $!\n";
my $src_tar_dir = "condor-$version";
my $src_tarball = "$src_tar_dir.tar.gz";
mkdir( "$src_tar_dir" ) || die "Can't mkdir($src_tar_dir): $!\n";

# cwd must be the CommonDir to get the buildid file
safe_sys( "cp $buildid_file $src_tar_dir" );

safe_sys( "cp $SrcDir/README.building $src_tar_dir" );
safe_sys( "cp src/condor_release/LICENSE-2.0.txt $src_tar_dir" );
safe_sys( "mv NTconfig config imake src externals $src_tar_dir" );
safe_sys( "tar --exclude=CVS -zcf $src_tarball $src_tar_dir" );
print "Done creating source tarball\n";

print "Removing all source directories\n";
safe_sys( "rm -rf $src_tar_dir" );
print "Done removing all source directories\n";


######################################################################
# 6) Create platform-independent results.tar.gz file
######################################################################

# All we want to do is tar the files in common into
# common/results.tar.gz so that we can save them.
print "Creating platform-independent results.tar.gz file\n";
chdir( "$CommonDir" ) || die "Can't chdir($CommonDir): $!\n";

print "Tarring up contents of common to save for later\n";
open( TAR, "tar -zcvf $result $buildid_file $vers_file $src_tarball|" ) ||
    die "Can't open(tar -zcvf $result $vers_file $src_tarball): $!\n";
while( <TAR> ) {
    print $_;
}
close( TAR );
if( $? ) {
    die "Tar failed with status $?\n";
}
print "tar completed successfully\n";

print "All steps completed successfully!\n";
exit 0;


######################################################################
# subroutines
######################################################################

sub safe_sys() {
    my ( $arg ) = @_;
    system $arg;
    my $status = $?;
    if( $status ) {
	die "$arg failed with status $status\n";
    }
}

sub acquire_runid() {
	my $runid;
	my $tries = 5;
	my $count = 0;
	my $delay = 60;

	# Try for $tries times, with a delay of $delay, to try and get a runid
	# from the database for this gid. If all else fails, just use the gid
	# (which we don't initially want to use since this is going into
	# the version string of the binaries and it is a user interface mistake to
	# have it in there).
	
	# figure out the runid, if not available, then put in the gid.
	$runid = `nmi_gid2runid $ENV{_NMI_GID} 2>&1`;
	while($count < $tries && ($? != 0 || $runid =~ m/ERROR/)) {
		$count++;
		sleep $delay;
		$runid = `nmi_gid2runid $ENV{_NMI_GID} 2>&1`;
	}
	if ($? != 0 || $runid =~ m/ERROR/) {
		# oops, no runid, so we'll just slam the gid in here for now until we
		# find a better semantic thing to do
		$runid = $ENV{_NMI_GID};
	}
	
	chomp $runid;
	return $runid;
}
